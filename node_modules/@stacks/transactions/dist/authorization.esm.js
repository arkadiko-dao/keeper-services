import { StacksMessageType, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, PubKeyEncoding, AddressHashMode, AuthType } from './constants.esm.js';
import { inheritsLoose as _inheritsLoose } from './_virtual/_rollupPluginBabelHelpers.js';
import { serializePublicKey, compressPublicKey, deserializePublicKey, createStacksPublicKey, isCompressed, signWithKey, getPublicKey, publicKeyFromSignature } from './keys.esm.js';
import BigNum from 'bn.js';
import { DeserializationError, SigningError, SerializationError } from './errors.esm.js';
import { addressFromPublicKeys, serializeLPList, deserializeLPList, createLPList, createEmptyAddress } from './types.esm.js';
import { BufferArray, txidFromData, cloneDeep, leftPadHex } from './utils.esm.js';

var Deserializable = /*#__PURE__*/function () {
  function Deserializable() {}

  Deserializable.deserialize = function deserialize(bufferReader) {
    var message = new this();
    message.deserialize(bufferReader);
    return message;
  };

  return Deserializable;
}();

function createMessageSignature(signature) {
  var length = Buffer.from(signature, 'hex').byteLength;

  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
    throw Error('Invalid signature');
  }

  return {
    type: StacksMessageType.MessageSignature,
    data: signature
  };
}
function emptyMessageSignature() {
  return {
    type: StacksMessageType.MessageSignature,
    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex')
  };
}
function serializeMessageSignature(messageSignature) {
  var bufferArray = new BufferArray();
  bufferArray.appendHexString(messageSignature.data);
  return bufferArray.concatBuffer();
}
function deserializeMessageSignature(bufferReader) {
  return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));
}
var AuthFieldType;

(function (AuthFieldType) {
  AuthFieldType[AuthFieldType["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
  AuthFieldType[AuthFieldType["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
  AuthFieldType[AuthFieldType["SignatureCompressed"] = 2] = "SignatureCompressed";
  AuthFieldType[AuthFieldType["SignatureUncompressed"] = 3] = "SignatureUncompressed";
})(AuthFieldType || (AuthFieldType = {}));

function createTransactionAuthField(pubKeyEncoding, contents) {
  return {
    pubKeyEncoding: pubKeyEncoding,
    type: StacksMessageType.TransactionAuthField,
    contents: contents
  };
}
function serializeTransactionAuthField(field) {
  var bufferArray = new BufferArray();

  switch (field.contents.type) {
    case StacksMessageType.PublicKey:
      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {
        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);
        bufferArray.push(serializePublicKey(field.contents));
      } else {
        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);
        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));
      }

      break;

    case StacksMessageType.MessageSignature:
      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {
        bufferArray.appendByte(AuthFieldType.SignatureCompressed);
      } else {
        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);
      }

      bufferArray.push(serializeMessageSignature(field.contents));
      break;
  }

  return bufferArray.concatBuffer();
}
function deserializeTransactionAuthField(bufferReader) {
  var authFieldType = bufferReader.readUInt8Enum(AuthFieldType, function (n) {
    throw new DeserializationError("Could not read " + n + " as AuthFieldType");
  });

  switch (authFieldType) {
    case AuthFieldType.PublicKeyCompressed:
      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));

    case AuthFieldType.PublicKeyUncompressed:
      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));

    case AuthFieldType.SignatureCompressed:
      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));

    case AuthFieldType.SignatureUncompressed:
      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));

    default:
      throw new Error("Unknown auth field type: " + JSON.stringify(authFieldType));
  }
}
function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {
  var signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;
  var keyEncoding = isCompressed(createStacksPublicKey(pubKey)) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;
  return {
    hashMode: hashMode,
    signer: signer,
    nonce: nonce,
    fee: fee,
    keyEncoding: keyEncoding,
    signature: emptyMessageSignature()
  };
}
function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {
  var stacksPublicKeys = pubKeys.map(createStacksPublicKey);
  var signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;
  return {
    hashMode: hashMode,
    signer: signer,
    nonce: nonce,
    fee: fee,
    fields: [],
    signaturesRequired: numSigs
  };
}
function isSingleSig(condition) {
  return 'signature' in condition;
}

function clearCondition(condition) {
  var cloned = cloneDeep(condition);
  cloned.nonce = new BigNum(0);
  cloned.fee = new BigNum(0);

  if (isSingleSig(cloned)) {
    cloned.signature = emptyMessageSignature();
  } else {
    cloned.fields = [];
  }

  return cloned;
}

function serializeSingleSigSpendingCondition(condition) {
  var bufferArray = new BufferArray();
  bufferArray.appendByte(condition.hashMode);
  bufferArray.appendHexString(condition.signer);
  bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));
  bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));
  bufferArray.appendByte(condition.keyEncoding);
  bufferArray.push(serializeMessageSignature(condition.signature));
  return bufferArray.concatBuffer();
}
function serializeMultiSigSpendingCondition(condition) {
  var bufferArray = new BufferArray();
  bufferArray.appendByte(condition.hashMode);
  bufferArray.appendHexString(condition.signer);
  bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));
  bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));
  var fields = createLPList(condition.fields);
  bufferArray.push(serializeLPList(fields));
  var numSigs = Buffer.alloc(2);
  numSigs.writeUInt16BE(condition.signaturesRequired, 0);
  bufferArray.push(numSigs);
  return bufferArray.concatBuffer();
}
function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {
  var signer = bufferReader.readBuffer(20).toString('hex');
  var nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
  var fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
  var keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, function (n) {
    throw new DeserializationError("Could not parse " + n + " as PubKeyEncoding");
  });
  var signature = deserializeMessageSignature(bufferReader);
  return {
    hashMode: hashMode,
    signer: signer,
    nonce: nonce,
    fee: fee,
    keyEncoding: keyEncoding,
    signature: signature
  };
}
function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {
  var signer = bufferReader.readBuffer(20).toString('hex');
  var nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
  var fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
  var fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField).values;
  var signaturesRequired = bufferReader.readUInt16BE();
  return {
    hashMode: hashMode,
    signer: signer,
    nonce: nonce,
    fee: fee,
    fields: fields,
    signaturesRequired: signaturesRequired
  };
}
function serializeSpendingCondition(condition) {
  if (isSingleSig(condition)) {
    return serializeSingleSigSpendingCondition(condition);
  } else {
    return serializeMultiSigSpendingCondition(condition);
  }
}
function deserializeSpendingCondition(bufferReader) {
  var hashMode = bufferReader.readUInt8Enum(AddressHashMode, function (n) {
    throw new DeserializationError("Could not parse " + n + " as AddressHashMode");
  });

  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {
    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);
  } else {
    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);
  }
}
function makeSigHashPreSign(curSigHash, authType, fee, nonce) {
  var hashLength = 32 + 1 + 8 + 8;
  var sigHash = curSigHash + Buffer.from([authType]).toString('hex') + fee.toArrayLike(Buffer, 'be', 8).toString('hex') + nonce.toArrayLike(Buffer, 'be', 8).toString('hex');

  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {
    throw Error('Invalid signature hash length');
  }

  return txidFromData(Buffer.from(sigHash, 'hex'));
}

function makeSigHashPostSign(curSigHash, pubKey, signature) {
  var hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
  var pubKeyEncoding = isCompressed(pubKey) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;
  var sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;
  var sigHashBuffer = Buffer.from(sigHash, 'hex');

  if (sigHashBuffer.byteLength > hashLength) {
    throw Error('Invalid signature hash length');
  }

  return txidFromData(sigHashBuffer);
}

function nextSignature(curSigHash, authType, fee, nonce, privateKey) {
  var sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);
  var signature = signWithKey(privateKey, sigHashPreSign);
  var publicKey = getPublicKey(privateKey);
  var nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
  return {
    nextSig: signature,
    nextSigHash: nextSigHash
  };
}
function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {
  var sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);
  var publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));
  var nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
  return {
    pubKey: publicKey,
    nextSigHash: nextSigHash
  };
}

function newInitialSigHash() {
  var spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', new BigNum(0), new BigNum(0));
  spendingCondition.signer = createEmptyAddress().hash160;
  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;
  spendingCondition.signature = emptyMessageSignature();
  return spendingCondition;
}

function verify(condition, initialSigHash, authType) {
  if (isSingleSig(condition)) {
    return verifySingleSig(condition, initialSigHash, authType);
  } else {
    return '';
  }
}

function verifySingleSig(condition, initialSigHash, authType) {
  var _nextVerification = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature),
      nextSigHash = _nextVerification.nextSigHash;

  return nextSigHash;
}

var Authorization = /*#__PURE__*/function (_Deserializable) {
  _inheritsLoose(Authorization, _Deserializable);

  function Authorization(authType, spendingConditions, sponsorSpendingCondition) {
    var _this;

    _this = _Deserializable.call(this) || this;
    _this.authType = authType;
    _this.spendingCondition = spendingConditions;
    _this.sponsorSpendingCondition = sponsorSpendingCondition;
    return _this;
  }

  var _proto = Authorization.prototype;

  _proto.intoInitialSighashAuth = function intoInitialSighashAuth() {
    if (this.spendingCondition) {
      switch (this.authType) {
        case AuthType.Standard:
          return new Authorization(AuthType.Standard, clearCondition(this.spendingCondition));

        case AuthType.Sponsored:
          return new Authorization(AuthType.Sponsored, clearCondition(this.spendingCondition), newInitialSigHash());

        default:
          throw new SigningError('Unexpected authorization type for signing');
      }
    }

    throw new Error('Authorization missing SpendingCondition');
  };

  _proto.setFee = function setFee(amount) {
    switch (this.authType) {
      case AuthType.Standard:
        this.spendingCondition.fee = amount;
        break;

      case AuthType.Sponsored:
        this.sponsorSpendingCondition.fee = amount;
        break;
    }
  };

  _proto.getFee = function getFee() {
    switch (this.authType) {
      case AuthType.Standard:
        return this.spendingCondition.fee;

      case AuthType.Sponsored:
        return this.sponsorSpendingCondition.fee;

      default:
        return 0;
    }
  };

  _proto.setNonce = function setNonce(nonce) {
    this.spendingCondition.nonce = nonce;
  };

  _proto.setSponsorNonce = function setSponsorNonce(nonce) {
    this.sponsorSpendingCondition.nonce = nonce;
  };

  _proto.setSponsor = function setSponsor(sponsorSpendingCondition) {
    this.sponsorSpendingCondition = sponsorSpendingCondition;
  };

  _proto.verifyOrigin = function verifyOrigin(initialSigHash) {
    switch (this.authType) {
      case AuthType.Standard:
        return verify(this.spendingCondition, initialSigHash, AuthType.Standard);

      case AuthType.Sponsored:
        return verify(this.spendingCondition, initialSigHash, AuthType.Standard);

      default:
        throw new SigningError('Invalid origin auth type');
    }
  };

  _proto.serialize = function serialize() {
    var bufferArray = new BufferArray();

    if (this.authType === undefined) {
      throw new SerializationError('"authType" is undefined');
    }

    bufferArray.appendByte(this.authType);

    switch (this.authType) {
      case AuthType.Standard:
        if (this.spendingCondition === undefined) {
          throw new SerializationError('"spendingCondition" is undefined');
        }

        bufferArray.push(serializeSpendingCondition(this.spendingCondition));
        break;

      case AuthType.Sponsored:
        if (this.spendingCondition === undefined) {
          throw new SerializationError('"spendingCondition" is undefined');
        }

        if (this.sponsorSpendingCondition === undefined) {
          throw new SerializationError('"spendingCondition" is undefined');
        }

        bufferArray.push(serializeSpendingCondition(this.spendingCondition));
        bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));
        break;

      default:
        throw new SerializationError("Unexpected transaction AuthType while serializing: " + JSON.stringify(this.authType));
    }

    return bufferArray.concatBuffer();
  };

  _proto.deserialize = function deserialize(bufferReader) {
    this.authType = bufferReader.readUInt8Enum(AuthType, function (n) {
      throw new DeserializationError("Could not parse " + n + " as AuthType");
    });

    switch (this.authType) {
      case AuthType.Standard:
        this.spendingCondition = deserializeSpendingCondition(bufferReader);
        break;

      case AuthType.Sponsored:
        this.spendingCondition = deserializeSpendingCondition(bufferReader);
        this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);
        break;

      default:
        throw new DeserializationError("Unexpected transaction AuthType while deserializing: " + JSON.stringify(this.authType));
    }
  };

  return Authorization;
}(Deserializable);
var StandardAuthorization = /*#__PURE__*/function (_Authorization) {
  _inheritsLoose(StandardAuthorization, _Authorization);

  function StandardAuthorization(spendingCondition) {
    return _Authorization.call(this, AuthType.Standard, spendingCondition) || this;
  }

  return StandardAuthorization;
}(Authorization);
var SponsoredAuthorization = /*#__PURE__*/function (_Authorization2) {
  _inheritsLoose(SponsoredAuthorization, _Authorization2);

  function SponsoredAuthorization(originSpendingCondition, sponsorSpendingCondition) {
    var sponsorSC = sponsorSpendingCondition;

    if (!sponsorSC) {
      sponsorSC = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), new BigNum(0), new BigNum(0));
    }

    return _Authorization2.call(this, AuthType.Sponsored, originSpendingCondition, sponsorSC) || this;
  }

  return SponsoredAuthorization;
}(Authorization);

export { Authorization, SponsoredAuthorization, StandardAuthorization, createMessageSignature, createMultiSigSpendingCondition, createSingleSigSpendingCondition, createTransactionAuthField, deserializeMessageSignature, deserializeMultiSigSpendingCondition, deserializeSingleSigSpendingCondition, deserializeSpendingCondition, deserializeTransactionAuthField, emptyMessageSignature, isSingleSig, makeSigHashPreSign, nextSignature, nextVerification, serializeMessageSignature, serializeMultiSigSpendingCondition, serializeSingleSigSpendingCondition, serializeSpendingCondition, serializeTransactionAuthField };
//# sourceMappingURL=authorization.esm.js.map
