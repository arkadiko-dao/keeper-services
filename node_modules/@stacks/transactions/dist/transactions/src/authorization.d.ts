/// <reference types="node" />
import { AuthType, MultiSigHashMode, PubKeyEncoding, SingleSigHashMode, StacksMessageType } from './constants';
import { StacksPrivateKey, StacksPublicKey } from './keys';
import BigNum from 'bn.js';
import { BufferReader } from './bufferReader';
declare abstract class Deserializable {
    abstract serialize(): Buffer;
    abstract deserialize(bufferReader: BufferReader): void;
    static deserialize<T extends Deserializable>(this: new () => T, bufferReader: BufferReader): T;
}
export interface MessageSignature {
    readonly type: StacksMessageType.MessageSignature;
    data: string;
}
export declare function createMessageSignature(signature: string): MessageSignature;
export declare function emptyMessageSignature(): MessageSignature;
export declare function serializeMessageSignature(messageSignature: MessageSignature): Buffer;
export declare function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature;
export declare type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;
export interface TransactionAuthField {
    type: StacksMessageType.TransactionAuthField;
    pubKeyEncoding: PubKeyEncoding;
    contents: TransactionAuthFieldContents;
}
export declare function createTransactionAuthField(pubKeyEncoding: PubKeyEncoding, contents: TransactionAuthFieldContents): TransactionAuthField;
export declare function serializeTransactionAuthField(field: TransactionAuthField): Buffer;
export declare function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField;
export interface SingleSigSpendingCondition {
    hashMode: SingleSigHashMode;
    signer: string;
    nonce: BigNum;
    fee: BigNum;
    keyEncoding: PubKeyEncoding;
    signature: MessageSignature;
}
export interface MultiSigSpendingCondition {
    hashMode: MultiSigHashMode;
    signer: string;
    nonce: BigNum;
    fee: BigNum;
    fields: TransactionAuthField[];
    signaturesRequired: number;
}
export declare type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;
export declare function createSingleSigSpendingCondition(hashMode: SingleSigHashMode, pubKey: string, nonce: BigNum, fee: BigNum): SingleSigSpendingCondition;
export declare function createMultiSigSpendingCondition(hashMode: MultiSigHashMode, numSigs: number, pubKeys: string[], nonce: BigNum, fee: BigNum): MultiSigSpendingCondition;
export declare function isSingleSig(condition: SpendingCondition): condition is SingleSigSpendingCondition;
export declare function serializeSingleSigSpendingCondition(condition: SingleSigSpendingCondition): Buffer;
export declare function serializeMultiSigSpendingCondition(condition: MultiSigSpendingCondition): Buffer;
export declare function deserializeSingleSigSpendingCondition(hashMode: SingleSigHashMode, bufferReader: BufferReader): SingleSigSpendingCondition;
export declare function deserializeMultiSigSpendingCondition(hashMode: MultiSigHashMode, bufferReader: BufferReader): MultiSigSpendingCondition;
export declare function serializeSpendingCondition(condition: SpendingCondition): Buffer;
export declare function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition;
export declare function makeSigHashPreSign(curSigHash: string, authType: AuthType, fee: BigNum, nonce: BigNum): string;
export declare function nextSignature(curSigHash: string, authType: AuthType, fee: BigNum, nonce: BigNum, privateKey: StacksPrivateKey): {
    nextSig: MessageSignature;
    nextSigHash: string;
};
export declare function nextVerification(initialSigHash: string, authType: AuthType, fee: BigNum, nonce: BigNum, pubKeyEncoding: PubKeyEncoding, signature: MessageSignature): {
    pubKey: StacksPublicKey;
    nextSigHash: string;
};
export declare class Authorization extends Deserializable {
    authType?: AuthType;
    spendingCondition?: SpendingCondition;
    sponsorSpendingCondition?: SpendingCondition;
    constructor(authType?: AuthType, spendingConditions?: SpendingCondition, sponsorSpendingCondition?: SpendingCondition);
    intoInitialSighashAuth(): Authorization;
    setFee(amount: BigNum): void;
    getFee(): BigNum | 0;
    setNonce(nonce: BigNum): void;
    setSponsorNonce(nonce: BigNum): void;
    setSponsor(sponsorSpendingCondition: SpendingCondition): void;
    verifyOrigin(initialSigHash: string): string;
    serialize(): Buffer;
    deserialize(bufferReader: BufferReader): void;
}
export declare class StandardAuthorization extends Authorization {
    constructor(spendingCondition: SpendingCondition);
}
export declare class SponsoredAuthorization extends Authorization {
    constructor(originSpendingCondition: SpendingCondition, sponsorSpendingCondition?: SpendingCondition);
}
export {};
