/// <reference types="node" />
import { sha512 } from 'sha.js';
import { ClarityValue } from './clarity';
import randombytes from 'randombytes';
export { randombytes as randomBytes };
export declare class BufferArray {
    _value: Buffer[];
    get value(): Buffer[];
    appendHexString(hexString: string): void;
    push(buffer: Buffer): number;
    appendByte(octet: number): void;
    concatBuffer(): Buffer;
}
export declare const leftPadHex: (hexString: string) => string;
export declare const leftPadHexToLength: (hexString: string, length: number) => string;
export declare const rightPadHexToLength: (hexString: string, length: number) => string;
export declare const intToHexString: (integer: number, lengthBytes?: number) => string;
export declare const hexStringToInt: (hexString: string) => number;
export declare const exceedsMaxLengthBytes: (string: string, maxLengthBytes: number) => boolean;
export declare function cloneDeep<T>(obj: T): T;
export declare function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K>;
export declare class sha512_256 extends sha512 {
    constructor();
    digest(): Buffer;
    digest(encoding: import('crypto').HexBase64Latin1Encoding): string;
}
export declare const txidFromData: (data: Buffer) => string;
export declare const hash160: (input: Buffer) => Buffer;
export declare const hashP2PKH: (input: Buffer) => string;
export declare const hashP2SH: (numSigs: number, pubKeys: Buffer[]) => string;
export declare function isClarityName(name: string): boolean;
export declare function fetchPrivate(input: RequestInfo, init?: RequestInit): Promise<Response>;
export declare function cvToHex(cv: ClarityValue): string;
export declare function hexToCV(hex: string): ClarityValue;
export interface ReadOnlyFunctionSuccessResponse {
    okay: true;
    result: string;
}
export interface ReadOnlyFunctionErrorResponse {
    okay: false;
    cause: string;
}
export declare type ReadOnlyFunctionResponse = ReadOnlyFunctionSuccessResponse | ReadOnlyFunctionErrorResponse;
export declare const parseReadOnlyResponse: (response: ReadOnlyFunctionResponse) => ClarityValue;
export declare const validateStacksAddress: (stacksAddress: string) => boolean;
