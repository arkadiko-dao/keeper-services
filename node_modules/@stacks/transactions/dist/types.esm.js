import { StacksMessageType, AddressVersion, AddressHashMode, TransactionVersion, PostConditionPrincipalID, MAX_STRING_LENGTH_BYTES, MEMO_MAX_LENGTH_BYTES } from './constants.esm.js';
import { c32address, c32addressDecode } from 'c32check';
import { serializePublicKey, deserializePublicKey, isCompressed } from './keys.esm.js';
import { DeserializationError } from './errors.esm.js';
import { serializePostCondition, deserializePostCondition } from './postcondition.esm.js';
import { serializePayload, deserializePayload } from './payload.esm.js';
import { hashP2SH, hashP2PKH, BufferArray, intToHexString, hexStringToInt, exceedsMaxLengthBytes, rightPadHexToLength } from './utils.esm.js';
import { serializeMessageSignature, serializeTransactionAuthField, deserializeMessageSignature, deserializeTransactionAuthField } from './authorization.esm.js';

function serializeStacksMessage(message) {
  switch (message.type) {
    case StacksMessageType.Address:
      return serializeAddress(message);

    case StacksMessageType.Principal:
      return serializePrincipal(message);

    case StacksMessageType.LengthPrefixedString:
      return serializeLPString(message);

    case StacksMessageType.MemoString:
      return serializeMemoString(message);

    case StacksMessageType.AssetInfo:
      return serializeAssetInfo(message);

    case StacksMessageType.PostCondition:
      return serializePostCondition(message);

    case StacksMessageType.PublicKey:
      return serializePublicKey(message);

    case StacksMessageType.LengthPrefixedList:
      return serializeLPList(message);

    case StacksMessageType.Payload:
      return serializePayload(message);

    case StacksMessageType.TransactionAuthField:
      return serializeTransactionAuthField(message);

    case StacksMessageType.MessageSignature:
      return serializeMessageSignature(message);
  }
}
function deserializeStacksMessage(bufferReader, type, listType) {
  switch (type) {
    case StacksMessageType.Address:
      return deserializeAddress(bufferReader);

    case StacksMessageType.Principal:
      return deserializePrincipal(bufferReader);

    case StacksMessageType.LengthPrefixedString:
      return deserializeLPString(bufferReader);

    case StacksMessageType.MemoString:
      return deserializeMemoString(bufferReader);

    case StacksMessageType.AssetInfo:
      return deserializeAssetInfo(bufferReader);

    case StacksMessageType.PostCondition:
      return deserializePostCondition(bufferReader);

    case StacksMessageType.PublicKey:
      return deserializePublicKey(bufferReader);

    case StacksMessageType.Payload:
      return deserializePayload(bufferReader);

    case StacksMessageType.LengthPrefixedList:
      if (!listType) {
        throw new DeserializationError('No List Type specified');
      }

      return deserializeLPList(bufferReader, listType);

    case StacksMessageType.MessageSignature:
      return deserializeMessageSignature(bufferReader);

    default:
      throw new Error('Could not recognize StacksMessageType');
  }
}
function createAddress(c32AddressString) {
  var addressData = c32addressDecode(c32AddressString);
  return {
    type: StacksMessageType.Address,
    version: addressData[0],
    hash160: addressData[1]
  };
}
function createEmptyAddress() {
  return {
    type: StacksMessageType.Address,
    version: AddressVersion.MainnetSingleSig,
    hash160: '0'.repeat(40)
  };
}
function addressFromVersionHash(version, hash) {
  return {
    type: StacksMessageType.Address,
    version: version,
    hash160: hash
  };
}
function addressHashModeToVersion(hashMode, txVersion) {
  switch (hashMode) {
    case AddressHashMode.SerializeP2PKH:
      switch (txVersion) {
        case TransactionVersion.Mainnet:
          return AddressVersion.MainnetSingleSig;

        case TransactionVersion.Testnet:
          return AddressVersion.TestnetSingleSig;

        default:
          throw new Error("Unexpected txVersion " + JSON.stringify(txVersion) + " for hashMode " + hashMode);
      }

    case AddressHashMode.SerializeP2SH:
    case AddressHashMode.SerializeP2WPKH:
    case AddressHashMode.SerializeP2WSH:
      switch (txVersion) {
        case TransactionVersion.Mainnet:
          return AddressVersion.MainnetMultiSig;

        case TransactionVersion.Testnet:
          return AddressVersion.TestnetMultiSig;

        default:
          throw new Error("Unexpected txVersion " + JSON.stringify(txVersion) + " for hashMode " + hashMode);
      }

    default:
      throw new Error("Unexpected hashMode " + JSON.stringify(hashMode));
  }
}
function addressFromHashMode(hashMode, txVersion, data) {
  var version = addressHashModeToVersion(hashMode, txVersion);
  return addressFromVersionHash(version, data);
}
function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {
  if (publicKeys.length === 0) {
    throw Error('Invalid number of public keys');
  }

  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {
    if (publicKeys.length !== 1 || numSigs !== 1) {
      throw Error('Invalid number of public keys or signatures');
    }
  }

  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {
    for (var i = 0; i < publicKeys.length; i++) {
      if (!isCompressed(publicKeys[i])) {
        throw Error('Public keys must be compressed for segwit');
      }
    }
  }

  switch (hashMode) {
    case AddressHashMode.SerializeP2PKH:
      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));

    case AddressHashMode.SerializeP2SH:
      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));

    default:
      throw Error("Not yet implemented: address construction using public keys for hash mode: " + hashMode);
  }
}
function addressToString(address) {
  return c32address(address.version, address.hash160).toString();
}
function serializeAddress(address) {
  var bufferArray = new BufferArray();
  bufferArray.appendHexString(intToHexString(address.version, 1));
  bufferArray.appendHexString(address.hash160);
  return bufferArray.concatBuffer();
}
function deserializeAddress(bufferReader) {
  var version = hexStringToInt(bufferReader.readBuffer(1).toString('hex'));
  var data = bufferReader.readBuffer(20).toString('hex');
  return {
    type: StacksMessageType.Address,
    version: version,
    hash160: data
  };
}
function parsePrincipalString(principalString) {
  if (principalString.includes('.')) {
    var _principalString$spli = principalString.split('.'),
        address = _principalString$spli[0],
        contractName = _principalString$spli[1];

    return createContractPrincipal(address, contractName);
  } else {
    return createStandardPrincipal(principalString);
  }
}
function createStandardPrincipal(addressString) {
  var addr = createAddress(addressString);
  return {
    type: StacksMessageType.Principal,
    prefix: PostConditionPrincipalID.Standard,
    address: addr
  };
}
function createContractPrincipal(addressString, contractName) {
  var addr = createAddress(addressString);
  var name = createLPString(contractName);
  return {
    type: StacksMessageType.Principal,
    prefix: PostConditionPrincipalID.Contract,
    address: addr,
    contractName: name
  };
}
function serializePrincipal(principal) {
  var bufferArray = new BufferArray();
  bufferArray.push(Buffer.from([principal.prefix]));
  bufferArray.push(serializeAddress(principal.address));

  if (principal.prefix === PostConditionPrincipalID.Contract) {
    bufferArray.push(serializeLPString(principal.contractName));
  }

  return bufferArray.concatBuffer();
}
function deserializePrincipal(bufferReader) {
  var prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, function (_) {
    throw new DeserializationError('Unexpected Principal payload type: ${n}');
  });
  var address = deserializeAddress(bufferReader);

  if (prefix === PostConditionPrincipalID.Standard) {
    return {
      type: StacksMessageType.Principal,
      prefix: prefix,
      address: address
    };
  }

  var contractName = deserializeLPString(bufferReader);
  return {
    type: StacksMessageType.Principal,
    prefix: prefix,
    address: address,
    contractName: contractName
  };
}
function createLPString(content, lengthPrefixBytes, maxLengthBytes) {
  var prefixLength = lengthPrefixBytes || 1;
  var maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;

  if (exceedsMaxLengthBytes(content, maxLength)) {
    throw new Error("String length exceeds maximum bytes " + maxLength.toString());
  }

  return {
    type: StacksMessageType.LengthPrefixedString,
    content: content,
    lengthPrefixBytes: prefixLength,
    maxLengthBytes: maxLength
  };
}
function serializeLPString(lps) {
  var bufferArray = new BufferArray();
  var contentBuffer = Buffer.from(lps.content);
  var length = contentBuffer.byteLength;
  bufferArray.appendHexString(intToHexString(length, lps.lengthPrefixBytes));
  bufferArray.push(contentBuffer);
  return bufferArray.concatBuffer();
}
function deserializeLPString(bufferReader, prefixBytes, maxLength) {
  prefixBytes = prefixBytes ? prefixBytes : 1;
  var length = hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));
  var content = bufferReader.readBuffer(length).toString();
  return createLPString(content, prefixBytes, maxLength != null ? maxLength : 128);
}
function codeBodyString(content) {
  return createLPString(content, 4, 100000);
}
function createMemoString(content) {
  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {
    throw new Error("Memo exceeds maximum length of " + MEMO_MAX_LENGTH_BYTES.toString() + " bytes");
  }

  return {
    type: StacksMessageType.MemoString,
    content: content
  };
}
function serializeMemoString(memoString) {
  var bufferArray = new BufferArray();
  var contentBuffer = Buffer.from(memoString.content);
  var paddedContent = rightPadHexToLength(contentBuffer.toString('hex'), MEMO_MAX_LENGTH_BYTES * 2);
  bufferArray.push(Buffer.from(paddedContent, 'hex'));
  return bufferArray.concatBuffer();
}
function deserializeMemoString(bufferReader) {
  var content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();
  return {
    type: StacksMessageType.MemoString,
    content: content
  };
}
function parseAssetInfoString(id) {
  var _id$split = id.split(/\.|::/),
      assetAddress = _id$split[0],
      assetContractName = _id$split[1],
      assetTokenName = _id$split[2];

  var assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);
  return assetInfo;
}
function createAssetInfo(addressString, contractName, assetName) {
  return {
    type: StacksMessageType.AssetInfo,
    address: createAddress(addressString),
    contractName: createLPString(contractName),
    assetName: createLPString(assetName)
  };
}
function serializeAssetInfo(info) {
  var bufferArray = new BufferArray();
  bufferArray.push(serializeAddress(info.address));
  bufferArray.push(serializeLPString(info.contractName));
  bufferArray.push(serializeLPString(info.assetName));
  return bufferArray.concatBuffer();
}
function deserializeAssetInfo(bufferReader) {
  return {
    type: StacksMessageType.AssetInfo,
    address: deserializeAddress(bufferReader),
    contractName: deserializeLPString(bufferReader),
    assetName: deserializeLPString(bufferReader)
  };
}
function createLPList(values, lengthPrefixBytes) {
  return {
    type: StacksMessageType.LengthPrefixedList,
    lengthPrefixBytes: lengthPrefixBytes || 4,
    values: values
  };
}
function serializeLPList(lpList) {
  var list = lpList.values;
  var bufferArray = new BufferArray();
  bufferArray.appendHexString(intToHexString(list.length, lpList.lengthPrefixBytes));

  for (var index = 0; index < list.length; index++) {
    bufferArray.push(serializeStacksMessage(list[index]));
  }

  return bufferArray.concatBuffer();
}
function deserializeLPList(bufferReader, type, lengthPrefixBytes) {
  var length = hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));
  var l = [];

  for (var index = 0; index < length; index++) {
    switch (type) {
      case StacksMessageType.Address:
        l.push(deserializeAddress(bufferReader));
        break;

      case StacksMessageType.LengthPrefixedString:
        l.push(deserializeLPString(bufferReader));
        break;

      case StacksMessageType.MemoString:
        l.push(deserializeMemoString(bufferReader));
        break;

      case StacksMessageType.AssetInfo:
        l.push(deserializeAssetInfo(bufferReader));
        break;

      case StacksMessageType.PostCondition:
        l.push(deserializePostCondition(bufferReader));
        break;

      case StacksMessageType.PublicKey:
        l.push(deserializePublicKey(bufferReader));
        break;

      case StacksMessageType.TransactionAuthField:
        l.push(deserializeTransactionAuthField(bufferReader));
        break;
    }
  }

  return createLPList(l, lengthPrefixBytes);
}

export { addressFromHashMode, addressFromPublicKeys, addressFromVersionHash, addressHashModeToVersion, addressToString, codeBodyString, createAddress, createAssetInfo, createContractPrincipal, createEmptyAddress, createLPList, createLPString, createMemoString, createStandardPrincipal, deserializeAddress, deserializeAssetInfo, deserializeLPList, deserializeLPString, deserializeMemoString, deserializePrincipal, deserializeStacksMessage, parseAssetInfoString, parsePrincipalString, serializeAddress, serializeAssetInfo, serializeLPList, serializeLPString, serializeMemoString, serializePrincipal, serializeStacksMessage };
//# sourceMappingURL=types.esm.js.map
