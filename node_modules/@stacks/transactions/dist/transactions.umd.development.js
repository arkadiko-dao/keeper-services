(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('sha.js'), require('elliptic'), require('c32check'), require('bn.js'), require('smart-buffer'), require('ripemd160-min'), require('randombytes'), require('cross-fetch'), require('lodash-es/cloneDeep'), require('@stacks/network'), require('@stacks/common')) :
  typeof define === 'function' && define.amd ? define(['exports', 'sha.js', 'elliptic', 'c32check', 'bn.js', 'smart-buffer', 'ripemd160-min', 'randombytes', 'cross-fetch', 'lodash-es/cloneDeep', '@stacks/network', '@stacks/common'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@stacks/transactions'] = {}, global.sha_js, global.elliptic, global.c32check, global.BigNum, global.smartBuffer, global.RIPEMD160, global.randomBytes, global.fetch, global.lodashCloneDeep, global.network, global.common));
}(this, (function (exports, sha_js, elliptic, c32check, BigNum, smartBuffer, RIPEMD160, randomBytes, fetch, lodashCloneDeep, network, common) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var BigNum__default = /*#__PURE__*/_interopDefaultLegacy(BigNum);
  var RIPEMD160__default = /*#__PURE__*/_interopDefaultLegacy(RIPEMD160);
  var randomBytes__default = /*#__PURE__*/_interopDefaultLegacy(randomBytes);
  var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
  var lodashCloneDeep__default = /*#__PURE__*/_interopDefaultLegacy(lodashCloneDeep);

  (function (ChainID) {
    ChainID[ChainID["Testnet"] = 2147483648] = "Testnet";
    ChainID[ChainID["Mainnet"] = 1] = "Mainnet";
  })(exports.ChainID || (exports.ChainID = {}));

  var DEFAULT_CHAIN_ID = exports.ChainID.Mainnet;
  var MAX_STRING_LENGTH_BYTES = 128;
  var CLARITY_INT_SIZE = 128;
  var COINBASE_BUFFER_LENGTH_BYTES = 32;
  var RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;
  var COMPRESSED_PUBKEY_LENGTH_BYTES = 32;
  var UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;
  var MEMO_MAX_LENGTH_BYTES = 34;
  var DEFAULT_CORE_NODE_API_URL = 'https://stacks-node-api.mainnet.stacks.co';


  (function (StacksMessageType) {
    StacksMessageType[StacksMessageType["Address"] = 0] = "Address";
    StacksMessageType[StacksMessageType["Principal"] = 1] = "Principal";
    StacksMessageType[StacksMessageType["LengthPrefixedString"] = 2] = "LengthPrefixedString";
    StacksMessageType[StacksMessageType["MemoString"] = 3] = "MemoString";
    StacksMessageType[StacksMessageType["AssetInfo"] = 4] = "AssetInfo";
    StacksMessageType[StacksMessageType["PostCondition"] = 5] = "PostCondition";
    StacksMessageType[StacksMessageType["PublicKey"] = 6] = "PublicKey";
    StacksMessageType[StacksMessageType["LengthPrefixedList"] = 7] = "LengthPrefixedList";
    StacksMessageType[StacksMessageType["Payload"] = 8] = "Payload";
    StacksMessageType[StacksMessageType["MessageSignature"] = 9] = "MessageSignature";
    StacksMessageType[StacksMessageType["TransactionAuthField"] = 10] = "TransactionAuthField";
  })(exports.StacksMessageType || (exports.StacksMessageType = {}));



  (function (PayloadType) {
    PayloadType[PayloadType["TokenTransfer"] = 0] = "TokenTransfer";
    PayloadType[PayloadType["SmartContract"] = 1] = "SmartContract";
    PayloadType[PayloadType["ContractCall"] = 2] = "ContractCall";
    PayloadType[PayloadType["PoisonMicroblock"] = 3] = "PoisonMicroblock";
    PayloadType[PayloadType["Coinbase"] = 4] = "Coinbase";
  })(exports.PayloadType || (exports.PayloadType = {}));



  (function (AnchorMode) {
    AnchorMode[AnchorMode["OnChainOnly"] = 1] = "OnChainOnly";
    AnchorMode[AnchorMode["OffChainOnly"] = 2] = "OffChainOnly";
    AnchorMode[AnchorMode["Any"] = 3] = "Any";
  })(exports.AnchorMode || (exports.AnchorMode = {}));



  (function (TransactionVersion) {
    TransactionVersion[TransactionVersion["Mainnet"] = 0] = "Mainnet";
    TransactionVersion[TransactionVersion["Testnet"] = 128] = "Testnet";
  })(exports.TransactionVersion || (exports.TransactionVersion = {}));

  var DEFAULT_TRANSACTION_VERSION = exports.TransactionVersion.Mainnet;


  (function (PostConditionMode) {
    PostConditionMode[PostConditionMode["Allow"] = 1] = "Allow";
    PostConditionMode[PostConditionMode["Deny"] = 2] = "Deny";
  })(exports.PostConditionMode || (exports.PostConditionMode = {}));



  (function (PostConditionType) {
    PostConditionType[PostConditionType["STX"] = 0] = "STX";
    PostConditionType[PostConditionType["Fungible"] = 1] = "Fungible";
    PostConditionType[PostConditionType["NonFungible"] = 2] = "NonFungible";
  })(exports.PostConditionType || (exports.PostConditionType = {}));



  (function (AuthType) {
    AuthType[AuthType["Standard"] = 4] = "Standard";
    AuthType[AuthType["Sponsored"] = 5] = "Sponsored";
  })(exports.AuthType || (exports.AuthType = {}));



  (function (AddressHashMode) {
    AddressHashMode[AddressHashMode["SerializeP2PKH"] = 0] = "SerializeP2PKH";
    AddressHashMode[AddressHashMode["SerializeP2SH"] = 1] = "SerializeP2SH";
    AddressHashMode[AddressHashMode["SerializeP2WPKH"] = 2] = "SerializeP2WPKH";
    AddressHashMode[AddressHashMode["SerializeP2WSH"] = 3] = "SerializeP2WSH";
  })(exports.AddressHashMode || (exports.AddressHashMode = {}));



  (function (AddressVersion) {
    AddressVersion[AddressVersion["MainnetSingleSig"] = 22] = "MainnetSingleSig";
    AddressVersion[AddressVersion["MainnetMultiSig"] = 20] = "MainnetMultiSig";
    AddressVersion[AddressVersion["TestnetSingleSig"] = 26] = "TestnetSingleSig";
    AddressVersion[AddressVersion["TestnetMultiSig"] = 21] = "TestnetMultiSig";
  })(exports.AddressVersion || (exports.AddressVersion = {}));



  (function (PubKeyEncoding) {
    PubKeyEncoding[PubKeyEncoding["Compressed"] = 0] = "Compressed";
    PubKeyEncoding[PubKeyEncoding["Uncompressed"] = 1] = "Uncompressed";
  })(exports.PubKeyEncoding || (exports.PubKeyEncoding = {}));



  (function (FungibleConditionCode) {
    FungibleConditionCode[FungibleConditionCode["Equal"] = 1] = "Equal";
    FungibleConditionCode[FungibleConditionCode["Greater"] = 2] = "Greater";
    FungibleConditionCode[FungibleConditionCode["GreaterEqual"] = 3] = "GreaterEqual";
    FungibleConditionCode[FungibleConditionCode["Less"] = 4] = "Less";
    FungibleConditionCode[FungibleConditionCode["LessEqual"] = 5] = "LessEqual";
  })(exports.FungibleConditionCode || (exports.FungibleConditionCode = {}));



  (function (NonFungibleConditionCode) {
    NonFungibleConditionCode[NonFungibleConditionCode["DoesNotOwn"] = 16] = "DoesNotOwn";
    NonFungibleConditionCode[NonFungibleConditionCode["Owns"] = 17] = "Owns";
  })(exports.NonFungibleConditionCode || (exports.NonFungibleConditionCode = {}));



  (function (PostConditionPrincipalID) {
    PostConditionPrincipalID[PostConditionPrincipalID["Origin"] = 1] = "Origin";
    PostConditionPrincipalID[PostConditionPrincipalID["Standard"] = 2] = "Standard";
    PostConditionPrincipalID[PostConditionPrincipalID["Contract"] = 3] = "Contract";
  })(exports.PostConditionPrincipalID || (exports.PostConditionPrincipalID = {}));



  (function (AssetType) {
    AssetType[AssetType["STX"] = 0] = "STX";
    AssetType[AssetType["Fungible"] = 1] = "Fungible";
    AssetType[AssetType["NonFungible"] = 2] = "NonFungible";
  })(exports.AssetType || (exports.AssetType = {}));



  (function (TxRejectedReason) {
    TxRejectedReason["Serialization"] = "Serialization";
    TxRejectedReason["Deserialization"] = "Deserialization";
    TxRejectedReason["SignatureValidation"] = "SignatureValidation";
    TxRejectedReason["FeeTooLow"] = "FeeTooLow";
    TxRejectedReason["BadNonce"] = "BadNonce";
    TxRejectedReason["NotEnoughFunds"] = "NotEnoughFunds";
    TxRejectedReason["NoSuchContract"] = "NoSuchContract";
    TxRejectedReason["NoSuchPublicFunction"] = "NoSuchPublicFunction";
    TxRejectedReason["BadFunctionArgument"] = "BadFunctionArgument";
    TxRejectedReason["ContractAlreadyExists"] = "ContractAlreadyExists";
    TxRejectedReason["PoisonMicroblocksDoNotConflict"] = "PoisonMicroblocksDoNotConflict";
    TxRejectedReason["PoisonMicroblockHasUnknownPubKeyHash"] = "PoisonMicroblockHasUnknownPubKeyHash";
    TxRejectedReason["PoisonMicroblockIsInvalid"] = "PoisonMicroblockIsInvalid";
    TxRejectedReason["BadAddressVersionByte"] = "BadAddressVersionByte";
    TxRejectedReason["NoCoinbaseViaMempool"] = "NoCoinbaseViaMempool";
    TxRejectedReason["ServerFailureNoSuchChainTip"] = "ServerFailureNoSuchChainTip";
    TxRejectedReason["ServerFailureDatabase"] = "ServerFailureDatabase";
    TxRejectedReason["ServerFailureOther"] = "ServerFailureOther";
  })(exports.TxRejectedReason || (exports.TxRejectedReason = {}));

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var runtime_1 = /*#__PURE__*/createCommonjsModule(function (module) {
    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1; // More compressible than void 0.

      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }

      try {
        // IE 8 has a broken Object.defineProperty that only works on DOM objects.
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.

        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.

      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.


      var IteratorPrototype = {};

      IteratorPrototype[iteratorSymbol] = function () {
        return this;
      };

      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      }; // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.


      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return PromiseImpl.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              // If a rejected Promise was yielded, throw the rejection back
              // into the async generator function so it can be handled there.
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).


        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);

      AsyncIterator.prototype[asyncIteratorSymbol] = function () {
        return this;
      };

      exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.

      exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            } // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted; // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.

              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      } // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.


      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === "throw") {
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (delegate.iterator["return"]) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

          context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        } // The delegate iterator is finished, so forget it and continue with
        // the outer generator.


        context.delegate = null;
        return ContinueSentinel;
      } // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.


      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.

      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp.toString = function () {
        return "[object Generator]";
      };

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse(); // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.

        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          } // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.


          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        } // Return an iterator with no values.


        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0; // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.

          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          } // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.


          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      }; // Regardless of whether this script is executing as a CommonJS module
      // or not, return the runtime object so that we can declare the variable
      // regeneratorRuntime in the outer scope, which allows this module to be
      // injected easily by `bin/regenerator --include-runtime script.js`.

      return exports;
    }( // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
     module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      // This module should not be running in strict mode, so the above
      // assignment should always work unless something is misconfigured. Just
      // in case runtime.js accidentally runs in strict mode, we can escape
      // strict mode using a global Function call. This could conceivably fail
      // if a Content Security Policy forbids using Function, but in that case
      // the proper solution is to fix the accidental strict mode problem. If
      // you've misconfigured your bundler to force strict mode and applied a
      // CSP to forbid Function, and you're not willing to fix either of those
      // problems, please detail your unique predicament in a GitHub issue.
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  });

  function getAddressFromPrivateKey(privateKey, transactionVersion) {
    if (transactionVersion === void 0) {
      transactionVersion = exports.TransactionVersion.Mainnet;
    }

    var pubKey = pubKeyfromPrivKey(privateKey);
    return getAddressFromPublicKey(pubKey.data, transactionVersion);
  }
  function getAddressFromPublicKey(publicKey, transactionVersion) {
    if (transactionVersion === void 0) {
      transactionVersion = exports.TransactionVersion.Mainnet;
    }

    publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');
    var addrVer = addressHashModeToVersion(exports.AddressHashMode.SerializeP2PKH, transactionVersion);
    var addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));
    var addrString = addressToString(addr);
    return addrString;
  }
  function createStacksPublicKey(key) {
    return {
      type: exports.StacksMessageType.PublicKey,
      data: Buffer.from(key, 'hex')
    };
  }
  function publicKeyFromSignature(message, messageSignature, pubKeyEncoding) {
    if (pubKeyEncoding === void 0) {
      pubKeyEncoding = exports.PubKeyEncoding.Compressed;
    }

    var ec = new elliptic.ec('secp256k1');
    var messageBN = ec.keyFromPrivate(message, 'hex').getPrivate().toString(10);
    var parsedSignature = parseRecoverableSignature(messageSignature.data);
    var publicKey = ec.recoverPubKey(messageBN, parsedSignature, parsedSignature.recoveryParam, 'hex');

    if (pubKeyEncoding == exports.PubKeyEncoding.Uncompressed) {
      return publicKey.encode('hex');
    }

    return publicKey.encodeCompressed('hex');
  }
  function publicKeyFromBuffer(data) {
    return {
      type: exports.StacksMessageType.PublicKey,
      data: data
    };
  }
  function isCompressed(key) {
    return !key.data.toString('hex').startsWith('04');
  }
  function publicKeyToString(key) {
    return key.data.toString('hex');
  }
  function serializePublicKey(key) {
    var bufferArray = new BufferArray();
    bufferArray.push(key.data);
    return bufferArray.concatBuffer();
  }
  function pubKeyfromPrivKey(privateKey) {
    var privKey = createStacksPrivateKey(privateKey);
    var ec = new elliptic.ec('secp256k1');
    var keyPair = ec.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');
    var pubKey = keyPair.getPublic(privKey.compressed, 'hex');
    return createStacksPublicKey(pubKey);
  }
  function compressPublicKey(publicKey) {
    var ec = new elliptic.ec('secp256k1');
    var key = ec.keyFromPublic(publicKey);
    var pubKey = key.getPublic(true, 'hex');
    return createStacksPublicKey(pubKey);
  }
  function deserializePublicKey(bufferReader) {
    var fieldId = bufferReader.readUInt8();
    var keyLength = fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
    return publicKeyFromBuffer(Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)]));
  }
  function createStacksPrivateKey(key) {
    var data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;
    var compressed;

    if (data.length === 33) {
      if (data[data.length - 1] !== 1) {
        throw new Error('Improperly formatted private-key. 33 byte length usually ' + 'indicates compressed key, but last byte must be == 0x01');
      }

      compressed = true;
    } else if (data.length === 32) {
      compressed = false;
    } else {
      throw new Error("Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length " + data.length);
    }

    return {
      data: data,
      compressed: compressed
    };
  }
  function makeRandomPrivKey(entropy) {
    var ec = new elliptic.ec('secp256k1');
    var options = {
      entropy: entropy || randomBytes__default['default'](32)
    };
    var keyPair = ec.genKeyPair(options);
    var privateKey = keyPair.getPrivate().toString('hex', 32);
    return createStacksPrivateKey(privateKey);
  }
  function signWithKey(privateKey, input) {
    var ec = new elliptic.ec('secp256k1');
    var key = ec.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');
    var signature = key.sign(input, 'hex', {
      canonical: true
    });
    var coordinateValueBytes = 32;
    var r = leftPadHexToLength(signature.r.toString('hex'), coordinateValueBytes * 2);
    var s = leftPadHexToLength(signature.s.toString('hex'), coordinateValueBytes * 2);

    if (signature.recoveryParam === undefined || signature.recoveryParam === null) {
      throw new Error('"signature.recoveryParam" is not set');
    }

    var recoveryParam = intToHexString(signature.recoveryParam, 1);
    var recoverableSignatureString = recoveryParam + r + s;
    return createMessageSignature(recoverableSignatureString);
  }
  function getSignatureRecoveryParam(signature) {
    var coordinateValueBytes = 32;

    if (signature.length < coordinateValueBytes * 2 * 2 + 1) {
      throw new Error('Invalid signature');
    }

    var recoveryParamHex = signature.substr(0, 2);
    return hexStringToInt(recoveryParamHex);
  }
  function parseRecoverableSignature(signature) {
    var coordinateValueBytes = 32;

    if (signature.length < coordinateValueBytes * 2 * 2 + 1) {
      throw new Error('Invalid signature');
    }

    var recoveryParamHex = signature.substr(0, 2);
    var r = signature.substr(2, coordinateValueBytes * 2);
    var s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);
    return {
      recoveryParam: hexStringToInt(recoveryParamHex),
      r: r,
      s: s
    };
  }
  function getPublicKey(privateKey) {
    return pubKeyfromPrivKey(privateKey.data);
  }
  function privateKeyToString(privateKey) {
    return privateKey.data.toString('hex');
  }
  function publicKeyToAddress(version, publicKey) {
    return c32check.c32address(version, hash160(publicKey.data).toString('hex'));
  }

  var SerializationError = /*#__PURE__*/function (_Error2) {
    _inheritsLoose(SerializationError, _Error2);

    function SerializationError(message) {
      var _this2;

      _this2 = _Error2.call(this, message) || this;
      _this2.message = message;
      _this2.name = _this2.constructor.name;

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this2), _this2.constructor);
      }

      return _this2;
    }

    return SerializationError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var DeserializationError = /*#__PURE__*/function (_Error3) {
    _inheritsLoose(DeserializationError, _Error3);

    function DeserializationError(message) {
      var _this3;

      _this3 = _Error3.call(this, message) || this;
      _this3.message = message;
      _this3.name = _this3.constructor.name;

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this3), _this3.constructor);
      }

      return _this3;
    }

    return DeserializationError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var NotImplementedError = /*#__PURE__*/function (_Error4) {
    _inheritsLoose(NotImplementedError, _Error4);

    function NotImplementedError(message) {
      var _this4;

      _this4 = _Error4.call(this, message) || this;
      _this4.message = message;
      _this4.name = _this4.constructor.name;

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this4), _this4.constructor);
      }

      return _this4;
    }

    return NotImplementedError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var SigningError = /*#__PURE__*/function (_Error5) {
    _inheritsLoose(SigningError, _Error5);

    function SigningError(message) {
      var _this5;

      _this5 = _Error5.call(this, message) || this;
      _this5.message = message;
      _this5.name = _this5.constructor.name;

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this5), _this5.constructor);
      }

      return _this5;
    }

    return SigningError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function createSTXPostCondition(principal, conditionCode, amount) {
    if (typeof principal === 'string') {
      principal = parsePrincipalString(principal);
    }

    return {
      type: exports.StacksMessageType.PostCondition,
      conditionType: exports.PostConditionType.STX,
      principal: principal,
      conditionCode: conditionCode,
      amount: amount
    };
  }
  function createFungiblePostCondition(principal, conditionCode, amount, assetInfo) {
    if (typeof principal === 'string') {
      principal = parsePrincipalString(principal);
    }

    if (typeof assetInfo === 'string') {
      assetInfo = parseAssetInfoString(assetInfo);
    }

    return {
      type: exports.StacksMessageType.PostCondition,
      conditionType: exports.PostConditionType.Fungible,
      principal: principal,
      conditionCode: conditionCode,
      amount: amount,
      assetInfo: assetInfo
    };
  }
  function createNonFungiblePostCondition(principal, conditionCode, assetInfo, assetName) {
    if (typeof principal === 'string') {
      principal = parsePrincipalString(principal);
    }

    if (typeof assetInfo === 'string') {
      assetInfo = parseAssetInfoString(assetInfo);
    }

    return {
      type: exports.StacksMessageType.PostCondition,
      conditionType: exports.PostConditionType.NonFungible,
      principal: principal,
      conditionCode: conditionCode,
      assetInfo: assetInfo,
      assetName: assetName
    };
  }
  function serializePostCondition(postCondition) {
    var bufferArray = new BufferArray();
    bufferArray.appendByte(postCondition.conditionType);
    bufferArray.push(serializePrincipal(postCondition.principal));

    if (postCondition.conditionType === exports.PostConditionType.Fungible || postCondition.conditionType === exports.PostConditionType.NonFungible) {
      bufferArray.push(serializeAssetInfo(postCondition.assetInfo));
    }

    if (postCondition.conditionType === exports.PostConditionType.NonFungible) {
      bufferArray.push(serializeCV(postCondition.assetName));
    }

    bufferArray.appendByte(postCondition.conditionCode);

    if (postCondition.conditionType === exports.PostConditionType.STX || postCondition.conditionType === exports.PostConditionType.Fungible) {
      bufferArray.push(postCondition.amount.toArrayLike(Buffer, 'be', 8));
    }

    return bufferArray.concatBuffer();
  }
  function deserializePostCondition(bufferReader) {
    var postConditionType = bufferReader.readUInt8Enum(exports.PostConditionType, function (n) {
      throw new DeserializationError("Could not read " + n + " as PostConditionType");
    });
    var principal = deserializePrincipal(bufferReader);
    var conditionCode;
    var assetInfo;
    var amount;

    switch (postConditionType) {
      case exports.PostConditionType.STX:
        conditionCode = bufferReader.readUInt8Enum(exports.FungibleConditionCode, function (n) {
          throw new DeserializationError("Could not read " + n + " as FungibleConditionCode");
        });
        amount = new BigNum__default['default'](bufferReader.readBuffer(8).toString('hex'), 16);
        return {
          type: exports.StacksMessageType.PostCondition,
          conditionType: exports.PostConditionType.STX,
          principal: principal,
          conditionCode: conditionCode,
          amount: amount
        };

      case exports.PostConditionType.Fungible:
        assetInfo = deserializeAssetInfo(bufferReader);
        conditionCode = bufferReader.readUInt8Enum(exports.FungibleConditionCode, function (n) {
          throw new DeserializationError("Could not read " + n + " as FungibleConditionCode");
        });
        amount = new BigNum__default['default'](bufferReader.readBuffer(8).toString('hex'), 16);
        return {
          type: exports.StacksMessageType.PostCondition,
          conditionType: exports.PostConditionType.Fungible,
          principal: principal,
          conditionCode: conditionCode,
          amount: amount,
          assetInfo: assetInfo
        };

      case exports.PostConditionType.NonFungible:
        assetInfo = deserializeAssetInfo(bufferReader);
        var assetName = deserializeCV(bufferReader);
        conditionCode = bufferReader.readUInt8Enum(exports.NonFungibleConditionCode, function (n) {
          throw new DeserializationError("Could not read " + n + " as FungibleConditionCode");
        });
        return {
          type: exports.StacksMessageType.PostCondition,
          conditionType: exports.PostConditionType.NonFungible,
          principal: principal,
          conditionCode: conditionCode,
          assetInfo: assetInfo,
          assetName: assetName
        };
    }
  }

  function createTokenTransferPayload(recipient, amount, memo) {
    var _memo;

    if (typeof recipient === 'string') {
      recipient = principalCV(recipient);
    }

    if (typeof memo === 'string') {
      memo = createMemoString(memo);
    }

    return {
      type: exports.StacksMessageType.Payload,
      payloadType: exports.PayloadType.TokenTransfer,
      recipient: recipient,
      amount: amount,
      memo: (_memo = memo) != null ? _memo : createMemoString('')
    };
  }
  function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {
    if (typeof contractAddress === 'string') {
      contractAddress = createAddress(contractAddress);
    }

    if (typeof contractName === 'string') {
      contractName = createLPString(contractName);
    }

    if (typeof functionName === 'string') {
      functionName = createLPString(functionName);
    }

    return {
      type: exports.StacksMessageType.Payload,
      payloadType: exports.PayloadType.ContractCall,
      contractAddress: contractAddress,
      contractName: contractName,
      functionName: functionName,
      functionArgs: functionArgs
    };
  }
  function createSmartContractPayload(contractName, codeBody) {
    if (typeof contractName === 'string') {
      contractName = createLPString(contractName);
    }

    if (typeof codeBody === 'string') {
      codeBody = codeBodyString(codeBody);
    }

    return {
      type: exports.StacksMessageType.Payload,
      payloadType: exports.PayloadType.SmartContract,
      contractName: contractName,
      codeBody: codeBody
    };
  }
  function createPoisonPayload() {
    return {
      type: exports.StacksMessageType.Payload,
      payloadType: exports.PayloadType.PoisonMicroblock
    };
  }
  function createCoinbasePayload(coinbaseBuffer) {
    if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {
      throw Error("Coinbase buffer size must be " + COINBASE_BUFFER_LENGTH_BYTES + " bytes");
    }

    return {
      type: exports.StacksMessageType.Payload,
      payloadType: exports.PayloadType.Coinbase,
      coinbaseBuffer: coinbaseBuffer
    };
  }
  function serializePayload(payload) {
    var bufferArray = new BufferArray();
    bufferArray.appendByte(payload.payloadType);

    switch (payload.payloadType) {
      case exports.PayloadType.TokenTransfer:
        bufferArray.push(serializeCV(payload.recipient));
        bufferArray.push(payload.amount.toArrayLike(Buffer, 'be', 8));
        bufferArray.push(serializeStacksMessage(payload.memo));
        break;

      case exports.PayloadType.ContractCall:
        bufferArray.push(serializeStacksMessage(payload.contractAddress));
        bufferArray.push(serializeStacksMessage(payload.contractName));
        bufferArray.push(serializeStacksMessage(payload.functionName));
        var numArgs = Buffer.alloc(4);
        numArgs.writeUInt32BE(payload.functionArgs.length, 0);
        bufferArray.push(numArgs);
        payload.functionArgs.forEach(function (arg) {
          bufferArray.push(serializeCV(arg));
        });
        break;

      case exports.PayloadType.SmartContract:
        bufferArray.push(serializeStacksMessage(payload.contractName));
        bufferArray.push(serializeStacksMessage(payload.codeBody));
        break;

      case exports.PayloadType.PoisonMicroblock:
        break;

      case exports.PayloadType.Coinbase:
        bufferArray.push(payload.coinbaseBuffer);
        break;
    }

    return bufferArray.concatBuffer();
  }
  function deserializePayload(bufferReader) {
    var payloadType = bufferReader.readUInt8Enum(exports.PayloadType, function (n) {
      throw new Error("Cannot recognize PayloadType: " + n);
    });

    switch (payloadType) {
      case exports.PayloadType.TokenTransfer:
        var recipient = deserializeCV(bufferReader);
        var amount = new BigNum__default['default'](bufferReader.readBuffer(8));
        var memo = deserializeMemoString(bufferReader);
        return createTokenTransferPayload(recipient, amount, memo);

      case exports.PayloadType.ContractCall:
        var contractAddress = deserializeAddress(bufferReader);
        var contractCallName = deserializeLPString(bufferReader);
        var functionName = deserializeLPString(bufferReader);
        var functionArgs = [];
        var numberOfArgs = bufferReader.readUInt32BE();

        for (var i = 0; i < numberOfArgs; i++) {
          var clarityValue = deserializeCV(bufferReader);
          functionArgs.push(clarityValue);
        }

        return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);

      case exports.PayloadType.SmartContract:
        var smartContractName = deserializeLPString(bufferReader);
        var codeBody = deserializeLPString(bufferReader, 4, 100000);
        return createSmartContractPayload(smartContractName, codeBody);

      case exports.PayloadType.PoisonMicroblock:
        return createPoisonPayload();

      case exports.PayloadType.Coinbase:
        var coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);
        return createCoinbasePayload(coinbaseBuffer);
    }
  }

  function serializeStacksMessage(message) {
    switch (message.type) {
      case exports.StacksMessageType.Address:
        return serializeAddress(message);

      case exports.StacksMessageType.Principal:
        return serializePrincipal(message);

      case exports.StacksMessageType.LengthPrefixedString:
        return serializeLPString(message);

      case exports.StacksMessageType.MemoString:
        return serializeMemoString(message);

      case exports.StacksMessageType.AssetInfo:
        return serializeAssetInfo(message);

      case exports.StacksMessageType.PostCondition:
        return serializePostCondition(message);

      case exports.StacksMessageType.PublicKey:
        return serializePublicKey(message);

      case exports.StacksMessageType.LengthPrefixedList:
        return serializeLPList(message);

      case exports.StacksMessageType.Payload:
        return serializePayload(message);

      case exports.StacksMessageType.TransactionAuthField:
        return serializeTransactionAuthField(message);

      case exports.StacksMessageType.MessageSignature:
        return serializeMessageSignature(message);
    }
  }
  function deserializeStacksMessage(bufferReader, type, listType) {
    switch (type) {
      case exports.StacksMessageType.Address:
        return deserializeAddress(bufferReader);

      case exports.StacksMessageType.Principal:
        return deserializePrincipal(bufferReader);

      case exports.StacksMessageType.LengthPrefixedString:
        return deserializeLPString(bufferReader);

      case exports.StacksMessageType.MemoString:
        return deserializeMemoString(bufferReader);

      case exports.StacksMessageType.AssetInfo:
        return deserializeAssetInfo(bufferReader);

      case exports.StacksMessageType.PostCondition:
        return deserializePostCondition(bufferReader);

      case exports.StacksMessageType.PublicKey:
        return deserializePublicKey(bufferReader);

      case exports.StacksMessageType.Payload:
        return deserializePayload(bufferReader);

      case exports.StacksMessageType.LengthPrefixedList:
        if (!listType) {
          throw new DeserializationError('No List Type specified');
        }

        return deserializeLPList(bufferReader, listType);

      case exports.StacksMessageType.MessageSignature:
        return deserializeMessageSignature(bufferReader);

      default:
        throw new Error('Could not recognize StacksMessageType');
    }
  }
  function createAddress(c32AddressString) {
    var addressData = c32check.c32addressDecode(c32AddressString);
    return {
      type: exports.StacksMessageType.Address,
      version: addressData[0],
      hash160: addressData[1]
    };
  }
  function createEmptyAddress() {
    return {
      type: exports.StacksMessageType.Address,
      version: exports.AddressVersion.MainnetSingleSig,
      hash160: '0'.repeat(40)
    };
  }
  function addressFromVersionHash(version, hash) {
    return {
      type: exports.StacksMessageType.Address,
      version: version,
      hash160: hash
    };
  }
  function addressHashModeToVersion(hashMode, txVersion) {
    switch (hashMode) {
      case exports.AddressHashMode.SerializeP2PKH:
        switch (txVersion) {
          case exports.TransactionVersion.Mainnet:
            return exports.AddressVersion.MainnetSingleSig;

          case exports.TransactionVersion.Testnet:
            return exports.AddressVersion.TestnetSingleSig;

          default:
            throw new Error("Unexpected txVersion " + JSON.stringify(txVersion) + " for hashMode " + hashMode);
        }

      case exports.AddressHashMode.SerializeP2SH:
      case exports.AddressHashMode.SerializeP2WPKH:
      case exports.AddressHashMode.SerializeP2WSH:
        switch (txVersion) {
          case exports.TransactionVersion.Mainnet:
            return exports.AddressVersion.MainnetMultiSig;

          case exports.TransactionVersion.Testnet:
            return exports.AddressVersion.TestnetMultiSig;

          default:
            throw new Error("Unexpected txVersion " + JSON.stringify(txVersion) + " for hashMode " + hashMode);
        }

      default:
        throw new Error("Unexpected hashMode " + JSON.stringify(hashMode));
    }
  }
  function addressFromHashMode(hashMode, txVersion, data) {
    var version = addressHashModeToVersion(hashMode, txVersion);
    return addressFromVersionHash(version, data);
  }
  function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {
    if (publicKeys.length === 0) {
      throw Error('Invalid number of public keys');
    }

    if (hashMode === exports.AddressHashMode.SerializeP2PKH || hashMode === exports.AddressHashMode.SerializeP2WPKH) {
      if (publicKeys.length !== 1 || numSigs !== 1) {
        throw Error('Invalid number of public keys or signatures');
      }
    }

    if (hashMode === exports.AddressHashMode.SerializeP2WPKH || hashMode === exports.AddressHashMode.SerializeP2WSH) {
      for (var i = 0; i < publicKeys.length; i++) {
        if (!isCompressed(publicKeys[i])) {
          throw Error('Public keys must be compressed for segwit');
        }
      }
    }

    switch (hashMode) {
      case exports.AddressHashMode.SerializeP2PKH:
        return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));

      case exports.AddressHashMode.SerializeP2SH:
        return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));

      default:
        throw Error("Not yet implemented: address construction using public keys for hash mode: " + hashMode);
    }
  }
  function addressToString(address) {
    return c32check.c32address(address.version, address.hash160).toString();
  }
  function serializeAddress(address) {
    var bufferArray = new BufferArray();
    bufferArray.appendHexString(intToHexString(address.version, 1));
    bufferArray.appendHexString(address.hash160);
    return bufferArray.concatBuffer();
  }
  function deserializeAddress(bufferReader) {
    var version = hexStringToInt(bufferReader.readBuffer(1).toString('hex'));
    var data = bufferReader.readBuffer(20).toString('hex');
    return {
      type: exports.StacksMessageType.Address,
      version: version,
      hash160: data
    };
  }
  function parsePrincipalString(principalString) {
    if (principalString.includes('.')) {
      var _principalString$spli = principalString.split('.'),
          address = _principalString$spli[0],
          contractName = _principalString$spli[1];

      return createContractPrincipal(address, contractName);
    } else {
      return createStandardPrincipal(principalString);
    }
  }
  function createStandardPrincipal(addressString) {
    var addr = createAddress(addressString);
    return {
      type: exports.StacksMessageType.Principal,
      prefix: exports.PostConditionPrincipalID.Standard,
      address: addr
    };
  }
  function createContractPrincipal(addressString, contractName) {
    var addr = createAddress(addressString);
    var name = createLPString(contractName);
    return {
      type: exports.StacksMessageType.Principal,
      prefix: exports.PostConditionPrincipalID.Contract,
      address: addr,
      contractName: name
    };
  }
  function serializePrincipal(principal) {
    var bufferArray = new BufferArray();
    bufferArray.push(Buffer.from([principal.prefix]));
    bufferArray.push(serializeAddress(principal.address));

    if (principal.prefix === exports.PostConditionPrincipalID.Contract) {
      bufferArray.push(serializeLPString(principal.contractName));
    }

    return bufferArray.concatBuffer();
  }
  function deserializePrincipal(bufferReader) {
    var prefix = bufferReader.readUInt8Enum(exports.PostConditionPrincipalID, function (_) {
      throw new DeserializationError('Unexpected Principal payload type: ${n}');
    });
    var address = deserializeAddress(bufferReader);

    if (prefix === exports.PostConditionPrincipalID.Standard) {
      return {
        type: exports.StacksMessageType.Principal,
        prefix: prefix,
        address: address
      };
    }

    var contractName = deserializeLPString(bufferReader);
    return {
      type: exports.StacksMessageType.Principal,
      prefix: prefix,
      address: address,
      contractName: contractName
    };
  }
  function createLPString(content, lengthPrefixBytes, maxLengthBytes) {
    var prefixLength = lengthPrefixBytes || 1;
    var maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;

    if (exceedsMaxLengthBytes(content, maxLength)) {
      throw new Error("String length exceeds maximum bytes " + maxLength.toString());
    }

    return {
      type: exports.StacksMessageType.LengthPrefixedString,
      content: content,
      lengthPrefixBytes: prefixLength,
      maxLengthBytes: maxLength
    };
  }
  function serializeLPString(lps) {
    var bufferArray = new BufferArray();
    var contentBuffer = Buffer.from(lps.content);
    var length = contentBuffer.byteLength;
    bufferArray.appendHexString(intToHexString(length, lps.lengthPrefixBytes));
    bufferArray.push(contentBuffer);
    return bufferArray.concatBuffer();
  }
  function deserializeLPString(bufferReader, prefixBytes, maxLength) {
    prefixBytes = prefixBytes ? prefixBytes : 1;
    var length = hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));
    var content = bufferReader.readBuffer(length).toString();
    return createLPString(content, prefixBytes, maxLength != null ? maxLength : 128);
  }
  function codeBodyString(content) {
    return createLPString(content, 4, 100000);
  }
  function createMemoString(content) {
    if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {
      throw new Error("Memo exceeds maximum length of " + MEMO_MAX_LENGTH_BYTES.toString() + " bytes");
    }

    return {
      type: exports.StacksMessageType.MemoString,
      content: content
    };
  }
  function serializeMemoString(memoString) {
    var bufferArray = new BufferArray();
    var contentBuffer = Buffer.from(memoString.content);
    var paddedContent = rightPadHexToLength(contentBuffer.toString('hex'), MEMO_MAX_LENGTH_BYTES * 2);
    bufferArray.push(Buffer.from(paddedContent, 'hex'));
    return bufferArray.concatBuffer();
  }
  function deserializeMemoString(bufferReader) {
    var content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();
    return {
      type: exports.StacksMessageType.MemoString,
      content: content
    };
  }
  function parseAssetInfoString(id) {
    var _id$split = id.split(/\.|::/),
        assetAddress = _id$split[0],
        assetContractName = _id$split[1],
        assetTokenName = _id$split[2];

    var assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);
    return assetInfo;
  }
  function createAssetInfo(addressString, contractName, assetName) {
    return {
      type: exports.StacksMessageType.AssetInfo,
      address: createAddress(addressString),
      contractName: createLPString(contractName),
      assetName: createLPString(assetName)
    };
  }
  function serializeAssetInfo(info) {
    var bufferArray = new BufferArray();
    bufferArray.push(serializeAddress(info.address));
    bufferArray.push(serializeLPString(info.contractName));
    bufferArray.push(serializeLPString(info.assetName));
    return bufferArray.concatBuffer();
  }
  function deserializeAssetInfo(bufferReader) {
    return {
      type: exports.StacksMessageType.AssetInfo,
      address: deserializeAddress(bufferReader),
      contractName: deserializeLPString(bufferReader),
      assetName: deserializeLPString(bufferReader)
    };
  }
  function createLPList(values, lengthPrefixBytes) {
    return {
      type: exports.StacksMessageType.LengthPrefixedList,
      lengthPrefixBytes: lengthPrefixBytes || 4,
      values: values
    };
  }
  function serializeLPList(lpList) {
    var list = lpList.values;
    var bufferArray = new BufferArray();
    bufferArray.appendHexString(intToHexString(list.length, lpList.lengthPrefixBytes));

    for (var index = 0; index < list.length; index++) {
      bufferArray.push(serializeStacksMessage(list[index]));
    }

    return bufferArray.concatBuffer();
  }
  function deserializeLPList(bufferReader, type, lengthPrefixBytes) {
    var length = hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));
    var l = [];

    for (var index = 0; index < length; index++) {
      switch (type) {
        case exports.StacksMessageType.Address:
          l.push(deserializeAddress(bufferReader));
          break;

        case exports.StacksMessageType.LengthPrefixedString:
          l.push(deserializeLPString(bufferReader));
          break;

        case exports.StacksMessageType.MemoString:
          l.push(deserializeMemoString(bufferReader));
          break;

        case exports.StacksMessageType.AssetInfo:
          l.push(deserializeAssetInfo(bufferReader));
          break;

        case exports.StacksMessageType.PostCondition:
          l.push(deserializePostCondition(bufferReader));
          break;

        case exports.StacksMessageType.PublicKey:
          l.push(deserializePublicKey(bufferReader));
          break;

        case exports.StacksMessageType.TransactionAuthField:
          l.push(deserializeTransactionAuthField(bufferReader));
          break;
      }
    }

    return createLPList(l, lengthPrefixBytes);
  }

  function principalToString(principal) {
    if (principal.type === exports.ClarityType.PrincipalStandard) {
      return addressToString(principal.address);
    } else if (principal.type === exports.ClarityType.PrincipalContract) {
      var address = addressToString(principal.address);
      return address + "." + principal.contractName.content;
    } else {
      throw new Error("Unexpected principal data: " + JSON.stringify(principal));
    }
  }

  function principalCV(principal) {
    if (principal.includes('.')) {
      var _principal$split = principal.split('.'),
          address = _principal$split[0],
          contractName = _principal$split[1];

      return contractPrincipalCV(address, contractName);
    } else {
      return standardPrincipalCV(principal);
    }
  }

  function standardPrincipalCV(addressString) {
    var addr = createAddress(addressString);
    return {
      type: exports.ClarityType.PrincipalStandard,
      address: addr
    };
  }

  function standardPrincipalCVFromAddress(address) {
    return {
      type: exports.ClarityType.PrincipalStandard,
      address: address
    };
  }

  function contractPrincipalCV(addressString, contractName) {
    var addr = createAddress(addressString);
    var lengthPrefixedContractName = createLPString(contractName);
    return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);
  }

  function contractPrincipalCVFromAddress(address, contractName) {
    if (Buffer.byteLength(contractName.content) >= 128) {
      throw new Error('Contract name must be less than 128 bytes');
    }

    return {
      type: exports.ClarityType.PrincipalContract,
      address: address,
      contractName: contractName
    };
  }

  function contractPrincipalCVFromStandard(sp, contractName) {
    var lengthPrefixedContractName = createLPString(contractName);
    return {
      type: exports.ClarityType.PrincipalContract,
      address: sp.address,
      contractName: lengthPrefixedContractName
    };
  }

  (function (ClarityType) {
    ClarityType[ClarityType["Int"] = 0] = "Int";
    ClarityType[ClarityType["UInt"] = 1] = "UInt";
    ClarityType[ClarityType["Buffer"] = 2] = "Buffer";
    ClarityType[ClarityType["BoolTrue"] = 3] = "BoolTrue";
    ClarityType[ClarityType["BoolFalse"] = 4] = "BoolFalse";
    ClarityType[ClarityType["PrincipalStandard"] = 5] = "PrincipalStandard";
    ClarityType[ClarityType["PrincipalContract"] = 6] = "PrincipalContract";
    ClarityType[ClarityType["ResponseOk"] = 7] = "ResponseOk";
    ClarityType[ClarityType["ResponseErr"] = 8] = "ResponseErr";
    ClarityType[ClarityType["OptionalNone"] = 9] = "OptionalNone";
    ClarityType[ClarityType["OptionalSome"] = 10] = "OptionalSome";
    ClarityType[ClarityType["List"] = 11] = "List";
    ClarityType[ClarityType["Tuple"] = 12] = "Tuple";
    ClarityType[ClarityType["StringASCII"] = 13] = "StringASCII";
    ClarityType[ClarityType["StringUTF8"] = 14] = "StringUTF8";
  })(exports.ClarityType || (exports.ClarityType = {}));

  function cvToString(val, encoding) {
    if (encoding === void 0) {
      encoding = 'hex';
    }

    switch (val.type) {
      case exports.ClarityType.BoolTrue:
        return 'true';

      case exports.ClarityType.BoolFalse:
        return 'false';

      case exports.ClarityType.Int:
        return val.value.fromTwos(CLARITY_INT_SIZE).toString();

      case exports.ClarityType.UInt:
        return "u" + val.value.toString();

      case exports.ClarityType.Buffer:
        if (encoding === 'tryAscii') {
          var str = val.buffer.toString('ascii');

          if (/[ -~]/.test(str)) {
            return JSON.stringify(str);
          }
        }

        return "0x" + val.buffer.toString('hex');

      case exports.ClarityType.OptionalNone:
        return 'none';

      case exports.ClarityType.OptionalSome:
        return "(some " + cvToString(val.value, encoding) + ")";

      case exports.ClarityType.ResponseErr:
        return "(err " + cvToString(val.value, encoding) + ")";

      case exports.ClarityType.ResponseOk:
        return "(ok " + cvToString(val.value, encoding) + ")";

      case exports.ClarityType.PrincipalStandard:
      case exports.ClarityType.PrincipalContract:
        return principalToString(val);

      case exports.ClarityType.List:
        return "(list " + val.list.map(function (v) {
          return cvToString(v, encoding);
        }).join(' ') + ")";

      case exports.ClarityType.Tuple:
        return "(tuple " + Object.keys(val.data).map(function (key) {
          return "(" + key + " " + cvToString(val.data[key], encoding) + ")";
        }).join(' ') + ")";

      case exports.ClarityType.StringASCII:
        return "\"" + val.data + "\"";

      case exports.ClarityType.StringUTF8:
        return "u\"" + val.data + "\"";
    }
  }
  function cvToValue(val) {
    switch (val.type) {
      case exports.ClarityType.BoolTrue:
        return true;

      case exports.ClarityType.BoolFalse:
        return false;

      case exports.ClarityType.Int:
        return val.value.fromTwos(CLARITY_INT_SIZE).toNumber();

      case exports.ClarityType.UInt:
        return val.value.toNumber();

      case exports.ClarityType.Buffer:
        return "0x" + val.buffer.toString('hex');

      case exports.ClarityType.OptionalNone:
        return null;

      case exports.ClarityType.OptionalSome:
        return cvToJSON(val.value);

      case exports.ClarityType.ResponseErr:
        return cvToJSON(val.value);

      case exports.ClarityType.ResponseOk:
        return cvToJSON(val.value);

      case exports.ClarityType.PrincipalStandard:
      case exports.ClarityType.PrincipalContract:
        return principalToString(val);

      case exports.ClarityType.List:
        return val.list.map(function (v) {
          return cvToJSON(v);
        });

      case exports.ClarityType.Tuple:
        var result = {};
        Object.keys(val.data).forEach(function (key) {
          result[key] = cvToJSON(val.data[key]);
        });
        return result;

      case exports.ClarityType.StringASCII:
        return val.data;

      case exports.ClarityType.StringUTF8:
        return val.data;
    }
  }
  function cvToJSON(val) {
    switch (val.type) {
      case exports.ClarityType.ResponseErr:
        return {
          type: getCVTypeString(val),
          value: cvToValue(val),
          success: false
        };

      case exports.ClarityType.ResponseOk:
        return {
          type: getCVTypeString(val),
          value: cvToValue(val),
          success: true
        };

      default:
        return {
          type: getCVTypeString(val),
          value: cvToValue(val)
        };
    }
  }
  function getCVTypeString(val) {
    switch (val.type) {
      case exports.ClarityType.BoolTrue:
      case exports.ClarityType.BoolFalse:
        return 'bool';

      case exports.ClarityType.Int:
        return 'int';

      case exports.ClarityType.UInt:
        return 'uint';

      case exports.ClarityType.Buffer:
        return "(buff " + val.buffer.length + ")";

      case exports.ClarityType.OptionalNone:
        return '(optional none)';

      case exports.ClarityType.OptionalSome:
        return "(optional " + getCVTypeString(val.value) + ")";

      case exports.ClarityType.ResponseErr:
        return "(response UnknownType " + getCVTypeString(val.value) + ")";

      case exports.ClarityType.ResponseOk:
        return "(response " + getCVTypeString(val.value) + " UnknownType)";

      case exports.ClarityType.PrincipalStandard:
      case exports.ClarityType.PrincipalContract:
        return 'principal';

      case exports.ClarityType.List:
        return "(list " + val.list.length + " " + getCVTypeString(val.list[0]) + ")";

      case exports.ClarityType.Tuple:
        return "(tuple " + Object.keys(val.data).map(function (key) {
          return "(" + key + " " + getCVTypeString(val.data[key]) + ")";
        }).join(' ') + ")";

      case exports.ClarityType.StringASCII:
        return "(string-ascii " + Buffer.from(val.data, 'ascii').length + ")";

      case exports.ClarityType.StringUTF8:
        return "(string-utf8 " + Buffer.from(val.data, 'utf8').length + ")";
    }
  }

  var trueCV = function trueCV() {
    return {
      type: exports.ClarityType.BoolTrue
    };
  };

  var falseCV = function falseCV() {
    return {
      type: exports.ClarityType.BoolFalse
    };
  };

  var intCV = function intCV(value) {
    var bn = new BigNum__default['default'](value);
    var twos = bn.toTwos(CLARITY_INT_SIZE);

    if (twos.bitLength() > CLARITY_INT_SIZE) {
      throw new Error('Cannot construct clarity integer from value greater than INT_SIZE bits');
    }

    return {
      type: exports.ClarityType.Int,
      value: twos
    };
  };

  var uintCV = function uintCV(value) {
    var bn = new BigNum__default['default'](value);
    var twos = bn.toTwos(CLARITY_INT_SIZE);

    if (twos.isNeg()) {
      throw new Error('Cannot construct unsigned clarity integer from negative value');
    } else if (twos.bitLength() > CLARITY_INT_SIZE) {
      throw new Error('Cannot construct unsigned clarity integer from value greater than 128 bits');
    }

    return {
      type: exports.ClarityType.UInt,
      value: twos
    };
  };

  var bufferCV = function bufferCV(buffer) {
    if (buffer.length > 1000000) {
      throw new Error('Cannot construct clarity buffer that is greater than 1MB');
    }

    return {
      type: exports.ClarityType.Buffer,
      buffer: buffer
    };
  };

  var bufferCVFromString = function bufferCVFromString(str) {
    return bufferCV(Buffer.from(str));
  };

  var noneCV = function noneCV() {
    return {
      type: exports.ClarityType.OptionalNone
    };
  };

  var someCV = function someCV(value) {
    return {
      type: exports.ClarityType.OptionalSome,
      value: value
    };
  };

  function responseErrorCV(value) {
    return {
      type: exports.ClarityType.ResponseErr,
      value: value
    };
  }

  function responseOkCV(value) {
    return {
      type: exports.ClarityType.ResponseOk,
      value: value
    };
  }

  function listCV(values) {
    return {
      type: exports.ClarityType.List,
      list: values
    };
  }

  function tupleCV(data) {
    for (var key in data) {
      if (!isClarityName(key)) {
        throw new Error("\"" + key + "\" is not a valid Clarity name");
      }
    }

    return {
      type: exports.ClarityType.Tuple,
      data: data
    };
  }

  var stringAsciiCV = function stringAsciiCV(data) {
    return {
      type: exports.ClarityType.StringASCII,
      data: data
    };
  };

  var stringUtf8CV = function stringUtf8CV(data) {
    return {
      type: exports.ClarityType.StringUTF8,
      data: data
    };
  };

  function bufferWithTypeID(typeId, buffer) {
    var id = Buffer.from([typeId]);
    return Buffer.concat([id, buffer]);
  }

  function serializeBoolCV(value) {
    return Buffer.from([value.type]);
  }

  function serializeOptionalCV(cv) {
    if (cv.type === exports.ClarityType.OptionalNone) {
      return Buffer.from([cv.type]);
    } else {
      return bufferWithTypeID(cv.type, serializeCV(cv.value));
    }
  }

  function serializeBufferCV(cv) {
    var length = Buffer.alloc(4);
    length.writeUInt32BE(cv.buffer.length, 0);
    return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));
  }

  function serializeIntCV(cv) {
    var buffer = cv.value.toArrayLike(Buffer, 'be', 16);
    return bufferWithTypeID(cv.type, buffer);
  }

  function serializeStandardPrincipalCV(cv) {
    return bufferWithTypeID(cv.type, serializeAddress(cv.address));
  }

  function serializeContractPrincipalCV(cv) {
    return bufferWithTypeID(cv.type, Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)]));
  }

  function serializeResponseCV(cv) {
    return bufferWithTypeID(cv.type, serializeCV(cv.value));
  }

  function serializeListCV(cv) {
    var buffers = new BufferArray();
    var length = Buffer.alloc(4);
    length.writeUInt32BE(cv.list.length, 0);
    buffers.push(length);

    for (var _iterator = _createForOfIteratorHelperLoose(cv.list), _step; !(_step = _iterator()).done;) {
      var value = _step.value;
      var serializedValue = serializeCV(value);
      buffers.push(serializedValue);
    }

    return bufferWithTypeID(cv.type, buffers.concatBuffer());
  }

  function serializeTupleCV(cv) {
    var buffers = new BufferArray();
    var length = Buffer.alloc(4);
    length.writeUInt32BE(Object.keys(cv.data).length, 0);
    buffers.push(length);
    var lexicographicOrder = Object.keys(cv.data).sort(function (a, b) {
      var bufA = Buffer.from(a);
      var bufB = Buffer.from(b);
      return bufA.compare(bufB);
    });

    for (var _iterator2 = _createForOfIteratorHelperLoose(lexicographicOrder), _step2; !(_step2 = _iterator2()).done;) {
      var key = _step2.value;
      var nameWithLength = createLPString(key);
      buffers.push(serializeLPString(nameWithLength));
      var serializedValue = serializeCV(cv.data[key]);
      buffers.push(serializedValue);
    }

    return bufferWithTypeID(cv.type, buffers.concatBuffer());
  }

  function serializeStringCV(cv, encoding) {
    var buffers = new BufferArray();
    var str = Buffer.from(cv.data, encoding);
    var len = Buffer.alloc(4);
    len.writeUInt32BE(str.length, 0);
    buffers.push(len);
    buffers.push(str);
    return bufferWithTypeID(cv.type, buffers.concatBuffer());
  }

  function serializeStringAsciiCV(cv) {
    return serializeStringCV(cv, 'ascii');
  }

  function serializeStringUtf8CV(cv) {
    return serializeStringCV(cv, 'utf8');
  }

  function serializeCV(value) {
    switch (value.type) {
      case exports.ClarityType.BoolTrue:
      case exports.ClarityType.BoolFalse:
        return serializeBoolCV(value);

      case exports.ClarityType.OptionalNone:
      case exports.ClarityType.OptionalSome:
        return serializeOptionalCV(value);

      case exports.ClarityType.Buffer:
        return serializeBufferCV(value);

      case exports.ClarityType.Int:
      case exports.ClarityType.UInt:
        return serializeIntCV(value);

      case exports.ClarityType.PrincipalStandard:
        return serializeStandardPrincipalCV(value);

      case exports.ClarityType.PrincipalContract:
        return serializeContractPrincipalCV(value);

      case exports.ClarityType.ResponseOk:
      case exports.ClarityType.ResponseErr:
        return serializeResponseCV(value);

      case exports.ClarityType.List:
        return serializeListCV(value);

      case exports.ClarityType.Tuple:
        return serializeTupleCV(value);

      case exports.ClarityType.StringASCII:
        return serializeStringAsciiCV(value);

      case exports.ClarityType.StringUTF8:
        return serializeStringUtf8CV(value);

      default:
        throw new SerializationError('Unable to serialize. Invalid Clarity Value.');
    }
  }

  function createEnumChecker(enumVariable) {
    var enumValues = Object.values(enumVariable).filter(function (v) {
      return typeof v === 'number';
    });
    var enumValueSet = new Set(enumValues);
    return function (value) {
      return enumValueSet.has(value);
    };
  }

  var enumCheckFunctions = /*#__PURE__*/new Map();
  function isEnum(enumVariable, value) {
    var checker = enumCheckFunctions.get(enumVariable);

    if (checker !== undefined) {
      return checker(value);
    }

    var newChecker = createEnumChecker(enumVariable);
    enumCheckFunctions.set(enumVariable, newChecker);
    return isEnum(enumVariable, value);
  }
  var BufferReader = /*#__PURE__*/function () {
    function BufferReader(options) {
      if (Buffer.isBuffer(options)) {
        this.smartBuffer = new smartBuffer.SmartBuffer({
          buff: options
        });
      } else {
        this.smartBuffer = new smartBuffer.SmartBuffer(options);
      }
    }

    BufferReader.fromBuffer = function fromBuffer(buffer) {
      return new BufferReader({
        buff: buffer
      });
    };

    var _proto = BufferReader.prototype;

    _proto.readBuffer = function readBuffer(length) {
      return this.smartBuffer.readBuffer(length);
    };

    _proto.readUInt32BE = function readUInt32BE(offset) {
      return this.smartBuffer.readUInt32BE(offset);
    };

    _proto.readUInt8 = function readUInt8() {
      return this.smartBuffer.readUInt8();
    };

    _proto.readUInt16BE = function readUInt16BE() {
      return this.smartBuffer.readUInt16BE();
    };

    _proto.readBigUIntLE = function readBigUIntLE(length) {
      var buffer = Buffer.from(this.smartBuffer.readBuffer(length)).reverse();
      var hex = buffer.toString();
      var num = BigInt("0x" + hex);
      return num;
    };

    _proto.readBigUIntBE = function readBigUIntBE(length) {
      var buffer = this.smartBuffer.readBuffer(length);
      var hex = buffer.toString('hex');
      var num = BigInt("0x" + hex);
      return num;
    };

    _proto.readBigUInt64BE = function readBigUInt64BE() {
      return this.smartBuffer.readBigUInt64BE();
    };

    _proto.readString = function readString(arg, encoding) {
      return this.smartBuffer.readString(arg, encoding);
    };

    _proto.readUInt8Enum = function readUInt8Enum(enumVariable, invalidEnumErrorFormatter) {
      var num = this.smartBuffer.readUInt8();

      if (isEnum(enumVariable, num)) {
        return num;
      } else {
        throw invalidEnumErrorFormatter(num);
      }
    };

    _createClass(BufferReader, [{
      key: "readOffset",
      get: function get() {
        return this.smartBuffer.readOffset;
      },
      set: function set(val) {
        this.smartBuffer.readOffset = val;
      }
    }, {
      key: "internalBuffer",
      get: function get() {
        return this.smartBuffer.internalBuffer;
      }
    }]);

    return BufferReader;
  }();

  function deserializeCV(buffer) {
    var bufferReader = Buffer.isBuffer(buffer) ? new BufferReader(buffer) : buffer;
    var type = bufferReader.readUInt8Enum(exports.ClarityType, function (n) {
      throw new DeserializationError("Cannot recognize Clarity Type: " + n);
    });

    switch (type) {
      case exports.ClarityType.Int:
        return intCV(bufferReader.readBuffer(16));

      case exports.ClarityType.UInt:
        return uintCV(bufferReader.readBuffer(16));

      case exports.ClarityType.Buffer:
        var bufferLength = bufferReader.readUInt32BE();
        return bufferCV(bufferReader.readBuffer(bufferLength));

      case exports.ClarityType.BoolTrue:
        return trueCV();

      case exports.ClarityType.BoolFalse:
        return falseCV();

      case exports.ClarityType.PrincipalStandard:
        var sAddress = deserializeAddress(bufferReader);
        return standardPrincipalCVFromAddress(sAddress);

      case exports.ClarityType.PrincipalContract:
        var cAddress = deserializeAddress(bufferReader);
        var contractName = deserializeLPString(bufferReader);
        return contractPrincipalCVFromAddress(cAddress, contractName);

      case exports.ClarityType.ResponseOk:
        return responseOkCV(deserializeCV(bufferReader));

      case exports.ClarityType.ResponseErr:
        return responseErrorCV(deserializeCV(bufferReader));

      case exports.ClarityType.OptionalNone:
        return noneCV();

      case exports.ClarityType.OptionalSome:
        return someCV(deserializeCV(bufferReader));

      case exports.ClarityType.List:
        var listLength = bufferReader.readUInt32BE();
        var listContents = [];

        for (var i = 0; i < listLength; i++) {
          listContents.push(deserializeCV(bufferReader));
        }

        return listCV(listContents);

      case exports.ClarityType.Tuple:
        var tupleLength = bufferReader.readUInt32BE();
        var tupleContents = {};

        for (var _i = 0; _i < tupleLength; _i++) {
          var clarityName = deserializeLPString(bufferReader).content;

          if (clarityName === undefined) {
            throw new DeserializationError('"content" is undefined');
          }

          tupleContents[clarityName] = deserializeCV(bufferReader);
        }

        return tupleCV(tupleContents);

      case exports.ClarityType.StringASCII:
        var asciiStrLen = bufferReader.readUInt32BE();
        var asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');
        return stringAsciiCV(asciiStr);

      case exports.ClarityType.StringUTF8:
        var utf8StrLen = bufferReader.readUInt32BE();
        var utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');
        return stringUtf8CV(utf8Str);

      default:
        throw new DeserializationError('Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.');
    }
  }

  var BufferArray = /*#__PURE__*/function () {
    function BufferArray() {
      this._value = [];
    }

    var _proto = BufferArray.prototype;

    _proto.appendHexString = function appendHexString(hexString) {
      this.value.push(Buffer.from(hexString, 'hex'));
    };

    _proto.push = function push(buffer) {
      return this._value.push(buffer);
    };

    _proto.appendByte = function appendByte(octet) {
      if (!Number.isInteger(octet) || octet < 0 || octet > 255) {
        throw new Error("Value " + octet + " is not a valid byte");
      }

      this.value.push(Buffer.from([octet]));
    };

    _proto.concatBuffer = function concatBuffer() {
      return Buffer.concat(this.value);
    };

    _createClass(BufferArray, [{
      key: "value",
      get: function get() {
        return this._value;
      }
    }]);

    return BufferArray;
  }();
  var leftPadHex = function leftPadHex(hexString) {
    return hexString.length % 2 == 0 ? hexString : "0" + hexString;
  };
  var leftPadHexToLength = function leftPadHexToLength(hexString, length) {
    return hexString.padStart(length, '0');
  };
  var rightPadHexToLength = function rightPadHexToLength(hexString, length) {
    return hexString.padEnd(length, '0');
  };
  var intToHexString = function intToHexString(integer, lengthBytes) {
    if (lengthBytes === void 0) {
      lengthBytes = 8;
    }

    return integer.toString(16).padStart(lengthBytes * 2, '0');
  };
  var hexStringToInt = function hexStringToInt(hexString) {
    return parseInt(hexString, 16);
  };
  var exceedsMaxLengthBytes = function exceedsMaxLengthBytes(string, maxLengthBytes) {
    return string ? Buffer.from(string).length > maxLengthBytes : false;
  };
  function cloneDeep(obj) {
    return lodashCloneDeep__default['default'](obj);
  }
  function omit(obj, prop) {
    var clone = cloneDeep(obj);
    delete clone[prop];
    return clone;
  }
  var sha512_256 = /*#__PURE__*/function (_sha) {
    _inheritsLoose(sha512_256, _sha);

    function sha512_256() {
      var _this;

      _this = _sha.call(this) || this;
      Object.assign(_assertThisInitialized(_this), {
        _ah: 0x22312194,
        _al: 0xfc2bf72c,
        _bh: 0x9f555fa3,
        _bl: 0xc84c64c2,
        _ch: 0x2393b86b,
        _cl: 0x6f53b151,
        _dh: 0x96387719,
        _dl: 0x5940eabd,
        _eh: 0x96283ee2,
        _el: 0xa88effe3,
        _fh: 0xbe5e1e25,
        _fl: 0x53863992,
        _gh: 0x2b0199fc,
        _gl: 0x2c85b8aa,
        _hh: 0x0eb72ddc,
        _hl: 0x81c52ca2
      });
      return _this;
    }

    var _proto2 = sha512_256.prototype;

    _proto2.digest = function digest(encoding) {
      var buff = _sha.prototype.digest.call(this).slice(0, 32);

      return encoding ? buff.toString(encoding) : buff;
    };

    return sha512_256;
  }(sha_js.sha512);
  var txidFromData = function txidFromData(data) {
    return new sha512_256().update(data).digest('hex');
  };
  var hash160 = function hash160(input) {
    var sha256Result = new sha_js.sha256().update(input).digest();
    return Buffer.from(new RIPEMD160__default['default']().update(sha256Result).digest());
  };
  var hashP2PKH = function hashP2PKH(input) {
    return hash160(input).toString('hex');
  };
  var hashP2SH = function hashP2SH(numSigs, pubKeys) {
    if (numSigs > 15 || pubKeys.length > 15) {
      throw Error('P2SH multisig address can only contain up to 15 public keys');
    }

    var bufferArray = new BufferArray();
    bufferArray.appendByte(80 + numSigs);
    pubKeys.forEach(function (pubKey) {
      bufferArray.appendByte(pubKey.length);
      bufferArray.push(pubKey);
    });
    bufferArray.appendByte(80 + pubKeys.length);
    bufferArray.appendByte(174);
    var redeemScript = bufferArray.concatBuffer();
    var redeemScriptHash = hash160(redeemScript);
    return redeemScriptHash.toString('hex');
  };
  function isClarityName(name) {
    var regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
    return regex.test(name) && name.length < 128;
  }
  function fetchPrivate(_x, _x2) {
    return _fetchPrivate.apply(this, arguments);
  }

  function _fetchPrivate() {
    _fetchPrivate = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(input, init) {
      var defaultFetchOpts, fetchOpts, fetchResult;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              defaultFetchOpts = {
                referrer: 'no-referrer',
                referrerPolicy: 'no-referrer'
              };
              fetchOpts = Object.assign(defaultFetchOpts, init);
              _context.next = 4;
              return fetch__default['default'](input, fetchOpts);

            case 4:
              fetchResult = _context.sent;
              return _context.abrupt("return", fetchResult);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _fetchPrivate.apply(this, arguments);
  }

  function cvToHex(cv) {
    var serialized = serializeCV(cv);
    return "0x" + serialized.toString('hex');
  }
  function hexToCV(hex) {
    var hexWithoutPrefix = hex.startsWith('0x') ? hex.slice(2) : hex;
    var bufferCV = Buffer.from(hexWithoutPrefix, 'hex');
    return deserializeCV(bufferCV);
  }
  var parseReadOnlyResponse = function parseReadOnlyResponse(response) {
    if (response.okay) {
      return hexToCV(response.result);
    } else {
      throw new Error(response.cause);
    }
  };
  var validateStacksAddress = function validateStacksAddress(stacksAddress) {
    try {
      c32check.c32addressDecode(stacksAddress);
      return true;
    } catch (e) {
      return false;
    }
  };

  var Deserializable = /*#__PURE__*/function () {
    function Deserializable() {}

    Deserializable.deserialize = function deserialize(bufferReader) {
      var message = new this();
      message.deserialize(bufferReader);
      return message;
    };

    return Deserializable;
  }();

  function createMessageSignature(signature) {
    var length = Buffer.from(signature, 'hex').byteLength;

    if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
      throw Error('Invalid signature');
    }

    return {
      type: exports.StacksMessageType.MessageSignature,
      data: signature
    };
  }
  function emptyMessageSignature() {
    return {
      type: exports.StacksMessageType.MessageSignature,
      data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex')
    };
  }
  function serializeMessageSignature(messageSignature) {
    var bufferArray = new BufferArray();
    bufferArray.appendHexString(messageSignature.data);
    return bufferArray.concatBuffer();
  }
  function deserializeMessageSignature(bufferReader) {
    return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));
  }
  var AuthFieldType;

  (function (AuthFieldType) {
    AuthFieldType[AuthFieldType["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
    AuthFieldType[AuthFieldType["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
    AuthFieldType[AuthFieldType["SignatureCompressed"] = 2] = "SignatureCompressed";
    AuthFieldType[AuthFieldType["SignatureUncompressed"] = 3] = "SignatureUncompressed";
  })(AuthFieldType || (AuthFieldType = {}));

  function createTransactionAuthField(pubKeyEncoding, contents) {
    return {
      pubKeyEncoding: pubKeyEncoding,
      type: exports.StacksMessageType.TransactionAuthField,
      contents: contents
    };
  }
  function serializeTransactionAuthField(field) {
    var bufferArray = new BufferArray();

    switch (field.contents.type) {
      case exports.StacksMessageType.PublicKey:
        if (field.pubKeyEncoding == exports.PubKeyEncoding.Compressed) {
          bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);
          bufferArray.push(serializePublicKey(field.contents));
        } else {
          bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);
          bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));
        }

        break;

      case exports.StacksMessageType.MessageSignature:
        if (field.pubKeyEncoding == exports.PubKeyEncoding.Compressed) {
          bufferArray.appendByte(AuthFieldType.SignatureCompressed);
        } else {
          bufferArray.appendByte(AuthFieldType.SignatureUncompressed);
        }

        bufferArray.push(serializeMessageSignature(field.contents));
        break;
    }

    return bufferArray.concatBuffer();
  }
  function deserializeTransactionAuthField(bufferReader) {
    var authFieldType = bufferReader.readUInt8Enum(AuthFieldType, function (n) {
      throw new DeserializationError("Could not read " + n + " as AuthFieldType");
    });

    switch (authFieldType) {
      case AuthFieldType.PublicKeyCompressed:
        return createTransactionAuthField(exports.PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));

      case AuthFieldType.PublicKeyUncompressed:
        return createTransactionAuthField(exports.PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));

      case AuthFieldType.SignatureCompressed:
        return createTransactionAuthField(exports.PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));

      case AuthFieldType.SignatureUncompressed:
        return createTransactionAuthField(exports.PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));

      default:
        throw new Error("Unknown auth field type: " + JSON.stringify(authFieldType));
    }
  }
  function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {
    var signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;
    var keyEncoding = isCompressed(createStacksPublicKey(pubKey)) ? exports.PubKeyEncoding.Compressed : exports.PubKeyEncoding.Uncompressed;
    return {
      hashMode: hashMode,
      signer: signer,
      nonce: nonce,
      fee: fee,
      keyEncoding: keyEncoding,
      signature: emptyMessageSignature()
    };
  }
  function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {
    var stacksPublicKeys = pubKeys.map(createStacksPublicKey);
    var signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;
    return {
      hashMode: hashMode,
      signer: signer,
      nonce: nonce,
      fee: fee,
      fields: [],
      signaturesRequired: numSigs
    };
  }
  function isSingleSig(condition) {
    return 'signature' in condition;
  }

  function clearCondition(condition) {
    var cloned = cloneDeep(condition);
    cloned.nonce = new BigNum__default['default'](0);
    cloned.fee = new BigNum__default['default'](0);

    if (isSingleSig(cloned)) {
      cloned.signature = emptyMessageSignature();
    } else {
      cloned.fields = [];
    }

    return cloned;
  }

  function serializeSingleSigSpendingCondition(condition) {
    var bufferArray = new BufferArray();
    bufferArray.appendByte(condition.hashMode);
    bufferArray.appendHexString(condition.signer);
    bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));
    bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));
    bufferArray.appendByte(condition.keyEncoding);
    bufferArray.push(serializeMessageSignature(condition.signature));
    return bufferArray.concatBuffer();
  }
  function serializeMultiSigSpendingCondition(condition) {
    var bufferArray = new BufferArray();
    bufferArray.appendByte(condition.hashMode);
    bufferArray.appendHexString(condition.signer);
    bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));
    bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));
    var fields = createLPList(condition.fields);
    bufferArray.push(serializeLPList(fields));
    var numSigs = Buffer.alloc(2);
    numSigs.writeUInt16BE(condition.signaturesRequired, 0);
    bufferArray.push(numSigs);
    return bufferArray.concatBuffer();
  }
  function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {
    var signer = bufferReader.readBuffer(20).toString('hex');
    var nonce = new BigNum__default['default'](bufferReader.readBuffer(8).toString('hex'), 16);
    var fee = new BigNum__default['default'](bufferReader.readBuffer(8).toString('hex'), 16);
    var keyEncoding = bufferReader.readUInt8Enum(exports.PubKeyEncoding, function (n) {
      throw new DeserializationError("Could not parse " + n + " as PubKeyEncoding");
    });
    var signature = deserializeMessageSignature(bufferReader);
    return {
      hashMode: hashMode,
      signer: signer,
      nonce: nonce,
      fee: fee,
      keyEncoding: keyEncoding,
      signature: signature
    };
  }
  function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {
    var signer = bufferReader.readBuffer(20).toString('hex');
    var nonce = new BigNum__default['default'](bufferReader.readBuffer(8).toString('hex'), 16);
    var fee = new BigNum__default['default'](bufferReader.readBuffer(8).toString('hex'), 16);
    var fields = deserializeLPList(bufferReader, exports.StacksMessageType.TransactionAuthField).values;
    var signaturesRequired = bufferReader.readUInt16BE();
    return {
      hashMode: hashMode,
      signer: signer,
      nonce: nonce,
      fee: fee,
      fields: fields,
      signaturesRequired: signaturesRequired
    };
  }
  function serializeSpendingCondition(condition) {
    if (isSingleSig(condition)) {
      return serializeSingleSigSpendingCondition(condition);
    } else {
      return serializeMultiSigSpendingCondition(condition);
    }
  }
  function deserializeSpendingCondition(bufferReader) {
    var hashMode = bufferReader.readUInt8Enum(exports.AddressHashMode, function (n) {
      throw new DeserializationError("Could not parse " + n + " as AddressHashMode");
    });

    if (hashMode === exports.AddressHashMode.SerializeP2PKH || hashMode === exports.AddressHashMode.SerializeP2WPKH) {
      return deserializeSingleSigSpendingCondition(hashMode, bufferReader);
    } else {
      return deserializeMultiSigSpendingCondition(hashMode, bufferReader);
    }
  }
  function makeSigHashPreSign(curSigHash, authType, fee, nonce) {
    var hashLength = 32 + 1 + 8 + 8;
    var sigHash = curSigHash + Buffer.from([authType]).toString('hex') + fee.toArrayLike(Buffer, 'be', 8).toString('hex') + nonce.toArrayLike(Buffer, 'be', 8).toString('hex');

    if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {
      throw Error('Invalid signature hash length');
    }

    return txidFromData(Buffer.from(sigHash, 'hex'));
  }

  function makeSigHashPostSign(curSigHash, pubKey, signature) {
    var hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
    var pubKeyEncoding = isCompressed(pubKey) ? exports.PubKeyEncoding.Compressed : exports.PubKeyEncoding.Uncompressed;
    var sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;
    var sigHashBuffer = Buffer.from(sigHash, 'hex');

    if (sigHashBuffer.byteLength > hashLength) {
      throw Error('Invalid signature hash length');
    }

    return txidFromData(sigHashBuffer);
  }

  function nextSignature(curSigHash, authType, fee, nonce, privateKey) {
    var sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);
    var signature = signWithKey(privateKey, sigHashPreSign);
    var publicKey = getPublicKey(privateKey);
    var nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
    return {
      nextSig: signature,
      nextSigHash: nextSigHash
    };
  }
  function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {
    var sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);
    var publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));
    var nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
    return {
      pubKey: publicKey,
      nextSigHash: nextSigHash
    };
  }

  function newInitialSigHash() {
    var spendingCondition = createSingleSigSpendingCondition(exports.AddressHashMode.SerializeP2PKH, '', new BigNum__default['default'](0), new BigNum__default['default'](0));
    spendingCondition.signer = createEmptyAddress().hash160;
    spendingCondition.keyEncoding = exports.PubKeyEncoding.Compressed;
    spendingCondition.signature = emptyMessageSignature();
    return spendingCondition;
  }

  function verify(condition, initialSigHash, authType) {
    if (isSingleSig(condition)) {
      return verifySingleSig(condition, initialSigHash, authType);
    } else {
      return '';
    }
  }

  function verifySingleSig(condition, initialSigHash, authType) {
    var _nextVerification = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature),
        nextSigHash = _nextVerification.nextSigHash;

    return nextSigHash;
  }

  var Authorization = /*#__PURE__*/function (_Deserializable) {
    _inheritsLoose(Authorization, _Deserializable);

    function Authorization(authType, spendingConditions, sponsorSpendingCondition) {
      var _this;

      _this = _Deserializable.call(this) || this;
      _this.authType = authType;
      _this.spendingCondition = spendingConditions;
      _this.sponsorSpendingCondition = sponsorSpendingCondition;
      return _this;
    }

    var _proto = Authorization.prototype;

    _proto.intoInitialSighashAuth = function intoInitialSighashAuth() {
      if (this.spendingCondition) {
        switch (this.authType) {
          case exports.AuthType.Standard:
            return new Authorization(exports.AuthType.Standard, clearCondition(this.spendingCondition));

          case exports.AuthType.Sponsored:
            return new Authorization(exports.AuthType.Sponsored, clearCondition(this.spendingCondition), newInitialSigHash());

          default:
            throw new SigningError('Unexpected authorization type for signing');
        }
      }

      throw new Error('Authorization missing SpendingCondition');
    };

    _proto.setFee = function setFee(amount) {
      switch (this.authType) {
        case exports.AuthType.Standard:
          this.spendingCondition.fee = amount;
          break;

        case exports.AuthType.Sponsored:
          this.sponsorSpendingCondition.fee = amount;
          break;
      }
    };

    _proto.getFee = function getFee() {
      switch (this.authType) {
        case exports.AuthType.Standard:
          return this.spendingCondition.fee;

        case exports.AuthType.Sponsored:
          return this.sponsorSpendingCondition.fee;

        default:
          return 0;
      }
    };

    _proto.setNonce = function setNonce(nonce) {
      this.spendingCondition.nonce = nonce;
    };

    _proto.setSponsorNonce = function setSponsorNonce(nonce) {
      this.sponsorSpendingCondition.nonce = nonce;
    };

    _proto.setSponsor = function setSponsor(sponsorSpendingCondition) {
      this.sponsorSpendingCondition = sponsorSpendingCondition;
    };

    _proto.verifyOrigin = function verifyOrigin(initialSigHash) {
      switch (this.authType) {
        case exports.AuthType.Standard:
          return verify(this.spendingCondition, initialSigHash, exports.AuthType.Standard);

        case exports.AuthType.Sponsored:
          return verify(this.spendingCondition, initialSigHash, exports.AuthType.Standard);

        default:
          throw new SigningError('Invalid origin auth type');
      }
    };

    _proto.serialize = function serialize() {
      var bufferArray = new BufferArray();

      if (this.authType === undefined) {
        throw new SerializationError('"authType" is undefined');
      }

      bufferArray.appendByte(this.authType);

      switch (this.authType) {
        case exports.AuthType.Standard:
          if (this.spendingCondition === undefined) {
            throw new SerializationError('"spendingCondition" is undefined');
          }

          bufferArray.push(serializeSpendingCondition(this.spendingCondition));
          break;

        case exports.AuthType.Sponsored:
          if (this.spendingCondition === undefined) {
            throw new SerializationError('"spendingCondition" is undefined');
          }

          if (this.sponsorSpendingCondition === undefined) {
            throw new SerializationError('"spendingCondition" is undefined');
          }

          bufferArray.push(serializeSpendingCondition(this.spendingCondition));
          bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));
          break;

        default:
          throw new SerializationError("Unexpected transaction AuthType while serializing: " + JSON.stringify(this.authType));
      }

      return bufferArray.concatBuffer();
    };

    _proto.deserialize = function deserialize(bufferReader) {
      this.authType = bufferReader.readUInt8Enum(exports.AuthType, function (n) {
        throw new DeserializationError("Could not parse " + n + " as AuthType");
      });

      switch (this.authType) {
        case exports.AuthType.Standard:
          this.spendingCondition = deserializeSpendingCondition(bufferReader);
          break;

        case exports.AuthType.Sponsored:
          this.spendingCondition = deserializeSpendingCondition(bufferReader);
          this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);
          break;

        default:
          throw new DeserializationError("Unexpected transaction AuthType while deserializing: " + JSON.stringify(this.authType));
      }
    };

    return Authorization;
  }(Deserializable);
  var StandardAuthorization = /*#__PURE__*/function (_Authorization) {
    _inheritsLoose(StandardAuthorization, _Authorization);

    function StandardAuthorization(spendingCondition) {
      return _Authorization.call(this, exports.AuthType.Standard, spendingCondition) || this;
    }

    return StandardAuthorization;
  }(Authorization);
  var SponsoredAuthorization = /*#__PURE__*/function (_Authorization2) {
    _inheritsLoose(SponsoredAuthorization, _Authorization2);

    function SponsoredAuthorization(originSpendingCondition, sponsorSpendingCondition) {
      var sponsorSC = sponsorSpendingCondition;

      if (!sponsorSC) {
        sponsorSC = createSingleSigSpendingCondition(exports.AddressHashMode.SerializeP2PKH, '0'.repeat(66), new BigNum__default['default'](0), new BigNum__default['default'](0));
      }

      return _Authorization2.call(this, exports.AuthType.Sponsored, originSpendingCondition, sponsorSC) || this;
    }

    return SponsoredAuthorization;
  }(Authorization);

  var StacksTransaction = /*#__PURE__*/function () {
    function StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {
      this.version = version;
      this.auth = auth;
      this.payload = payload;
      this.chainId = chainId != null ? chainId : DEFAULT_CHAIN_ID;
      this.postConditionMode = postConditionMode != null ? postConditionMode : exports.PostConditionMode.Deny;
      this.postConditions = postConditions != null ? postConditions : createLPList([]);

      if (anchorMode) {
        this.anchorMode = anchorMode;
      } else {
        switch (payload.payloadType) {
          case exports.PayloadType.Coinbase:
          case exports.PayloadType.PoisonMicroblock:
            {
              this.anchorMode = exports.AnchorMode.OnChainOnly;
              break;
            }

          case exports.PayloadType.ContractCall:
          case exports.PayloadType.SmartContract:
          case exports.PayloadType.TokenTransfer:
            {
              this.anchorMode = exports.AnchorMode.Any;
              break;
            }
        }
      }
    }

    var _proto = StacksTransaction.prototype;

    _proto.signBegin = function signBegin() {
      var tx = cloneDeep(this);
      tx.auth = tx.auth.intoInitialSighashAuth();
      return tx.txid();
    };

    _proto.verifyBegin = function verifyBegin() {
      var tx = cloneDeep(this);
      tx.auth = tx.auth.intoInitialSighashAuth();
      return tx.txid();
    };

    _proto.createTxWithSignature = function createTxWithSignature(signature) {
      var parsedSig = typeof signature === 'string' ? signature : signature.toString('hex');
      var tx = cloneDeep(this);

      if (!tx.auth.spendingCondition) {
        throw new Error('Cannot set signature on transaction without spending condition');
      }

      tx.auth.spendingCondition.signature = createMessageSignature(parsedSig);
      return tx;
    };

    _proto.verifyOrigin = function verifyOrigin() {
      return this.auth.verifyOrigin(this.verifyBegin());
    };

    _proto.signNextOrigin = function signNextOrigin(sigHash, privateKey) {
      if (this.auth.spendingCondition === undefined) {
        throw new Error('"auth.spendingCondition" is undefined');
      }

      if (this.auth.authType === undefined) {
        throw new Error('"auth.authType" is undefined');
      }

      return this.signAndAppend(this.auth.spendingCondition, sigHash, exports.AuthType.Standard, privateKey);
    };

    _proto.signNextSponsor = function signNextSponsor(sigHash, privateKey) {
      if (this.auth.sponsorSpendingCondition === undefined) {
        throw new Error('"auth.spendingCondition" is undefined');
      }

      if (this.auth.authType === undefined) {
        throw new Error('"auth.authType" is undefined');
      }

      return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, exports.AuthType.Sponsored, privateKey);
    };

    _proto.appendPubkey = function appendPubkey(publicKey) {
      var cond = this.auth.spendingCondition;

      if (cond && !isSingleSig(cond)) {
        var compressed = isCompressed(publicKey);
        cond.fields.push(createTransactionAuthField(compressed ? exports.PubKeyEncoding.Compressed : exports.PubKeyEncoding.Uncompressed, publicKey));
      } else {
        throw new Error("Can't append public key to a singlesig condition");
      }
    };

    _proto.signAndAppend = function signAndAppend(condition, curSigHash, authType, privateKey) {
      var _nextSignature = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey),
          nextSig = _nextSignature.nextSig,
          nextSigHash = _nextSignature.nextSigHash;

      if (isSingleSig(condition)) {
        condition.signature = nextSig;
      } else {
        var compressed = privateKey.data.toString('hex').endsWith('01');
        condition.fields.push(createTransactionAuthField(compressed ? exports.PubKeyEncoding.Compressed : exports.PubKeyEncoding.Uncompressed, nextSig));
      }

      return nextSigHash;
    };

    _proto.txid = function txid() {
      var serialized = this.serialize();
      return txidFromData(serialized);
    };

    _proto.setSponsor = function setSponsor(sponsorSpendingCondition) {
      if (this.auth.authType != exports.AuthType.Sponsored) {
        throw new SigningError('Cannot sponsor sign a non-sponsored transaction');
      }

      this.auth.setSponsor(sponsorSpendingCondition);
    };

    _proto.setFee = function setFee(amount) {
      this.auth.setFee(amount);
    };

    _proto.setNonce = function setNonce(nonce) {
      this.auth.setNonce(nonce);
    };

    _proto.setSponsorNonce = function setSponsorNonce(nonce) {
      this.auth.setSponsorNonce(nonce);
    };

    _proto.serialize = function serialize() {
      if (this.version === undefined) {
        throw new SerializationError('"version" is undefined');
      }

      if (this.chainId === undefined) {
        throw new SerializationError('"chainId" is undefined');
      }

      if (this.auth === undefined) {
        throw new SerializationError('"auth" is undefined');
      }

      if (this.anchorMode === undefined) {
        throw new SerializationError('"anchorMode" is undefined');
      }

      if (this.payload === undefined) {
        throw new SerializationError('"payload" is undefined');
      }

      var bufferArray = new BufferArray();
      bufferArray.appendByte(this.version);
      var chainIdBuffer = Buffer.alloc(4);
      chainIdBuffer.writeUInt32BE(this.chainId, 0);
      bufferArray.push(chainIdBuffer);
      bufferArray.push(this.auth.serialize());
      bufferArray.appendByte(this.anchorMode);
      bufferArray.appendByte(this.postConditionMode);
      bufferArray.push(serializeLPList(this.postConditions));
      bufferArray.push(serializePayload(this.payload));
      return bufferArray.concatBuffer();
    };

    return StacksTransaction;
  }();
  function deserializeTransaction(data) {
    var bufferReader;

    if (typeof data === 'string') {
      if (data.slice(0, 2).toLowerCase() === '0x') {
        bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));
      } else {
        bufferReader = new BufferReader(Buffer.from(data, 'hex'));
      }
    } else if (Buffer.isBuffer(data)) {
      bufferReader = new BufferReader(data);
    } else {
      bufferReader = data;
    }

    var version = bufferReader.readUInt8Enum(exports.TransactionVersion, function (n) {
      throw new Error("Could not parse " + n + " as TransactionVersion");
    });
    var chainId = bufferReader.readUInt32BE();
    var auth = Authorization.deserialize(bufferReader);
    var anchorMode = bufferReader.readUInt8Enum(exports.AnchorMode, function (n) {
      throw new Error("Could not parse " + n + " as AnchorMode");
    });
    var postConditionMode = bufferReader.readUInt8Enum(exports.PostConditionMode, function (n) {
      throw new Error("Could not parse " + n + " as PostConditionMode");
    });
    var postConditions = deserializeLPList(bufferReader, exports.StacksMessageType.PostCondition);
    var payload = deserializePayload(bufferReader);
    return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);
  }

  var TransactionSigner = /*#__PURE__*/function () {
    function TransactionSigner(transaction) {
      this.transaction = transaction;
      this.sigHash = transaction.signBegin();
      this.originDone = false;
      this.checkOversign = true;
      this.checkOverlap = true;
    }

    TransactionSigner.createSponsorSigner = function createSponsorSigner(transaction, spendingCondition) {
      if (transaction.auth.authType != exports.AuthType.Sponsored) {
        throw new SigningError('Cannot add sponsor to non-sponsored transaction');
      }

      var tx = cloneDeep(transaction);
      tx.setSponsor(spendingCondition);
      var originSigHash = tx.verifyOrigin();
      var signer = new this(tx);
      signer.originDone = true;
      signer.sigHash = originSigHash;
      signer.checkOversign = true;
      signer.checkOverlap = true;
      return signer;
    };

    var _proto = TransactionSigner.prototype;

    _proto.signOrigin = function signOrigin(privateKey) {
      if (this.checkOverlap && this.originDone) {
        throw new SigningError('Cannot sign origin after sponsor key');
      }

      if (this.transaction.auth === undefined) {
        throw new SigningError('"transaction.auth" is undefined');
      }

      if (this.transaction.auth.spendingCondition === undefined) {
        throw new SigningError('"transaction.auth.spendingCondition" is undefined');
      }

      if (!isSingleSig(this.transaction.auth.spendingCondition)) {
        var spendingCondition = this.transaction.auth.spendingCondition;

        if (this.checkOversign && spendingCondition.fields.length >= spendingCondition.signaturesRequired) {
          throw new Error('Origin would have too many signatures');
        }
      }

      var nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);
      this.sigHash = nextSighash;
    };

    _proto.appendOrigin = function appendOrigin(publicKey) {
      if (this.checkOverlap && this.originDone) {
        throw Error('Cannot append public key to origin after sponsor key');
      }

      if (this.transaction.auth === undefined) {
        throw new Error('"transaction.auth" is undefined');
      }

      if (this.transaction.auth.spendingCondition === undefined) {
        throw new Error('"transaction.auth.spendingCondition" is undefined');
      }

      this.transaction.appendPubkey(publicKey);
    };

    _proto.signSponsor = function signSponsor(privateKey) {
      if (this.transaction.auth === undefined) {
        throw new SigningError('"transaction.auth" is undefined');
      }

      if (this.transaction.auth.sponsorSpendingCondition === undefined) {
        throw new SigningError('"transaction.auth.spendingCondition" is undefined');
      }

      var nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);
      this.sigHash = nextSighash;
      this.originDone = true;
    };

    _proto.getTxInComplete = function getTxInComplete() {
      return cloneDeep(this.transaction);
    };

    _proto.resume = function resume(transaction) {
      this.transaction = cloneDeep(transaction);
      this.sigHash = transaction.signBegin();
    };

    return TransactionSigner;
  }();

  (function (ClarityAbiTypeId) {
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeUInt128"] = 1] = "ClarityAbiTypeUInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeInt128"] = 2] = "ClarityAbiTypeInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBool"] = 3] = "ClarityAbiTypeBool";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypePrincipal"] = 4] = "ClarityAbiTypePrincipal";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeNone"] = 5] = "ClarityAbiTypeNone";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBuffer"] = 6] = "ClarityAbiTypeBuffer";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeResponse"] = 7] = "ClarityAbiTypeResponse";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeOptional"] = 8] = "ClarityAbiTypeOptional";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTuple"] = 9] = "ClarityAbiTypeTuple";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeList"] = 10] = "ClarityAbiTypeList";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringAscii"] = 11] = "ClarityAbiTypeStringAscii";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringUtf8"] = 12] = "ClarityAbiTypeStringUtf8";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTraitReference"] = 13] = "ClarityAbiTypeTraitReference";
  })(exports.ClarityAbiTypeId || (exports.ClarityAbiTypeId = {}));

  var isClarityAbiPrimitive = function isClarityAbiPrimitive(val) {
    return typeof val === 'string';
  };
  var isClarityAbiBuffer = function isClarityAbiBuffer(val) {
    return val.buffer !== undefined;
  };
  var isClarityAbiStringAscii = function isClarityAbiStringAscii(val) {
    return val['string-ascii'] !== undefined;
  };
  var isClarityAbiStringUtf8 = function isClarityAbiStringUtf8(val) {
    return val['string-utf8'] !== undefined;
  };
  var isClarityAbiResponse = function isClarityAbiResponse(val) {
    return val.response !== undefined;
  };
  var isClarityAbiOptional = function isClarityAbiOptional(val) {
    return val.optional !== undefined;
  };
  var isClarityAbiTuple = function isClarityAbiTuple(val) {
    return val.tuple !== undefined;
  };
  var isClarityAbiList = function isClarityAbiList(val) {
    return val.list !== undefined;
  };
  function getTypeUnion(val) {
    if (isClarityAbiPrimitive(val)) {
      if (val === 'uint128') {
        return {
          id: exports.ClarityAbiTypeId.ClarityAbiTypeUInt128,
          type: val
        };
      } else if (val === 'int128') {
        return {
          id: exports.ClarityAbiTypeId.ClarityAbiTypeInt128,
          type: val
        };
      } else if (val === 'bool') {
        return {
          id: exports.ClarityAbiTypeId.ClarityAbiTypeBool,
          type: val
        };
      } else if (val === 'principal') {
        return {
          id: exports.ClarityAbiTypeId.ClarityAbiTypePrincipal,
          type: val
        };
      } else if (val === 'trait_reference') {
        return {
          id: exports.ClarityAbiTypeId.ClarityAbiTypeTraitReference,
          type: val
        };
      } else if (val === 'none') {
        return {
          id: exports.ClarityAbiTypeId.ClarityAbiTypeNone,
          type: val
        };
      } else {
        throw new Error("Unexpected Clarity ABI type primitive: " + JSON.stringify(val));
      }
    } else if (isClarityAbiBuffer(val)) {
      return {
        id: exports.ClarityAbiTypeId.ClarityAbiTypeBuffer,
        type: val
      };
    } else if (isClarityAbiResponse(val)) {
      return {
        id: exports.ClarityAbiTypeId.ClarityAbiTypeResponse,
        type: val
      };
    } else if (isClarityAbiOptional(val)) {
      return {
        id: exports.ClarityAbiTypeId.ClarityAbiTypeOptional,
        type: val
      };
    } else if (isClarityAbiTuple(val)) {
      return {
        id: exports.ClarityAbiTypeId.ClarityAbiTypeTuple,
        type: val
      };
    } else if (isClarityAbiList(val)) {
      return {
        id: exports.ClarityAbiTypeId.ClarityAbiTypeList,
        type: val
      };
    } else if (isClarityAbiStringAscii(val)) {
      return {
        id: exports.ClarityAbiTypeId.ClarityAbiTypeStringAscii,
        type: val
      };
    } else if (isClarityAbiStringUtf8(val)) {
      return {
        id: exports.ClarityAbiTypeId.ClarityAbiTypeStringUtf8,
        type: val
      };
    } else {
      throw new Error("Unexpected Clarity ABI type: " + JSON.stringify(val));
    }
  }

  function encodeClarityValue(input, val) {
    var union;

    if (input.id !== undefined) {
      union = input;
    } else {
      union = getTypeUnion(input);
    }

    switch (union.id) {
      case exports.ClarityAbiTypeId.ClarityAbiTypeUInt128:
        return uintCV(val);

      case exports.ClarityAbiTypeId.ClarityAbiTypeInt128:
        return intCV(val);

      case exports.ClarityAbiTypeId.ClarityAbiTypeBool:
        if (val === 'false' || val === '0') return falseCV();else if (val === 'true' || val === '1') return trueCV();else throw new Error("Unexpected Clarity bool value: " + JSON.stringify(val));

      case exports.ClarityAbiTypeId.ClarityAbiTypePrincipal:
        if (val.includes('.')) {
          var _val$split = val.split('.'),
              _addr = _val$split[0],
              _name = _val$split[1];

          return contractPrincipalCV(_addr, _name);
        } else {
          return standardPrincipalCV(val);
        }

      case exports.ClarityAbiTypeId.ClarityAbiTypeTraitReference:
        var _val$split2 = val.split('.'),
            addr = _val$split2[0],
            name = _val$split2[1];

        return contractPrincipalCV(addr, name);

      case exports.ClarityAbiTypeId.ClarityAbiTypeNone:
        return noneCV();

      case exports.ClarityAbiTypeId.ClarityAbiTypeBuffer:
        return bufferCV(Buffer.from(val, 'utf8'));

      case exports.ClarityAbiTypeId.ClarityAbiTypeStringAscii:
        return stringAsciiCV(val);

      case exports.ClarityAbiTypeId.ClarityAbiTypeStringUtf8:
        return stringUtf8CV(val);

      case exports.ClarityAbiTypeId.ClarityAbiTypeResponse:
        throw new NotImplementedError("Unsupported encoding for Clarity type: " + union.id);

      case exports.ClarityAbiTypeId.ClarityAbiTypeOptional:
        throw new NotImplementedError("Unsupported encoding for Clarity type: " + union.id);

      case exports.ClarityAbiTypeId.ClarityAbiTypeTuple:
        throw new NotImplementedError("Unsupported encoding for Clarity type: " + union.id);

      case exports.ClarityAbiTypeId.ClarityAbiTypeList:
        throw new NotImplementedError("Unsupported encoding for Clarity type: " + union.id);

      default:
        throw new Error("Unexpected Clarity type ID: " + JSON.stringify(union));
    }
  }
  function getTypeString(val) {
    if (isClarityAbiPrimitive(val)) {
      if (val === 'int128') {
        return 'int';
      } else if (val === 'uint128') {
        return 'uint';
      }

      return val;
    } else if (isClarityAbiBuffer(val)) {
      return "(buff " + val.buffer.length + ")";
    } else if (isClarityAbiStringAscii(val)) {
      return "(string-ascii " + val['string-ascii'].length + ")";
    } else if (isClarityAbiStringUtf8(val)) {
      return "(string-utf8 " + val['string-utf8'].length + ")";
    } else if (isClarityAbiResponse(val)) {
      return "(response " + getTypeString(val.response.ok) + " " + getTypeString(val.response.error) + ")";
    } else if (isClarityAbiOptional(val)) {
      return "(optional " + getTypeString(val.optional) + ")";
    } else if (isClarityAbiTuple(val)) {
      return "(tuple " + val.tuple.map(function (t) {
        return "(" + t.name + " " + getTypeString(t.type) + ")";
      }).join(' ') + ")";
    } else if (isClarityAbiList(val)) {
      return "(list " + val.list.length + " " + getTypeString(val.list.type) + ")";
    } else {
      throw new Error("Type string unsupported for Clarity type: " + JSON.stringify(val));
    }
  }
  function abiFunctionToString(func) {
    var access = func.access === 'read_only' ? 'read-only' : func.access;
    return "(define-" + access + " (" + func.name + " " + func.args.map(function (arg) {
      return "(" + arg.name + " " + getTypeString(arg.type) + ")";
    }).join(' ') + "))";
  }

  function matchType(cv, abiType) {
    var union = getTypeUnion(abiType);

    switch (cv.type) {
      case exports.ClarityType.BoolTrue:
      case exports.ClarityType.BoolFalse:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeBool;

      case exports.ClarityType.Int:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeInt128;

      case exports.ClarityType.UInt:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeUInt128;

      case exports.ClarityType.Buffer:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeBuffer && union.type.buffer.length >= cv.buffer.length;

      case exports.ClarityType.StringASCII:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeStringAscii && union.type['string-ascii'].length >= cv.data.length;

      case exports.ClarityType.StringUTF8:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeStringUtf8 && union.type['string-utf8'].length >= cv.data.length;

      case exports.ClarityType.OptionalNone:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeNone || union.id === exports.ClarityAbiTypeId.ClarityAbiTypeOptional;

      case exports.ClarityType.OptionalSome:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeOptional && matchType(cv.value, union.type.optional);

      case exports.ClarityType.ResponseErr:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.error);

      case exports.ClarityType.ResponseOk:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.ok);

      case exports.ClarityType.PrincipalContract:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypePrincipal || union.id === exports.ClarityAbiTypeId.ClarityAbiTypeTraitReference;

      case exports.ClarityType.PrincipalStandard:
        return union.id === exports.ClarityAbiTypeId.ClarityAbiTypePrincipal;

      case exports.ClarityType.List:
        return union.id == exports.ClarityAbiTypeId.ClarityAbiTypeList && union.type.list.length === cv.list.length && cv.list.every(function (val) {
          return matchType(val, union.type.list.type);
        });

      case exports.ClarityType.Tuple:
        if (union.id == exports.ClarityAbiTypeId.ClarityAbiTypeTuple) {
          var tuple = cloneDeep(cv.data);

          for (var i = 0; i < union.type.tuple.length; i++) {
            var abiTupleEntry = union.type.tuple[i];
            var key = abiTupleEntry.name;
            var val = tuple[key];

            if (val) {
              if (!matchType(val, abiTupleEntry.type)) {
                return false;
              }

              delete tuple[key];
            } else {
              return false;
            }
          }

          return true;
        } else {
          return false;
        }

      default:
        return false;
    }
  }

  function validateContractCall(payload, abi) {
    var filtered = abi.functions.filter(function (fn) {
      return fn.name === payload.functionName.content;
    });

    if (filtered.length === 1) {
      var abiFunc = filtered[0];
      var abiArgs = abiFunc.args;

      if (payload.functionArgs.length !== abiArgs.length) {
        throw new Error("Clarity function expects " + abiArgs.length + " argument(s) but received " + payload.functionArgs.length);
      }

      for (var i = 0; i < payload.functionArgs.length; i++) {
        var payloadArg = payload.functionArgs[i];
        var abiArg = abiArgs[i];

        if (!matchType(payloadArg, abiArg.type)) {
          var argNum = i + 1;
          throw new Error("Clarity function `" + payload.functionName.content + "` expects argument " + argNum + " to be of type " + getTypeString(abiArg.type) + ", not " + getCVTypeString(payloadArg));
        }
      }

      return true;
    } else if (filtered.length === 0) {
      throw new Error("ABI doesn't contain a function with the name " + payload.functionName.content);
    } else {
      throw new Error("Malformed ABI. Contains multiple functions with the name " + payload.functionName.content);
    }
  }
  function parseToCV(input, type) {
    var typeString = getTypeString(type);

    if (isClarityAbiPrimitive(type)) {
      if (type === 'uint128') {
        return uintCV(input);
      } else if (type === 'int128') {
        return intCV(input);
      } else if (type === 'bool') {
        if (input.toLowerCase() === 'true') {
          return trueCV();
        } else if (input.toLowerCase() === 'false') {
          return falseCV();
        } else {
          throw new Error("Invalid bool value: " + input);
        }
      } else if (type === 'principal') {
        if (input.includes('.')) {
          var _input$split = input.split('.'),
              address = _input$split[0],
              contractName = _input$split[1];

          return contractPrincipalCV(address, contractName);
        } else {
          return standardPrincipalCV(input);
        }
      } else {
        throw new Error("Contract function contains unsupported Clarity ABI type: " + typeString);
      }
    } else if (isClarityAbiBuffer(type)) {
      var inputLength = Buffer.from(input).byteLength;

      if (inputLength > type.buffer.length) {
        throw new Error("Input exceeds specified buffer length limit of " + type.buffer.length);
      }

      return bufferCVFromString(input);
    } else if (isClarityAbiResponse(type)) {
      throw new Error("Contract function contains unsupported Clarity ABI type: " + typeString);
    } else if (isClarityAbiOptional(type)) {
      throw new Error("Contract function contains unsupported Clarity ABI type: " + typeString);
    } else if (isClarityAbiTuple(type)) {
      throw new Error("Contract function contains unsupported Clarity ABI type: " + typeString);
    } else if (isClarityAbiList(type)) {
      throw new Error("Contract function contains unsupported Clarity ABI type: " + typeString);
    } else {
      throw new Error("Contract function contains unsupported Clarity ABI type: " + typeString);
    }
  }

  function getNonce(_x, _x2) {
    return _getNonce.apply(this, arguments);
  }

  function _getNonce() {
    _getNonce = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(address, network$1) {
      var defaultNetwork, url, response, msg, result;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              defaultNetwork = new network.StacksMainnet();
              url = network$1 ? network$1.getAccountApiUrl(address) : defaultNetwork.getAccountApiUrl(address);
              _context.next = 4;
              return common.fetchPrivate(url);

            case 4:
              response = _context.sent;

              if (response.ok) {
                _context.next = 16;
                break;
              }

              msg = '';
              _context.prev = 7;
              _context.next = 10;
              return response.text();

            case 10:
              msg = _context.sent;
              _context.next = 15;
              break;

            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](7);

            case 15:
              throw new Error("Error fetching nonce. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

            case 16:
              _context.next = 18;
              return response.json();

            case 18:
              result = _context.sent;
              return _context.abrupt("return", new BigNum__default['default'](result.nonce));

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[7, 13]]);
    }));
    return _getNonce.apply(this, arguments);
  }

  function estimateTransfer(_x3, _x4) {
    return _estimateTransfer.apply(this, arguments);
  }

  function _estimateTransfer() {
    _estimateTransfer = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(transaction, network$1) {
      var requestHeaders, fetchOptions, defaultNetwork, url, response, msg, feeRateResult, txBytes, feeRate;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(transaction.payload.payloadType !== exports.PayloadType.TokenTransfer)) {
                _context2.next = 2;
                break;
              }

              throw new Error("Transaction fee estimation only possible with " + exports.PayloadType[exports.PayloadType.TokenTransfer] + " transactions. Invoked with: " + exports.PayloadType[transaction.payload.payloadType]);

            case 2:
              requestHeaders = {
                Accept: 'application/text'
              };
              fetchOptions = {
                method: 'GET',
                headers: requestHeaders
              };
              defaultNetwork = new network.StacksMainnet();
              url = network$1 ? network$1.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();
              _context2.next = 8;
              return common.fetchPrivate(url, fetchOptions);

            case 8:
              response = _context2.sent;

              if (response.ok) {
                _context2.next = 20;
                break;
              }

              msg = '';
              _context2.prev = 11;
              _context2.next = 14;
              return response.text();

            case 14:
              msg = _context2.sent;
              _context2.next = 19;
              break;

            case 17:
              _context2.prev = 17;
              _context2.t0 = _context2["catch"](11);

            case 19:
              throw new Error("Error estimating transaction fee. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

            case 20:
              _context2.next = 22;
              return response.text();

            case 22:
              feeRateResult = _context2.sent;
              txBytes = new BigNum__default['default'](transaction.serialize().byteLength);
              feeRate = new BigNum__default['default'](feeRateResult);
              return _context2.abrupt("return", feeRate.mul(txBytes));

            case 26:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[11, 17]]);
    }));
    return _estimateTransfer.apply(this, arguments);
  }

  function broadcastTransaction(_x5, _x6, _x7) {
    return _broadcastTransaction.apply(this, arguments);
  }

  function _broadcastTransaction() {
    _broadcastTransaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(transaction, network, attachment) {
      var rawTx, url;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              rawTx = transaction.serialize();
              url = network.getBroadcastApiUrl();
              return _context3.abrupt("return", broadcastRawTransaction(rawTx, url, attachment));

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _broadcastTransaction.apply(this, arguments);
  }

  function broadcastRawTransaction(_x8, _x9, _x10) {
    return _broadcastRawTransaction.apply(this, arguments);
  }

  function _broadcastRawTransaction() {
    _broadcastRawTransaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(rawTx, url, attachment) {
      var options, response, text;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              options = {
                method: 'POST',
                headers: {
                  'Content-Type': attachment ? 'application/json' : 'application/octet-stream'
                },
                body: attachment ? JSON.stringify({
                  tx: rawTx.toString('hex'),
                  attachment: attachment.toString('hex')
                }) : rawTx
              };
              _context4.next = 3;
              return common.fetchPrivate(url, options);

            case 3:
              response = _context4.sent;

              if (response.ok) {
                _context4.next = 14;
                break;
              }

              _context4.prev = 5;
              _context4.next = 8;
              return response.json();

            case 8:
              return _context4.abrupt("return", _context4.sent);

            case 11:
              _context4.prev = 11;
              _context4.t0 = _context4["catch"](5);
              throw Error("Failed to broadcast transaction: " + _context4.t0.message);

            case 14:
              _context4.next = 16;
              return response.text();

            case 16:
              text = _context4.sent;
              _context4.prev = 17;
              return _context4.abrupt("return", JSON.parse(text));

            case 21:
              _context4.prev = 21;
              _context4.t1 = _context4["catch"](17);
              return _context4.abrupt("return", text);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, null, [[5, 11], [17, 21]]);
    }));
    return _broadcastRawTransaction.apply(this, arguments);
  }

  function getAbi(_x11, _x12, _x13) {
    return _getAbi.apply(this, arguments);
  }

  function _getAbi() {
    _getAbi = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(address, contractName, network) {
      var options, url, response, msg;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              options = {
                method: 'GET'
              };
              url = network.getAbiApiUrl(address, contractName);
              _context5.next = 4;
              return common.fetchPrivate(url, options);

            case 4:
              response = _context5.sent;

              if (response.ok) {
                _context5.next = 16;
                break;
              }

              msg = '';
              _context5.prev = 7;
              _context5.next = 10;
              return response.text();

            case 10:
              msg = _context5.sent;
              _context5.next = 15;
              break;

            case 13:
              _context5.prev = 13;
              _context5.t0 = _context5["catch"](7);

            case 15:
              throw new Error("Error fetching contract ABI for contract \"" + contractName + "\" at address " + address + ". Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

            case 16:
              _context5.t1 = JSON;
              _context5.next = 19;
              return response.text();

            case 19:
              _context5.t2 = _context5.sent;
              return _context5.abrupt("return", _context5.t1.parse.call(_context5.t1, _context5.t2));

            case 21:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, null, [[7, 13]]);
    }));
    return _getAbi.apply(this, arguments);
  }

  function makeUnsignedSTXTokenTransfer(_x14) {
    return _makeUnsignedSTXTokenTransfer.apply(this, arguments);
  }

  function _makeUnsignedSTXTokenTransfer() {
    _makeUnsignedSTXTokenTransfer = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(txOptions) {
      var defaultOptions, options, payload, authorization, spendingCondition, postConditions, lpPostConditions, transaction, txFee, addressVersion, senderAddress, txNonce;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              defaultOptions = {
                fee: new BigNum__default['default'](0),
                nonce: new BigNum__default['default'](0),
                network: new network.StacksMainnet(),
                anchorMode: exports.AnchorMode.Any,
                postConditionMode: exports.PostConditionMode.Deny,
                memo: '',
                sponsored: false
              };
              options = Object.assign(defaultOptions, txOptions);
              payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);
              authorization = null;
              spendingCondition = null;

              if ('publicKey' in options) {
                spendingCondition = createSingleSigSpendingCondition(exports.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
              } else {
                spendingCondition = createMultiSigSpendingCondition(exports.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
              }

              if (options.sponsored) {
                authorization = new SponsoredAuthorization(spendingCondition);
              } else {
                authorization = new StandardAuthorization(spendingCondition);
              }

              postConditions = [];

              if (options.postConditions && options.postConditions.length > 0) {
                options.postConditions.forEach(function (postCondition) {
                  postConditions.push(postCondition);
                });
              }

              lpPostConditions = createLPList(postConditions);
              transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, defaultOptions.anchorMode, options.network.chainId);

              if (txOptions.fee) {
                _context6.next = 16;
                break;
              }

              _context6.next = 14;
              return estimateTransfer(transaction, options.network);

            case 14:
              txFee = _context6.sent;
              transaction.setFee(txFee);

            case 16:
              if (txOptions.nonce) {
                _context6.next = 23;
                break;
              }

              addressVersion = options.network.version === exports.TransactionVersion.Mainnet ? exports.AddressVersion.MainnetSingleSig : exports.AddressVersion.TestnetSingleSig;
              senderAddress = c32check.c32address(addressVersion, transaction.auth.spendingCondition.signer);
              _context6.next = 21;
              return getNonce(senderAddress, options.network);

            case 21:
              txNonce = _context6.sent;
              transaction.setNonce(txNonce);

            case 23:
              return _context6.abrupt("return", transaction);

            case 24:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));
    return _makeUnsignedSTXTokenTransfer.apply(this, arguments);
  }

  function makeSTXTokenTransfer(_x15) {
    return _makeSTXTokenTransfer.apply(this, arguments);
  }

  function _makeSTXTokenTransfer() {
    _makeSTXTokenTransfer = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(txOptions) {
      var publicKey, options, transaction, privKey, signer, _options, _transaction, _signer, pubKeys, _loop, _iterator, _step, _iterator2, _step2, key;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!('senderKey' in txOptions)) {
                _context7.next = 12;
                break;
              }

              publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));
              options = omit(txOptions, 'senderKey');
              _context7.next = 5;
              return makeUnsignedSTXTokenTransfer(_extends({
                publicKey: publicKey
              }, options));

            case 5:
              transaction = _context7.sent;
              privKey = createStacksPrivateKey(txOptions.senderKey);
              signer = new TransactionSigner(transaction);
              signer.signOrigin(privKey);
              return _context7.abrupt("return", transaction);

            case 12:
              _options = omit(txOptions, 'signerKeys');
              _context7.next = 15;
              return makeUnsignedSTXTokenTransfer(_options);

            case 15:
              _transaction = _context7.sent;
              _signer = new TransactionSigner(_transaction);
              pubKeys = txOptions.publicKeys;

              _loop = function _loop() {
                var key = _step.value;
                var pubKey = pubKeyfromPrivKey(key);
                pubKeys = pubKeys.filter(function (pk) {
                  return pk !== pubKey.data.toString('hex');
                });

                _signer.signOrigin(createStacksPrivateKey(key));
              };

              for (_iterator = _createForOfIteratorHelperLoose(txOptions.signerKeys); !(_step = _iterator()).done;) {
                _loop();
              }

              for (_iterator2 = _createForOfIteratorHelperLoose(pubKeys); !(_step2 = _iterator2()).done;) {
                key = _step2.value;

                _signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));
              }

              return _context7.abrupt("return", _transaction);

            case 22:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));
    return _makeSTXTokenTransfer.apply(this, arguments);
  }

  function estimateContractDeploy(_x16, _x17) {
    return _estimateContractDeploy.apply(this, arguments);
  }

  function _estimateContractDeploy() {
    _estimateContractDeploy = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(transaction, network$1) {
      var requestHeaders, fetchOptions, defaultNetwork, url, response, msg, feeRateResult, txBytes, feeRate;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (!(transaction.payload.payloadType !== exports.PayloadType.SmartContract)) {
                _context8.next = 2;
                break;
              }

              throw new Error("Contract deploy fee estimation only possible with " + exports.PayloadType[exports.PayloadType.SmartContract] + " transactions. Invoked with: " + exports.PayloadType[transaction.payload.payloadType]);

            case 2:
              requestHeaders = {
                Accept: 'application/text'
              };
              fetchOptions = {
                method: 'GET',
                headers: requestHeaders
              };
              defaultNetwork = new network.StacksMainnet();
              url = network$1 ? network$1.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();
              _context8.next = 8;
              return common.fetchPrivate(url, fetchOptions);

            case 8:
              response = _context8.sent;

              if (response.ok) {
                _context8.next = 20;
                break;
              }

              msg = '';
              _context8.prev = 11;
              _context8.next = 14;
              return response.text();

            case 14:
              msg = _context8.sent;
              _context8.next = 19;
              break;

            case 17:
              _context8.prev = 17;
              _context8.t0 = _context8["catch"](11);

            case 19:
              throw new Error("Error estimating contract deploy fee. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

            case 20:
              _context8.next = 22;
              return response.text();

            case 22:
              feeRateResult = _context8.sent;
              txBytes = new BigNum__default['default'](transaction.serialize().byteLength);
              feeRate = new BigNum__default['default'](feeRateResult);
              return _context8.abrupt("return", feeRate.mul(txBytes));

            case 26:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, null, [[11, 17]]);
    }));
    return _estimateContractDeploy.apply(this, arguments);
  }

  function makeContractDeploy(_x18) {
    return _makeContractDeploy.apply(this, arguments);
  }

  function _makeContractDeploy() {
    _makeContractDeploy = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(txOptions) {
      var defaultOptions, options, payload, addressHashMode, privKey, pubKey, authorization, spendingCondition, postConditions, lpPostConditions, transaction, txFee, addressVersion, senderAddress, txNonce, signer;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              defaultOptions = {
                fee: new BigNum__default['default'](0),
                nonce: new BigNum__default['default'](0),
                network: new network.StacksMainnet(),
                anchorMode: exports.AnchorMode.Any,
                postConditionMode: exports.PostConditionMode.Deny,
                sponsored: false
              };
              options = Object.assign(defaultOptions, txOptions);
              payload = createSmartContractPayload(options.contractName, options.codeBody);
              addressHashMode = exports.AddressHashMode.SerializeP2PKH;
              privKey = createStacksPrivateKey(options.senderKey);
              pubKey = getPublicKey(privKey);
              authorization = null;
              spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);

              if (options.sponsored) {
                authorization = new SponsoredAuthorization(spendingCondition);
              } else {
                authorization = new StandardAuthorization(spendingCondition);
              }

              postConditions = [];

              if (options.postConditions && options.postConditions.length > 0) {
                options.postConditions.forEach(function (postCondition) {
                  postConditions.push(postCondition);
                });
              }

              lpPostConditions = createLPList(postConditions);
              transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);

              if (txOptions.fee) {
                _context9.next = 18;
                break;
              }

              _context9.next = 16;
              return estimateContractDeploy(transaction, options.network);

            case 16:
              txFee = _context9.sent;
              transaction.setFee(txFee);

            case 18:
              if (txOptions.nonce) {
                _context9.next = 25;
                break;
              }

              addressVersion = options.network.version === exports.TransactionVersion.Mainnet ? exports.AddressVersion.MainnetSingleSig : exports.AddressVersion.TestnetSingleSig;
              senderAddress = publicKeyToAddress(addressVersion, pubKey);
              _context9.next = 23;
              return getNonce(senderAddress, options.network);

            case 23:
              txNonce = _context9.sent;
              transaction.setNonce(txNonce);

            case 25:
              if (options.senderKey) {
                signer = new TransactionSigner(transaction);
                signer.signOrigin(privKey);
              }

              return _context9.abrupt("return", transaction);

            case 27:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));
    return _makeContractDeploy.apply(this, arguments);
  }

  function estimateContractFunctionCall(_x19, _x20) {
    return _estimateContractFunctionCall.apply(this, arguments);
  }

  function _estimateContractFunctionCall() {
    _estimateContractFunctionCall = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(transaction, network$1) {
      var requestHeaders, fetchOptions, defaultNetwork, url, response, msg, feeRateResult, txBytes, feeRate;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (!(transaction.payload.payloadType !== exports.PayloadType.ContractCall)) {
                _context10.next = 2;
                break;
              }

              throw new Error("Contract call fee estimation only possible with " + exports.PayloadType[exports.PayloadType.ContractCall] + " transactions. Invoked with: " + exports.PayloadType[transaction.payload.payloadType]);

            case 2:
              requestHeaders = {
                Accept: 'application/text'
              };
              fetchOptions = {
                method: 'GET',
                headers: requestHeaders
              };
              defaultNetwork = new network.StacksMainnet();
              url = network$1 ? network$1.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();
              _context10.next = 8;
              return common.fetchPrivate(url, fetchOptions);

            case 8:
              response = _context10.sent;

              if (response.ok) {
                _context10.next = 20;
                break;
              }

              msg = '';
              _context10.prev = 11;
              _context10.next = 14;
              return response.text();

            case 14:
              msg = _context10.sent;
              _context10.next = 19;
              break;

            case 17:
              _context10.prev = 17;
              _context10.t0 = _context10["catch"](11);

            case 19:
              throw new Error("Error estimating contract call fee. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

            case 20:
              _context10.next = 22;
              return response.text();

            case 22:
              feeRateResult = _context10.sent;
              txBytes = new BigNum__default['default'](transaction.serialize().byteLength);
              feeRate = new BigNum__default['default'](feeRateResult);
              return _context10.abrupt("return", feeRate.mul(txBytes));

            case 26:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, null, [[11, 17]]);
    }));
    return _estimateContractFunctionCall.apply(this, arguments);
  }

  function makeUnsignedContractCall(_x21) {
    return _makeUnsignedContractCall.apply(this, arguments);
  }

  function _makeUnsignedContractCall() {
    _makeUnsignedContractCall = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(txOptions) {
      var defaultOptions, options, payload, abi, spendingCondition, authorization, postConditions, lpPostConditions, transaction, txFee, addressVersion, senderAddress, txNonce;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              defaultOptions = {
                fee: new BigNum__default['default'](0),
                nonce: new BigNum__default['default'](0),
                network: new network.StacksMainnet(),
                anchorMode: exports.AnchorMode.Any,
                postConditionMode: exports.PostConditionMode.Deny,
                sponsored: false
              };
              options = Object.assign(defaultOptions, txOptions);
              payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);

              if (!(options == null ? void 0 : options.validateWithAbi)) {
                _context11.next = 16;
                break;
              }

              if (!(typeof options.validateWithAbi === 'boolean')) {
                _context11.next = 14;
                break;
              }

              if (!(options == null ? void 0 : options.network)) {
                _context11.next = 11;
                break;
              }

              _context11.next = 8;
              return getAbi(options.contractAddress, options.contractName, options.network);

            case 8:
              abi = _context11.sent;
              _context11.next = 12;
              break;

            case 11:
              throw new Error('Network option must be provided in order to validate with ABI');

            case 12:
              _context11.next = 15;
              break;

            case 14:
              abi = options.validateWithAbi;

            case 15:
              validateContractCall(payload, abi);

            case 16:
              spendingCondition = null;
              authorization = null;

              if ('publicKey' in options) {
                spendingCondition = createSingleSigSpendingCondition(exports.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
              } else {
                spendingCondition = createMultiSigSpendingCondition(exports.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
              }

              if (options.sponsored) {
                authorization = new SponsoredAuthorization(spendingCondition);
              } else {
                authorization = new StandardAuthorization(spendingCondition);
              }

              postConditions = [];

              if (options.postConditions && options.postConditions.length > 0) {
                options.postConditions.forEach(function (postCondition) {
                  postConditions.push(postCondition);
                });
              }

              lpPostConditions = createLPList(postConditions);
              transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);

              if (txOptions.fee) {
                _context11.next = 29;
                break;
              }

              _context11.next = 27;
              return estimateContractFunctionCall(transaction, options.network);

            case 27:
              txFee = _context11.sent;
              transaction.setFee(txFee);

            case 29:
              if (txOptions.nonce) {
                _context11.next = 36;
                break;
              }

              addressVersion = options.network.version === exports.TransactionVersion.Mainnet ? exports.AddressVersion.MainnetSingleSig : exports.AddressVersion.TestnetSingleSig;
              senderAddress = c32check.c32address(addressVersion, transaction.auth.spendingCondition.signer);
              _context11.next = 34;
              return getNonce(senderAddress, options.network);

            case 34:
              txNonce = _context11.sent;
              transaction.setNonce(txNonce);

            case 36:
              return _context11.abrupt("return", transaction);

            case 37:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));
    return _makeUnsignedContractCall.apply(this, arguments);
  }

  function makeContractCall(_x22) {
    return _makeContractCall.apply(this, arguments);
  }

  function _makeContractCall() {
    _makeContractCall = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(txOptions) {
      var publicKey, options, transaction, privKey, signer, _options2, _transaction2, _signer2, _pubKeys, _loop2, _iterator3, _step3, _iterator4, _step4, key;

      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (!('senderKey' in txOptions)) {
                _context12.next = 12;
                break;
              }

              publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));
              options = omit(txOptions, 'senderKey');
              _context12.next = 5;
              return makeUnsignedContractCall(_extends({
                publicKey: publicKey
              }, options));

            case 5:
              transaction = _context12.sent;
              privKey = createStacksPrivateKey(txOptions.senderKey);
              signer = new TransactionSigner(transaction);
              signer.signOrigin(privKey);
              return _context12.abrupt("return", transaction);

            case 12:
              _options2 = omit(txOptions, 'signerKeys');
              _context12.next = 15;
              return makeUnsignedContractCall(_options2);

            case 15:
              _transaction2 = _context12.sent;
              _signer2 = new TransactionSigner(_transaction2);
              _pubKeys = txOptions.publicKeys;

              _loop2 = function _loop2() {
                var key = _step3.value;
                var pubKey = pubKeyfromPrivKey(key);
                _pubKeys = _pubKeys.filter(function (pk) {
                  return pk !== pubKey.data.toString('hex');
                });

                _signer2.signOrigin(createStacksPrivateKey(key));
              };

              for (_iterator3 = _createForOfIteratorHelperLoose(txOptions.signerKeys); !(_step3 = _iterator3()).done;) {
                _loop2();
              }

              for (_iterator4 = _createForOfIteratorHelperLoose(_pubKeys); !(_step4 = _iterator4()).done;) {
                key = _step4.value;

                _signer2.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));
              }

              return _context12.abrupt("return", _transaction2);

            case 22:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));
    return _makeContractCall.apply(this, arguments);
  }

  function makeStandardSTXPostCondition(address, conditionCode, amount) {
    return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);
  }
  function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
    return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);
  }
  function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
    return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);
  }
  function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
    return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);
  }
  function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {
    return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetName);
  }
  function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {
    return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);
  }
  function callReadOnlyFunction(_x23) {
    return _callReadOnlyFunction.apply(this, arguments);
  }

  function _callReadOnlyFunction() {
    _callReadOnlyFunction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(readOnlyFunctionOptions) {
      var defaultOptions, options, contractName, contractAddress, functionName, functionArgs, network$1, senderAddress, url, args, body, response, msg;
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              defaultOptions = {
                network: new network.StacksMainnet()
              };
              options = Object.assign(defaultOptions, readOnlyFunctionOptions);
              contractName = options.contractName, contractAddress = options.contractAddress, functionName = options.functionName, functionArgs = options.functionArgs, network$1 = options.network, senderAddress = options.senderAddress;
              url = network$1.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);
              args = functionArgs.map(function (arg) {
                return cvToHex(arg);
              });
              body = JSON.stringify({
                sender: senderAddress,
                arguments: args
              });
              _context13.next = 8;
              return common.fetchPrivate(url, {
                method: 'POST',
                body: body,
                headers: {
                  'Content-Type': 'application/json'
                }
              });

            case 8:
              response = _context13.sent;

              if (response.ok) {
                _context13.next = 20;
                break;
              }

              msg = '';
              _context13.prev = 11;
              _context13.next = 14;
              return response.text();

            case 14:
              msg = _context13.sent;
              _context13.next = 19;
              break;

            case 17:
              _context13.prev = 17;
              _context13.t0 = _context13["catch"](11);

            case 19:
              throw new Error("Error calling read-only function. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

            case 20:
              return _context13.abrupt("return", response.json().then(function (responseJson) {
                return parseReadOnlyResponse(responseJson);
              }));

            case 21:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, null, [[11, 17]]);
    }));
    return _callReadOnlyFunction.apply(this, arguments);
  }

  function sponsorTransaction(_x24) {
    return _sponsorTransaction.apply(this, arguments);
  }

  function _sponsorTransaction() {
    _sponsorTransaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(sponsorOptions) {
      var _sponsorOptions$netwo;

      var defaultOptions, options, network$1, sponsorPubKey, txFee, addressVersion, senderAddress, sponsorNonce, sponsorSpendingCondition, privKey, signer;
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              defaultOptions = {
                fee: new BigNum__default['default'](0),
                sponsorNonce: new BigNum__default['default'](0),
                sponsorAddressHashmode: exports.AddressHashMode.SerializeP2PKH
              };
              options = Object.assign(defaultOptions, sponsorOptions);
              network$1 = (_sponsorOptions$netwo = sponsorOptions.network) != null ? _sponsorOptions$netwo : options.transaction.version === exports.TransactionVersion.Mainnet ? new network.StacksMainnet() : new network.StacksTestnet();
              sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);

              if (sponsorOptions.fee) {
                _context14.next = 24;
                break;
              }

              txFee = new BigNum__default['default'](0);
              _context14.t0 = options.transaction.payload.payloadType;
              _context14.next = _context14.t0 === exports.PayloadType.TokenTransfer ? 9 : _context14.t0 === exports.PayloadType.SmartContract ? 13 : _context14.t0 === exports.PayloadType.ContractCall ? 17 : 21;
              break;

            case 9:
              _context14.next = 11;
              return estimateTransfer(options.transaction, network$1);

            case 11:
              txFee = _context14.sent;
              return _context14.abrupt("break", 22);

            case 13:
              _context14.next = 15;
              return estimateContractDeploy(options.transaction, network$1);

            case 15:
              txFee = _context14.sent;
              return _context14.abrupt("break", 22);

            case 17:
              _context14.next = 19;
              return estimateContractFunctionCall(options.transaction, network$1);

            case 19:
              txFee = _context14.sent;
              return _context14.abrupt("break", 22);

            case 21:
              throw new Error("Sponsored transactions not supported for transaction type " + exports.PayloadType[options.transaction.payload.payloadType]);

            case 22:
              options.transaction.setFee(txFee);
              options.fee = txFee;

            case 24:
              if (sponsorOptions.sponsorNonce) {
                _context14.next = 31;
                break;
              }

              addressVersion = network$1.version === exports.TransactionVersion.Mainnet ? exports.AddressVersion.MainnetSingleSig : exports.AddressVersion.TestnetSingleSig;
              senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);
              _context14.next = 29;
              return getNonce(senderAddress, network$1);

            case 29:
              sponsorNonce = _context14.sent;
              options.sponsorNonce = sponsorNonce;

            case 31:
              sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);
              options.transaction.setSponsor(sponsorSpendingCondition);
              privKey = createStacksPrivateKey(options.sponsorPrivateKey);
              signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);
              signer.signSponsor(privKey);
              return _context14.abrupt("return", options.transaction);

            case 37:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    }));
    return _sponsorTransaction.apply(this, arguments);
  }

  Object.defineProperty(exports, 'randomBytes', {
    enumerable: true,
    get: function () {
      return randomBytes__default['default'];
    }
  });
  exports.Authorization = Authorization;
  exports.BufferArray = BufferArray;
  exports.BufferReader = BufferReader;
  exports.CLARITY_INT_SIZE = CLARITY_INT_SIZE;
  exports.COINBASE_BUFFER_LENGTH_BYTES = COINBASE_BUFFER_LENGTH_BYTES;
  exports.COMPRESSED_PUBKEY_LENGTH_BYTES = COMPRESSED_PUBKEY_LENGTH_BYTES;
  exports.DEFAULT_CHAIN_ID = DEFAULT_CHAIN_ID;
  exports.DEFAULT_CORE_NODE_API_URL = DEFAULT_CORE_NODE_API_URL;
  exports.DEFAULT_TRANSACTION_VERSION = DEFAULT_TRANSACTION_VERSION;
  exports.MAX_STRING_LENGTH_BYTES = MAX_STRING_LENGTH_BYTES;
  exports.MEMO_MAX_LENGTH_BYTES = MEMO_MAX_LENGTH_BYTES;
  exports.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
  exports.SponsoredAuthorization = SponsoredAuthorization;
  exports.StacksTransaction = StacksTransaction;
  exports.StandardAuthorization = StandardAuthorization;
  exports.TransactionSigner = TransactionSigner;
  exports.UNCOMPRESSED_PUBKEY_LENGTH_BYTES = UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
  exports.abiFunctionToString = abiFunctionToString;
  exports.addressFromHashMode = addressFromHashMode;
  exports.addressFromPublicKeys = addressFromPublicKeys;
  exports.addressFromVersionHash = addressFromVersionHash;
  exports.addressHashModeToVersion = addressHashModeToVersion;
  exports.addressToString = addressToString;
  exports.broadcastRawTransaction = broadcastRawTransaction;
  exports.broadcastTransaction = broadcastTransaction;
  exports.bufferCV = bufferCV;
  exports.bufferCVFromString = bufferCVFromString;
  exports.callReadOnlyFunction = callReadOnlyFunction;
  exports.cloneDeep = cloneDeep;
  exports.codeBodyString = codeBodyString;
  exports.compressPublicKey = compressPublicKey;
  exports.contractPrincipalCV = contractPrincipalCV;
  exports.contractPrincipalCVFromAddress = contractPrincipalCVFromAddress;
  exports.contractPrincipalCVFromStandard = contractPrincipalCVFromStandard;
  exports.createAddress = createAddress;
  exports.createAssetInfo = createAssetInfo;
  exports.createContractPrincipal = createContractPrincipal;
  exports.createEmptyAddress = createEmptyAddress;
  exports.createFungiblePostCondition = createFungiblePostCondition;
  exports.createLPList = createLPList;
  exports.createLPString = createLPString;
  exports.createMemoString = createMemoString;
  exports.createMessageSignature = createMessageSignature;
  exports.createMultiSigSpendingCondition = createMultiSigSpendingCondition;
  exports.createNonFungiblePostCondition = createNonFungiblePostCondition;
  exports.createSTXPostCondition = createSTXPostCondition;
  exports.createSingleSigSpendingCondition = createSingleSigSpendingCondition;
  exports.createStacksPrivateKey = createStacksPrivateKey;
  exports.createStacksPublicKey = createStacksPublicKey;
  exports.createStandardPrincipal = createStandardPrincipal;
  exports.createTransactionAuthField = createTransactionAuthField;
  exports.cvToHex = cvToHex;
  exports.cvToJSON = cvToJSON;
  exports.cvToString = cvToString;
  exports.cvToValue = cvToValue;
  exports.deserializeAddress = deserializeAddress;
  exports.deserializeAssetInfo = deserializeAssetInfo;
  exports.deserializeCV = deserializeCV;
  exports.deserializeLPList = deserializeLPList;
  exports.deserializeLPString = deserializeLPString;
  exports.deserializeMemoString = deserializeMemoString;
  exports.deserializeMessageSignature = deserializeMessageSignature;
  exports.deserializeMultiSigSpendingCondition = deserializeMultiSigSpendingCondition;
  exports.deserializePostCondition = deserializePostCondition;
  exports.deserializePrincipal = deserializePrincipal;
  exports.deserializePublicKey = deserializePublicKey;
  exports.deserializeSingleSigSpendingCondition = deserializeSingleSigSpendingCondition;
  exports.deserializeSpendingCondition = deserializeSpendingCondition;
  exports.deserializeStacksMessage = deserializeStacksMessage;
  exports.deserializeTransaction = deserializeTransaction;
  exports.deserializeTransactionAuthField = deserializeTransactionAuthField;
  exports.emptyMessageSignature = emptyMessageSignature;
  exports.encodeClarityValue = encodeClarityValue;
  exports.estimateContractDeploy = estimateContractDeploy;
  exports.estimateContractFunctionCall = estimateContractFunctionCall;
  exports.estimateTransfer = estimateTransfer;
  exports.exceedsMaxLengthBytes = exceedsMaxLengthBytes;
  exports.falseCV = falseCV;
  exports.fetchPrivate = fetchPrivate;
  exports.getAbi = getAbi;
  exports.getAddressFromPrivateKey = getAddressFromPrivateKey;
  exports.getAddressFromPublicKey = getAddressFromPublicKey;
  exports.getCVTypeString = getCVTypeString;
  exports.getNonce = getNonce;
  exports.getPublicKey = getPublicKey;
  exports.getSignatureRecoveryParam = getSignatureRecoveryParam;
  exports.getTypeString = getTypeString;
  exports.getTypeUnion = getTypeUnion;
  exports.hash160 = hash160;
  exports.hashP2PKH = hashP2PKH;
  exports.hashP2SH = hashP2SH;
  exports.hexStringToInt = hexStringToInt;
  exports.hexToCV = hexToCV;
  exports.intCV = intCV;
  exports.intToHexString = intToHexString;
  exports.isClarityAbiBuffer = isClarityAbiBuffer;
  exports.isClarityAbiList = isClarityAbiList;
  exports.isClarityAbiOptional = isClarityAbiOptional;
  exports.isClarityAbiPrimitive = isClarityAbiPrimitive;
  exports.isClarityAbiResponse = isClarityAbiResponse;
  exports.isClarityAbiStringAscii = isClarityAbiStringAscii;
  exports.isClarityAbiStringUtf8 = isClarityAbiStringUtf8;
  exports.isClarityAbiTuple = isClarityAbiTuple;
  exports.isClarityName = isClarityName;
  exports.isCompressed = isCompressed;
  exports.isSingleSig = isSingleSig;
  exports.leftPadHex = leftPadHex;
  exports.leftPadHexToLength = leftPadHexToLength;
  exports.listCV = listCV;
  exports.makeContractCall = makeContractCall;
  exports.makeContractDeploy = makeContractDeploy;
  exports.makeContractFungiblePostCondition = makeContractFungiblePostCondition;
  exports.makeContractNonFungiblePostCondition = makeContractNonFungiblePostCondition;
  exports.makeContractSTXPostCondition = makeContractSTXPostCondition;
  exports.makeRandomPrivKey = makeRandomPrivKey;
  exports.makeSTXTokenTransfer = makeSTXTokenTransfer;
  exports.makeSigHashPreSign = makeSigHashPreSign;
  exports.makeStandardFungiblePostCondition = makeStandardFungiblePostCondition;
  exports.makeStandardNonFungiblePostCondition = makeStandardNonFungiblePostCondition;
  exports.makeStandardSTXPostCondition = makeStandardSTXPostCondition;
  exports.makeUnsignedContractCall = makeUnsignedContractCall;
  exports.makeUnsignedSTXTokenTransfer = makeUnsignedSTXTokenTransfer;
  exports.nextSignature = nextSignature;
  exports.nextVerification = nextVerification;
  exports.noneCV = noneCV;
  exports.omit = omit;
  exports.parseAssetInfoString = parseAssetInfoString;
  exports.parsePrincipalString = parsePrincipalString;
  exports.parseReadOnlyResponse = parseReadOnlyResponse;
  exports.parseRecoverableSignature = parseRecoverableSignature;
  exports.parseToCV = parseToCV;
  exports.privateKeyToString = privateKeyToString;
  exports.pubKeyfromPrivKey = pubKeyfromPrivKey;
  exports.publicKeyFromBuffer = publicKeyFromBuffer;
  exports.publicKeyFromSignature = publicKeyFromSignature;
  exports.publicKeyToAddress = publicKeyToAddress;
  exports.publicKeyToString = publicKeyToString;
  exports.responseErrorCV = responseErrorCV;
  exports.responseOkCV = responseOkCV;
  exports.rightPadHexToLength = rightPadHexToLength;
  exports.serializeAddress = serializeAddress;
  exports.serializeAssetInfo = serializeAssetInfo;
  exports.serializeCV = serializeCV;
  exports.serializeLPList = serializeLPList;
  exports.serializeLPString = serializeLPString;
  exports.serializeMemoString = serializeMemoString;
  exports.serializeMessageSignature = serializeMessageSignature;
  exports.serializeMultiSigSpendingCondition = serializeMultiSigSpendingCondition;
  exports.serializePostCondition = serializePostCondition;
  exports.serializePrincipal = serializePrincipal;
  exports.serializePublicKey = serializePublicKey;
  exports.serializeSingleSigSpendingCondition = serializeSingleSigSpendingCondition;
  exports.serializeSpendingCondition = serializeSpendingCondition;
  exports.serializeStacksMessage = serializeStacksMessage;
  exports.serializeTransactionAuthField = serializeTransactionAuthField;
  exports.sha512_256 = sha512_256;
  exports.signWithKey = signWithKey;
  exports.someCV = someCV;
  exports.sponsorTransaction = sponsorTransaction;
  exports.standardPrincipalCV = standardPrincipalCV;
  exports.standardPrincipalCVFromAddress = standardPrincipalCVFromAddress;
  exports.stringAsciiCV = stringAsciiCV;
  exports.stringUtf8CV = stringUtf8CV;
  exports.trueCV = trueCV;
  exports.tupleCV = tupleCV;
  exports.txidFromData = txidFromData;
  exports.uintCV = uintCV;
  exports.validateContractCall = validateContractCall;
  exports.validateStacksAddress = validateStacksAddress;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=transactions.umd.development.js.map
