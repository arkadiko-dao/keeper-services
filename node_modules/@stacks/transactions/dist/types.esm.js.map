{"version":3,"file":"types.esm.js","sources":["../src/types.ts"],"sourcesContent":["import {\n  MAX_STRING_LENGTH_BYTES,\n  MEMO_MAX_LENGTH_BYTES,\n  AddressHashMode,\n  AddressVersion,\n  TransactionVersion,\n  StacksMessageType,\n  PostConditionPrincipalID,\n} from './constants';\n\nimport { StacksPublicKey, serializePublicKey, deserializePublicKey, isCompressed } from './keys';\n\nimport {\n  BufferArray,\n  intToHexString,\n  hexStringToInt,\n  exceedsMaxLengthBytes,\n  hashP2PKH,\n  rightPadHexToLength,\n  hashP2SH,\n} from './utils';\n\nimport { c32addressDecode, c32address } from 'c32check';\nimport { BufferReader } from './bufferReader';\nimport { PostCondition, serializePostCondition, deserializePostCondition } from './postcondition';\nimport { Payload, deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport {\n  deserializeTransactionAuthField,\n  deserializeMessageSignature,\n  MessageSignature,\n  serializeMessageSignature,\n  serializeTransactionAuthField,\n  TransactionAuthField,\n} from './authorization';\n\nexport type StacksMessage =\n  | Address\n  | PostConditionPrincipal\n  | LengthPrefixedString\n  | LengthPrefixedList\n  | Payload\n  | MemoString\n  | AssetInfo\n  | PostCondition\n  | StacksPublicKey\n  | TransactionAuthField\n  | MessageSignature;\n\nexport function serializeStacksMessage(message: StacksMessage): Buffer {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\n\nexport function deserializeStacksMessage(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  listType?: StacksMessageType\n): StacksMessage {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bufferReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bufferReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bufferReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bufferReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bufferReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bufferReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bufferReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bufferReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bufferReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bufferReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\n\nexport interface Address {\n  readonly type: StacksMessageType.Address;\n  readonly version: AddressVersion;\n  readonly hash160: string;\n}\n\nexport function createAddress(c32AddressString: string): Address {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1],\n  };\n}\n\nexport function createEmptyAddress(): Address {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40),\n  };\n}\n\nexport function addressFromVersionHash(version: AddressVersion, hash: string): Address {\n  return { type: StacksMessageType.Address, version, hash160: hash };\n}\n\n/**\n * Translates the tx auth hash mode to the corresponding address version.\n * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization\n */\nexport function addressHashModeToVersion(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion\n): AddressVersion {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\n\nexport function addressFromHashMode(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion,\n  data: string\n): Address {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\n\nexport function addressFromPublicKeys(\n  version: AddressVersion,\n  hashMode: AddressHashMode,\n  numSigs: number,\n  publicKeys: StacksPublicKey[]\n): Address {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    default:\n      throw Error(\n        `Not yet implemented: address construction using public keys for hash mode: ${hashMode}`\n      );\n  }\n}\n\nexport function addressToString(address: Address): string {\n  return c32address(address.version, address.hash160).toString();\n}\n\nexport function serializeAddress(address: Address): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(address.version, 1));\n  bufferArray.appendHexString(address.hash160);\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAddress(bufferReader: BufferReader): Address {\n  const version = hexStringToInt(bufferReader.readBuffer(1).toString('hex'));\n  const data = bufferReader.readBuffer(20).toString('hex');\n\n  return { type: StacksMessageType.Address, version, hash160: data };\n}\n\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\n\nexport interface StandardPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Standard;\n  readonly address: Address;\n}\n\nexport interface ContractPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Contract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\n/**\n * Parses a principal string for either a standard principal or contract principal.\n * @param principalString - String in the format `{address}.{contractName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\n */\nexport function parsePrincipalString(\n  principalString: string\n): StandardPrincipal | ContractPrincipal {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\n\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr,\n  };\n}\n\nexport function createContractPrincipal(\n  addressString: string,\n  contractName: string\n): ContractPrincipal {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name,\n  };\n}\n\nexport function serializePrincipal(principal: PostConditionPrincipal): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(Buffer.from([principal.prefix]));\n  bufferArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bufferArray.push(serializeLPString(principal.contractName));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal {\n  const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n    throw new DeserializationError('Unexpected Principal payload type: ${n}');\n  });\n  const address = deserializeAddress(bufferReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return { type: StacksMessageType.Principal, prefix, address } as StandardPrincipal;\n  }\n  const contractName = deserializeLPString(bufferReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName,\n  } as ContractPrincipal;\n}\n\nexport interface LengthPrefixedString {\n  readonly type: StacksMessageType.LengthPrefixedString;\n  readonly content: string;\n  readonly lengthPrefixBytes: number;\n  readonly maxLengthBytes: number;\n}\n\nexport function createLPString(content: string): LengthPrefixedString;\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes: number,\n  maxLengthBytes: number\n): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes?: number,\n  maxLengthBytes?: number\n): LengthPrefixedString {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength,\n  };\n}\n\nexport function serializeLPString(lps: LengthPrefixedString) {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(lps.content);\n  const length = contentBuffer.byteLength;\n  bufferArray.appendHexString(intToHexString(length, lps.lengthPrefixBytes));\n  bufferArray.push(contentBuffer);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPString(\n  bufferReader: BufferReader,\n  prefixBytes?: number,\n  maxLength?: number\n): LengthPrefixedString {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n  const content = bufferReader.readBuffer(length).toString();\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\n\nexport function codeBodyString(content: string): LengthPrefixedString {\n  return createLPString(content, 4, 100000);\n}\n\nexport interface MemoString {\n  readonly type: StacksMessageType.MemoString;\n  readonly content: string;\n}\n\nexport function createMemoString(content: string): MemoString {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n  }\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeMemoString(memoString: MemoString): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(memoString.content);\n  const paddedContent = rightPadHexToLength(\n    contentBuffer.toString('hex'),\n    MEMO_MAX_LENGTH_BYTES * 2\n  );\n  bufferArray.push(Buffer.from(paddedContent, 'hex'));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMemoString(bufferReader: BufferReader): MemoString {\n  const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport interface AssetInfo {\n  readonly type: StacksMessageType.AssetInfo;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly assetName: LengthPrefixedString;\n}\n\n/**\n * Parse a fully qualified string that identifies the token type.\n * @param id - String in the format `{address}.{contractName}::{assetName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract::example-token\"\n */\nexport function parseAssetInfoString(id: string): AssetInfo {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\n\nexport function createAssetInfo(\n  addressString: string,\n  contractName: string,\n  assetName: string\n): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName),\n  };\n}\n\nexport function serializeAssetInfo(info: AssetInfo): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(serializeAddress(info.address));\n  bufferArray.push(serializeLPString(info.contractName));\n  bufferArray.push(serializeLPString(info.assetName));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bufferReader),\n    contractName: deserializeLPString(bufferReader),\n    assetName: deserializeLPString(bufferReader),\n  };\n}\n\nexport interface LengthPrefixedList {\n  readonly type: StacksMessageType.LengthPrefixedList;\n  readonly lengthPrefixBytes: number;\n  readonly values: StacksMessage[];\n}\n\nexport function createLPList<T extends StacksMessage>(\n  values: T[],\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values,\n  };\n}\n\nexport function serializeLPList(lpList: LengthPrefixedList): Buffer {\n  const list = lpList.values;\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(list.length, lpList.lengthPrefixBytes));\n  for (let index = 0; index < list.length; index++) {\n    bufferArray.push(serializeStacksMessage(list[index]));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPList(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  const length = hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n  const l: StacksMessage[] = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bufferReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bufferReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bufferReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bufferReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bufferReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bufferReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bufferReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\n"],"names":["serializeStacksMessage","message","type","StacksMessageType","Address","serializeAddress","Principal","serializePrincipal","LengthPrefixedString","serializeLPString","MemoString","serializeMemoString","AssetInfo","serializeAssetInfo","PostCondition","serializePostCondition","PublicKey","serializePublicKey","LengthPrefixedList","serializeLPList","Payload","serializePayload","TransactionAuthField","serializeTransactionAuthField","MessageSignature","serializeMessageSignature","deserializeStacksMessage","bufferReader","listType","deserializeAddress","deserializePrincipal","deserializeLPString","deserializeMemoString","deserializeAssetInfo","deserializePostCondition","deserializePublicKey","deserializePayload","DeserializationError","deserializeLPList","deserializeMessageSignature","Error","createAddress","c32AddressString","addressData","c32addressDecode","version","hash160","createEmptyAddress","AddressVersion","MainnetSingleSig","repeat","addressFromVersionHash","hash","addressHashModeToVersion","hashMode","txVersion","AddressHashMode","SerializeP2PKH","TransactionVersion","Mainnet","Testnet","TestnetSingleSig","JSON","stringify","SerializeP2SH","SerializeP2WPKH","SerializeP2WSH","MainnetMultiSig","TestnetMultiSig","addressFromHashMode","data","addressFromPublicKeys","numSigs","publicKeys","length","i","isCompressed","hashP2PKH","hashP2SH","map","addressToString","address","c32address","toString","bufferArray","BufferArray","appendHexString","intToHexString","concatBuffer","hexStringToInt","readBuffer","parsePrincipalString","principalString","includes","split","contractName","createContractPrincipal","createStandardPrincipal","addressString","addr","prefix","PostConditionPrincipalID","Standard","name","createLPString","Contract","principal","push","Buffer","from","readUInt8Enum","_","content","lengthPrefixBytes","maxLengthBytes","prefixLength","maxLength","MAX_STRING_LENGTH_BYTES","exceedsMaxLengthBytes","lps","contentBuffer","byteLength","prefixBytes","codeBodyString","createMemoString","MEMO_MAX_LENGTH_BYTES","memoString","paddedContent","rightPadHexToLength","parseAssetInfoString","id","assetAddress","assetContractName","assetTokenName","assetInfo","createAssetInfo","assetName","info","createLPList","values","lpList","list","index","l","deserializeTransactionAuthField"],"mappings":"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"}