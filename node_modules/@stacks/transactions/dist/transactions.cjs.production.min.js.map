{"version":3,"file":"transactions.cjs.production.min.js","sources":["../src/constants.ts","../../../node_modules/regenerator-runtime/runtime.js","../src/keys.ts","../src/clarity/clarityValue.ts","../src/errors.ts","../src/postcondition.ts","../src/payload.ts","../src/clarity/types/principalCV.ts","../src/types.ts","../src/clarity/types/booleanCV.ts","../src/clarity/types/intCV.ts","../src/clarity/types/bufferCV.ts","../src/clarity/types/optionalCV.ts","../src/clarity/types/responseCV.ts","../src/clarity/types/listCV.ts","../src/clarity/types/tupleCV.ts","../src/clarity/types/stringCV.ts","../src/clarity/serialize.ts","../src/bufferReader.ts","../src/clarity/deserialize.ts","../src/utils.ts","../src/authorization.ts","../src/contract-abi.ts","../src/transaction.ts","../src/signer.ts","../src/builders.ts"],"sourcesContent":["/**\n * Unsigned 32-bit integer\n */\nenum ChainID {\n  Testnet = 0x80000000,\n  Mainnet = 0x00000001,\n}\n\nconst DEFAULT_CHAIN_ID = ChainID.Mainnet;\nconst MAX_STRING_LENGTH_BYTES = 128;\nconst CLARITY_INT_SIZE = 128;\nconst COINBASE_BUFFER_LENGTH_BYTES = 32;\nconst RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;\nconst COMPRESSED_PUBKEY_LENGTH_BYTES = 32;\nconst UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;\nconst MEMO_MAX_LENGTH_BYTES = 34;\nconst DEFAULT_CORE_NODE_API_URL = 'https://stacks-node-api.mainnet.stacks.co';\n\nenum StacksMessageType {\n  Address,\n  Principal,\n  LengthPrefixedString,\n  MemoString,\n  AssetInfo,\n  PostCondition,\n  PublicKey,\n  LengthPrefixedList,\n  Payload,\n  MessageSignature,\n  TransactionAuthField,\n}\n\nenum PayloadType {\n  TokenTransfer = 0x00,\n  SmartContract = 0x01,\n  ContractCall = 0x02,\n  PoisonMicroblock = 0x03,\n  Coinbase = 0x04,\n}\n\nenum AnchorMode {\n  OnChainOnly = 0x01,\n  OffChainOnly = 0x02,\n  Any = 0x03,\n}\n\nenum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\nconst DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\n\nenum PostConditionMode {\n  Allow = 0x01,\n  Deny = 0x02,\n}\n\nenum PostConditionType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum AuthType {\n  Standard = 0x04,\n  Sponsored = 0x05,\n}\n\nenum AddressHashMode {\n  // serialization modes for public keys to addresses.\n  // We support four different modes due to legacy compatibility with Stacks v1 addresses:\n  /** SingleSigHashMode - hash160(public-key), same as bitcoin's p2pkh */\n  SerializeP2PKH = 0x00,\n  /** MultiSigHashMode - hash160(multisig-redeem-script), same as bitcoin's multisig p2sh */\n  SerializeP2SH = 0x01,\n  /** SingleSigHashMode - hash160(segwit-program-00(p2pkh)), same as bitcoin's p2sh-p2wpkh */\n  SerializeP2WPKH = 0x02,\n  /** MultiSigHashMode - hash160(segwit-program-00(public-keys)), same as bitcoin's p2sh-p2wsh */\n  SerializeP2WSH = 0x03,\n}\n\ntype SingleSigHashMode = AddressHashMode.SerializeP2PKH | AddressHashMode.SerializeP2WPKH;\ntype MultiSigHashMode = AddressHashMode.SerializeP2SH | AddressHashMode.SerializeP2WSH;\n\nenum AddressVersion {\n  MainnetSingleSig = 22,\n  MainnetMultiSig = 20,\n  TestnetSingleSig = 26,\n  TestnetMultiSig = 21,\n}\n\nenum PubKeyEncoding {\n  Compressed = 0x00,\n  Uncompressed = 0x01,\n}\n\nenum FungibleConditionCode {\n  Equal = 0x01,\n  Greater = 0x02,\n  GreaterEqual = 0x03,\n  Less = 0x04,\n  LessEqual = 0x05,\n}\n\nenum NonFungibleConditionCode {\n  DoesNotOwn = 0x10,\n  Owns = 0x11,\n}\n\nenum PostConditionPrincipalID {\n  Origin = 0x01,\n  Standard = 0x02,\n  Contract = 0x03,\n}\n\nenum AssetType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum TxRejectedReason {\n  Serialization = 'Serialization',\n  Deserialization = 'Deserialization',\n  SignatureValidation = 'SignatureValidation',\n  FeeTooLow = 'FeeTooLow',\n  BadNonce = 'BadNonce',\n  NotEnoughFunds = 'NotEnoughFunds',\n  NoSuchContract = 'NoSuchContract',\n  NoSuchPublicFunction = 'NoSuchPublicFunction',\n  BadFunctionArgument = 'BadFunctionArgument',\n  ContractAlreadyExists = 'ContractAlreadyExists',\n  PoisonMicroblocksDoNotConflict = 'PoisonMicroblocksDoNotConflict',\n  PoisonMicroblockHasUnknownPubKeyHash = 'PoisonMicroblockHasUnknownPubKeyHash',\n  PoisonMicroblockIsInvalid = 'PoisonMicroblockIsInvalid',\n  BadAddressVersionByte = 'BadAddressVersionByte',\n  NoCoinbaseViaMempool = 'NoCoinbaseViaMempool',\n  ServerFailureNoSuchChainTip = 'ServerFailureNoSuchChainTip',\n  ServerFailureDatabase = 'ServerFailureDatabase',\n  ServerFailureOther = 'ServerFailureOther',\n}\n\nexport {\n  MAX_STRING_LENGTH_BYTES,\n  CLARITY_INT_SIZE,\n  COINBASE_BUFFER_LENGTH_BYTES,\n  DEFAULT_CHAIN_ID,\n  DEFAULT_TRANSACTION_VERSION,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n  MEMO_MAX_LENGTH_BYTES,\n  DEFAULT_CORE_NODE_API_URL,\n  ChainID,\n  StacksMessageType,\n  PayloadType,\n  AnchorMode,\n  TransactionVersion,\n  PostConditionMode,\n  PostConditionType,\n  PostConditionPrincipalID,\n  AuthType,\n  AddressHashMode,\n  SingleSigHashMode,\n  MultiSigHashMode,\n  AddressVersion,\n  PubKeyEncoding,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  AssetType,\n  TxRejectedReason,\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import {\n  AddressHashMode,\n  AddressVersion,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n  StacksMessageType,\n  TransactionVersion,\n  PubKeyEncoding,\n} from './constants';\n\nimport {\n  BufferArray,\n  hash160,\n  hashP2PKH,\n  hexStringToInt,\n  intToHexString,\n  leftPadHexToLength,\n  randomBytes,\n} from './utils';\n\nimport { ec as EC } from 'elliptic';\n\nimport { MessageSignature, createMessageSignature } from './authorization';\nimport { BufferReader } from './bufferReader';\nimport { c32address } from 'c32check';\nimport { addressHashModeToVersion, addressFromVersionHash, addressToString } from './types';\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Buffer;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key buffer or hex string */\n  privateKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key buffer or hex string */\n  publicKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: Buffer.from(key, 'hex'),\n  };\n}\n\nexport function publicKeyFromSignature(\n  message: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n) {\n  const ec = new EC('secp256k1');\n  const messageBN = ec.keyFromPrivate(message, 'hex').getPrivate().toString(10);\n\n  const parsedSignature = parseRecoverableSignature(messageSignature.data);\n\n  const publicKey = ec.recoverPubKey(\n    messageBN,\n    parsedSignature,\n    parsedSignature.recoveryParam,\n    'hex'\n  );\n\n  if (pubKeyEncoding == PubKeyEncoding.Uncompressed) {\n    return publicKey.encode('hex');\n  }\n\n  return publicKey.encodeCompressed('hex');\n}\n\nexport function publicKeyFromBuffer(data: Buffer): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !key.data.toString('hex').startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return key.data.toString('hex');\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(key.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Buffer): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const ec = new EC('secp256k1');\n  const keyPair = ec.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');\n  const pubKey = keyPair.getPublic(privKey.compressed, 'hex');\n  return createStacksPublicKey(pubKey);\n}\n\nexport function compressPublicKey(publicKey: string | Buffer): StacksPublicKey {\n  const ec = new EC('secp256k1');\n  const key = ec.keyFromPublic(publicKey);\n  const pubKey = key.getPublic(true, 'hex');\n  return createStacksPublicKey(pubKey);\n}\n\nexport function deserializePublicKey(bufferReader: BufferReader): StacksPublicKey {\n  const fieldId = bufferReader.readUInt8();\n  const keyLength =\n    fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBuffer(\n    Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)])\n  );\n}\n\nexport interface StacksPrivateKey {\n  data: Buffer;\n  compressed: boolean;\n}\n\nexport function createStacksPrivateKey(key: string | Buffer): StacksPrivateKey {\n  const data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;\n  let compressed: boolean;\n  if (data.length === 33) {\n    if (data[data.length - 1] !== 1) {\n      throw new Error(\n        'Improperly formatted private-key. 33 byte length usually ' +\n          'indicates compressed key, but last byte must be == 0x01'\n      );\n    }\n    compressed = true;\n  } else if (data.length === 32) {\n    compressed = false;\n  } else {\n    throw new Error(\n      `Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${data.length}`\n    );\n  }\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(entropy?: Buffer): StacksPrivateKey {\n  const ec = new EC('secp256k1');\n  const options = { entropy: entropy || randomBytes(32) };\n  const keyPair = ec.genKeyPair(options);\n  const privateKey = keyPair.getPrivate().toString('hex', 32);\n  return createStacksPrivateKey(privateKey);\n}\n\nexport function signWithKey(privateKey: StacksPrivateKey, input: string): MessageSignature {\n  const ec = new EC('secp256k1');\n  const key = ec.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');\n  const signature = key.sign(input, 'hex', { canonical: true });\n  const coordinateValueBytes = 32;\n  const r = leftPadHexToLength(signature.r.toString('hex'), coordinateValueBytes * 2);\n  const s = leftPadHexToLength(signature.s.toString('hex'), coordinateValueBytes * 2);\n  if (signature.recoveryParam === undefined || signature.recoveryParam === null) {\n    throw new Error('\"signature.recoveryParam\" is not set');\n  }\n  const recoveryParam = intToHexString(signature.recoveryParam, 1);\n  const recoverableSignatureString = recoveryParam + r + s;\n  return createMessageSignature(recoverableSignatureString);\n}\n\nexport function getSignatureRecoveryParam(signature: string) {\n  const coordinateValueBytes = 32;\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n  const recoveryParamHex = signature.substr(0, 2);\n  return hexStringToInt(recoveryParamHex);\n}\n\nexport function parseRecoverableSignature(signature: string) {\n  const coordinateValueBytes = 32;\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n  const recoveryParamHex = signature.substr(0, 2);\n  const r = signature.substr(2, coordinateValueBytes * 2);\n  const s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);\n  return {\n    recoveryParam: hexStringToInt(recoveryParamHex),\n    r,\n    s,\n  };\n}\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return privateKey.data.toString('hex');\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, hash160(publicKey.data).toString('hex'));\n}\n","import {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseErrorCV,\n  ResponseOkCV,\n  ListCV,\n  TupleCV,\n  StringAsciiCV,\n  StringUtf8CV,\n} from '.';\n\nimport { principalToString } from './types/principalCV';\nimport { CLARITY_INT_SIZE } from '../constants';\n\n/**\n * Type IDs corresponding to each of the Clarity value types as described here:\n * {@link https://github.com/blockstack/blockstack-core/blob/sip/sip-005/sip/sip-005-blocks-and-transactions.md#clarity-value-representation}\n */\nexport enum ClarityType {\n  Int = 0x00,\n  UInt = 0x01,\n  Buffer = 0x02,\n  BoolTrue = 0x03,\n  BoolFalse = 0x04,\n  PrincipalStandard = 0x05,\n  PrincipalContract = 0x06,\n  ResponseOk = 0x07,\n  ResponseErr = 0x08,\n  OptionalNone = 0x09,\n  OptionalSome = 0x0a,\n  List = 0x0b,\n  Tuple = 0x0c,\n  StringASCII = 0x0d,\n  StringUTF8 = 0x0e,\n}\n\nexport type ClarityValue =\n  | BooleanCV\n  | OptionalCV\n  | BufferCV\n  | IntCV\n  | UIntCV\n  | StandardPrincipalCV\n  | ContractPrincipalCV\n  | ResponseErrorCV\n  | ResponseOkCV\n  | ListCV\n  | TupleCV\n  | StringAsciiCV\n  | StringUtf8CV;\n\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.fromTwos(CLARITY_INT_SIZE).toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = val.buffer.toString('ascii');\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\n\nexport function cvToValue(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n      return val.value.fromTwos(CLARITY_INT_SIZE).toNumber();\n    case ClarityType.UInt:\n      return val.value.toNumber();\n    case ClarityType.Buffer:\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result: { [key: string]: any } = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\n\nexport function cvToJSON(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return { type: getCVTypeString(val), value: cvToValue(val), success: false };\n    case ClarityType.ResponseOk:\n      return { type: getCVTypeString(val), value: cvToValue(val), success: true };\n    default:\n      return { type: getCVTypeString(val), value: cvToValue(val) };\n  }\n}\n\nexport function getCVTypeString(val: ClarityValue): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${getCVTypeString(val.list[0])})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${Buffer.from(val.data, 'ascii').length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${Buffer.from(val.data, 'utf8').length})`;\n  }\n}\n","export class StacksTransactionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SerializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class DeserializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class NotImplementedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SigningError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\nexport class VerificationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n","import {\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  StacksMessageType,\n} from './constants';\n\nimport { BufferArray } from './utils';\n\nimport {\n  AssetInfo,\n  serializeAssetInfo,\n  deserializeAssetInfo,\n  PostConditionPrincipal,\n  serializePrincipal,\n  deserializePrincipal,\n  parseAssetInfoString,\n  parsePrincipalString,\n} from './types';\n\nimport BigNum from 'bn.js';\nimport { BufferReader } from './bufferReader';\nimport { ClarityValue, serializeCV, deserializeCV } from './clarity';\nimport { DeserializationError } from './errors';\n\nexport type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;\n\nexport interface STXPostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.STX;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: BigNum;\n}\n\nexport function createSTXPostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum\n): STXPostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.STX,\n    principal,\n    conditionCode,\n    amount,\n  };\n}\n\nexport interface FungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.Fungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: BigNum;\n  readonly assetInfo: AssetInfo;\n}\n\nexport function createFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.Fungible,\n    principal,\n    conditionCode,\n    amount,\n    assetInfo,\n  };\n}\n\nexport interface NonFungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.NonFungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: NonFungibleConditionCode;\n  /** Structure that identifies the token type. */\n  readonly assetInfo: AssetInfo;\n  /** The Clarity value that names the token instance. */\n  readonly assetName: ClarityValue;\n}\n\nexport function createNonFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.NonFungible,\n    principal,\n    conditionCode,\n    assetInfo,\n    assetName,\n  };\n}\n\nexport function serializePostCondition(postCondition: PostCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(postCondition.conditionType);\n  bufferArray.push(serializePrincipal(postCondition.principal));\n\n  if (\n    postCondition.conditionType === PostConditionType.Fungible ||\n    postCondition.conditionType === PostConditionType.NonFungible\n  ) {\n    bufferArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bufferArray.push(serializeCV(postCondition.assetName));\n  }\n\n  bufferArray.appendByte(postCondition.conditionCode);\n\n  if (\n    postCondition.conditionType === PostConditionType.STX ||\n    postCondition.conditionType === PostConditionType.Fungible\n  ) {\n    bufferArray.push(postCondition.amount.toArrayLike(Buffer, 'be', 8));\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePostCondition(bufferReader: BufferReader): PostCondition {\n  const postConditionType = bufferReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n\n  const principal = deserializePrincipal(bufferReader);\n\n  let conditionCode;\n  let assetInfo;\n  let amount;\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount,\n      };\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo,\n      };\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      const assetName = deserializeCV(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName,\n      };\n  }\n}\n","import { COINBASE_BUFFER_LENGTH_BYTES, PayloadType, StacksMessageType } from './constants';\n\nimport { BufferArray } from './utils';\n\nimport {\n  Address,\n  MemoString,\n  createAddress,\n  createMemoString,\n  LengthPrefixedString,\n  createLPString,\n  serializeStacksMessage,\n  deserializeAddress,\n  deserializeLPString,\n  deserializeMemoString,\n  codeBodyString,\n} from './types';\n\nimport { ClarityValue, serializeCV, deserializeCV } from './clarity/';\n\nimport BigNum from 'bn.js';\nimport { BufferReader } from './bufferReader';\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\n\nexport type Payload =\n  | TokenTransferPayload\n  | ContractCallPayload\n  | SmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload;\n\nexport interface TokenTransferPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TokenTransfer;\n  readonly recipient: PrincipalCV;\n  readonly amount: BigNum;\n  readonly memo: MemoString;\n}\n\nexport function createTokenTransferPayload(\n  recipient: string | PrincipalCV,\n  amount: BigNum,\n  memo?: string | MemoString\n): TokenTransferPayload {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount,\n    memo: memo ?? createMemoString(''),\n  };\n}\n\nexport interface ContractCallPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.ContractCall;\n  readonly contractAddress: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly functionName: LengthPrefixedString;\n  readonly functionArgs: ClarityValue[];\n}\n\nexport function createContractCallPayload(\n  contractAddress: string | Address,\n  contractName: string | LengthPrefixedString,\n  functionName: string | LengthPrefixedString,\n  functionArgs: ClarityValue[]\n): ContractCallPayload {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs,\n  };\n}\n\nexport interface SmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.SmartContract;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport function createSmartContractPayload(\n  contractName: string | LengthPrefixedString,\n  codeBody: string | LengthPrefixedString\n): SmartContractPayload {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody,\n  };\n}\n\nexport interface PoisonPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.PoisonMicroblock;\n}\n\nexport function createPoisonPayload(): PoisonPayload {\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\n\nexport interface CoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.Coinbase;\n  readonly coinbaseBuffer: Buffer;\n}\n\nexport function createCoinbasePayload(coinbaseBuffer: Buffer): CoinbasePayload {\n  if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);\n  }\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.Coinbase, coinbaseBuffer };\n}\n\nexport function serializePayload(payload: Payload): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bufferArray.push(serializeCV(payload.recipient));\n      bufferArray.push(payload.amount.toArrayLike(Buffer, 'be', 8));\n      bufferArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bufferArray.push(serializeStacksMessage(payload.contractAddress));\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = Buffer.alloc(4);\n      numArgs.writeUInt32BE(payload.functionArgs.length, 0);\n      bufferArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bufferArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      break;\n    case PayloadType.Coinbase:\n      bufferArray.push(payload.coinbaseBuffer);\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePayload(bufferReader: BufferReader): Payload {\n  const payloadType = bufferReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bufferReader) as PrincipalCV;\n      const amount = new BigNum(bufferReader.readBuffer(8));\n      const memo = deserializeMemoString(bufferReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bufferReader);\n      const contractCallName = deserializeLPString(bufferReader);\n      const functionName = deserializeLPString(bufferReader);\n      const functionArgs = [];\n      const numberOfArgs = bufferReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bufferReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(\n        contractAddress,\n        contractCallName,\n        functionName,\n        functionArgs\n      );\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bufferReader);\n      const codeBody = deserializeLPString(bufferReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);\n      return createCoinbasePayload(coinbaseBuffer);\n  }\n}\n","import {\n  Address,\n  LengthPrefixedString,\n  createAddress,\n  createLPString,\n  addressToString,\n} from '../../types';\nimport { ClarityType } from '../clarityValue';\n\ntype PrincipalCV = StandardPrincipalCV | ContractPrincipalCV;\n\ninterface StandardPrincipalCV {\n  readonly type: ClarityType.PrincipalStandard;\n  readonly address: Address;\n}\n\ninterface ContractPrincipalCV {\n  readonly type: ClarityType.PrincipalContract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nfunction principalToString(principal: PrincipalCV): string {\n  if (principal.type === ClarityType.PrincipalStandard) {\n    return addressToString(principal.address);\n  } else if (principal.type === ClarityType.PrincipalContract) {\n    const address = addressToString(principal.address);\n    return `${address}.${principal.contractName.content}`;\n  } else {\n    throw new Error(`Unexpected principal data: ${JSON.stringify(principal)}`);\n  }\n}\n\nfunction principalCV(principal: string): PrincipalCV {\n  if (principal.includes('.')) {\n    const [address, contractName] = principal.split('.');\n    return contractPrincipalCV(address, contractName);\n  } else {\n    return standardPrincipalCV(principal);\n  }\n}\n\nfunction standardPrincipalCV(addressString: string): StandardPrincipalCV {\n  const addr = createAddress(addressString);\n  return { type: ClarityType.PrincipalStandard, address: addr };\n}\n\nfunction standardPrincipalCVFromAddress(address: Address): StandardPrincipalCV {\n  return { type: ClarityType.PrincipalStandard, address };\n}\n\nfunction contractPrincipalCV(addressString: string, contractName: string): ContractPrincipalCV {\n  const addr = createAddress(addressString);\n  const lengthPrefixedContractName = createLPString(contractName);\n  return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);\n}\n\nfunction contractPrincipalCVFromAddress(\n  address: Address,\n  contractName: LengthPrefixedString\n): ContractPrincipalCV {\n  if (Buffer.byteLength(contractName.content) >= 128) {\n    throw new Error('Contract name must be less than 128 bytes');\n  }\n  return { type: ClarityType.PrincipalContract, address, contractName };\n}\n\nfunction contractPrincipalCVFromStandard(\n  sp: StandardPrincipalCV,\n  contractName: string\n): ContractPrincipalCV {\n  const lengthPrefixedContractName = createLPString(contractName);\n  return {\n    type: ClarityType.PrincipalContract,\n    address: sp.address,\n    contractName: lengthPrefixedContractName,\n  };\n}\n\nexport {\n  PrincipalCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  principalCV,\n  principalToString,\n  standardPrincipalCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCV,\n  contractPrincipalCVFromAddress,\n  contractPrincipalCVFromStandard,\n};\n","import {\n  MAX_STRING_LENGTH_BYTES,\n  MEMO_MAX_LENGTH_BYTES,\n  AddressHashMode,\n  AddressVersion,\n  TransactionVersion,\n  StacksMessageType,\n  PostConditionPrincipalID,\n} from './constants';\n\nimport { StacksPublicKey, serializePublicKey, deserializePublicKey, isCompressed } from './keys';\n\nimport {\n  BufferArray,\n  intToHexString,\n  hexStringToInt,\n  exceedsMaxLengthBytes,\n  hashP2PKH,\n  rightPadHexToLength,\n  hashP2SH,\n} from './utils';\n\nimport { c32addressDecode, c32address } from 'c32check';\nimport { BufferReader } from './bufferReader';\nimport { PostCondition, serializePostCondition, deserializePostCondition } from './postcondition';\nimport { Payload, deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport {\n  deserializeTransactionAuthField,\n  deserializeMessageSignature,\n  MessageSignature,\n  serializeMessageSignature,\n  serializeTransactionAuthField,\n  TransactionAuthField,\n} from './authorization';\n\nexport type StacksMessage =\n  | Address\n  | PostConditionPrincipal\n  | LengthPrefixedString\n  | LengthPrefixedList\n  | Payload\n  | MemoString\n  | AssetInfo\n  | PostCondition\n  | StacksPublicKey\n  | TransactionAuthField\n  | MessageSignature;\n\nexport function serializeStacksMessage(message: StacksMessage): Buffer {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\n\nexport function deserializeStacksMessage(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  listType?: StacksMessageType\n): StacksMessage {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bufferReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bufferReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bufferReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bufferReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bufferReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bufferReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bufferReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bufferReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bufferReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bufferReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\n\nexport interface Address {\n  readonly type: StacksMessageType.Address;\n  readonly version: AddressVersion;\n  readonly hash160: string;\n}\n\nexport function createAddress(c32AddressString: string): Address {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1],\n  };\n}\n\nexport function createEmptyAddress(): Address {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40),\n  };\n}\n\nexport function addressFromVersionHash(version: AddressVersion, hash: string): Address {\n  return { type: StacksMessageType.Address, version, hash160: hash };\n}\n\n/**\n * Translates the tx auth hash mode to the corresponding address version.\n * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization\n */\nexport function addressHashModeToVersion(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion\n): AddressVersion {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\n\nexport function addressFromHashMode(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion,\n  data: string\n): Address {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\n\nexport function addressFromPublicKeys(\n  version: AddressVersion,\n  hashMode: AddressHashMode,\n  numSigs: number,\n  publicKeys: StacksPublicKey[]\n): Address {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    default:\n      throw Error(\n        `Not yet implemented: address construction using public keys for hash mode: ${hashMode}`\n      );\n  }\n}\n\nexport function addressToString(address: Address): string {\n  return c32address(address.version, address.hash160).toString();\n}\n\nexport function serializeAddress(address: Address): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(address.version, 1));\n  bufferArray.appendHexString(address.hash160);\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAddress(bufferReader: BufferReader): Address {\n  const version = hexStringToInt(bufferReader.readBuffer(1).toString('hex'));\n  const data = bufferReader.readBuffer(20).toString('hex');\n\n  return { type: StacksMessageType.Address, version, hash160: data };\n}\n\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\n\nexport interface StandardPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Standard;\n  readonly address: Address;\n}\n\nexport interface ContractPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Contract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\n/**\n * Parses a principal string for either a standard principal or contract principal.\n * @param principalString - String in the format `{address}.{contractName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\n */\nexport function parsePrincipalString(\n  principalString: string\n): StandardPrincipal | ContractPrincipal {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\n\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr,\n  };\n}\n\nexport function createContractPrincipal(\n  addressString: string,\n  contractName: string\n): ContractPrincipal {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name,\n  };\n}\n\nexport function serializePrincipal(principal: PostConditionPrincipal): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(Buffer.from([principal.prefix]));\n  bufferArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bufferArray.push(serializeLPString(principal.contractName));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal {\n  const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n    throw new DeserializationError('Unexpected Principal payload type: ${n}');\n  });\n  const address = deserializeAddress(bufferReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return { type: StacksMessageType.Principal, prefix, address } as StandardPrincipal;\n  }\n  const contractName = deserializeLPString(bufferReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName,\n  } as ContractPrincipal;\n}\n\nexport interface LengthPrefixedString {\n  readonly type: StacksMessageType.LengthPrefixedString;\n  readonly content: string;\n  readonly lengthPrefixBytes: number;\n  readonly maxLengthBytes: number;\n}\n\nexport function createLPString(content: string): LengthPrefixedString;\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes: number,\n  maxLengthBytes: number\n): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes?: number,\n  maxLengthBytes?: number\n): LengthPrefixedString {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength,\n  };\n}\n\nexport function serializeLPString(lps: LengthPrefixedString) {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(lps.content);\n  const length = contentBuffer.byteLength;\n  bufferArray.appendHexString(intToHexString(length, lps.lengthPrefixBytes));\n  bufferArray.push(contentBuffer);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPString(\n  bufferReader: BufferReader,\n  prefixBytes?: number,\n  maxLength?: number\n): LengthPrefixedString {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n  const content = bufferReader.readBuffer(length).toString();\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\n\nexport function codeBodyString(content: string): LengthPrefixedString {\n  return createLPString(content, 4, 100000);\n}\n\nexport interface MemoString {\n  readonly type: StacksMessageType.MemoString;\n  readonly content: string;\n}\n\nexport function createMemoString(content: string): MemoString {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n  }\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeMemoString(memoString: MemoString): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(memoString.content);\n  const paddedContent = rightPadHexToLength(\n    contentBuffer.toString('hex'),\n    MEMO_MAX_LENGTH_BYTES * 2\n  );\n  bufferArray.push(Buffer.from(paddedContent, 'hex'));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMemoString(bufferReader: BufferReader): MemoString {\n  const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport interface AssetInfo {\n  readonly type: StacksMessageType.AssetInfo;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly assetName: LengthPrefixedString;\n}\n\n/**\n * Parse a fully qualified string that identifies the token type.\n * @param id - String in the format `{address}.{contractName}::{assetName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract::example-token\"\n */\nexport function parseAssetInfoString(id: string): AssetInfo {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\n\nexport function createAssetInfo(\n  addressString: string,\n  contractName: string,\n  assetName: string\n): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName),\n  };\n}\n\nexport function serializeAssetInfo(info: AssetInfo): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(serializeAddress(info.address));\n  bufferArray.push(serializeLPString(info.contractName));\n  bufferArray.push(serializeLPString(info.assetName));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bufferReader),\n    contractName: deserializeLPString(bufferReader),\n    assetName: deserializeLPString(bufferReader),\n  };\n}\n\nexport interface LengthPrefixedList {\n  readonly type: StacksMessageType.LengthPrefixedList;\n  readonly lengthPrefixBytes: number;\n  readonly values: StacksMessage[];\n}\n\nexport function createLPList<T extends StacksMessage>(\n  values: T[],\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values,\n  };\n}\n\nexport function serializeLPList(lpList: LengthPrefixedList): Buffer {\n  const list = lpList.values;\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(list.length, lpList.lengthPrefixBytes));\n  for (let index = 0; index < list.length; index++) {\n    bufferArray.push(serializeStacksMessage(list[index]));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPList(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  const length = hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n  const l: StacksMessage[] = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bufferReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bufferReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bufferReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bufferReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bufferReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bufferReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bufferReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\n","import { ClarityType } from '../clarityValue';\n\ntype BooleanCV = TrueCV | FalseCV;\n\ninterface TrueCV {\n  type: ClarityType.BoolTrue;\n}\n\ninterface FalseCV {\n  type: ClarityType.BoolFalse;\n}\n\nconst trueCV = (): BooleanCV => ({ type: ClarityType.BoolTrue });\nconst falseCV = (): BooleanCV => ({ type: ClarityType.BoolFalse });\n\nexport { BooleanCV, TrueCV, FalseCV, trueCV, falseCV };\n","import BigNum from 'bn.js';\nimport { CLARITY_INT_SIZE } from '../../constants';\nimport { ClarityType } from '../clarityValue';\n\ninterface IntCV {\n  readonly type: ClarityType.Int;\n  readonly value: BigNum;\n}\n\nconst intCV = (value: number | string | Buffer): IntCV => {\n  const bn = new BigNum(value);\n  const twos = bn.toTwos(CLARITY_INT_SIZE);\n\n  if (twos.bitLength() > CLARITY_INT_SIZE) {\n    throw new Error('Cannot construct clarity integer from value greater than INT_SIZE bits');\n  }\n\n  return { type: ClarityType.Int, value: twos };\n};\n\ninterface UIntCV {\n  readonly type: ClarityType.UInt;\n  readonly value: BigNum;\n}\n\nconst uintCV = (value: number | string | Buffer): UIntCV => {\n  const bn = new BigNum(value);\n  const twos = bn.toTwos(CLARITY_INT_SIZE);\n\n  if (twos.isNeg()) {\n    throw new Error('Cannot construct unsigned clarity integer from negative value');\n  } else if (twos.bitLength() > CLARITY_INT_SIZE) {\n    throw new Error('Cannot construct unsigned clarity integer from value greater than 128 bits');\n  }\n\n  return { type: ClarityType.UInt, value: twos };\n};\n\nexport { IntCV, UIntCV, intCV, uintCV };\n","import { ClarityType } from '../clarityValue';\n\ninterface BufferCV {\n  readonly type: ClarityType.Buffer;\n  readonly buffer: Buffer;\n}\n\nconst bufferCV = (buffer: Buffer): BufferCV => {\n  if (buffer.length > 1000000) {\n    throw new Error('Cannot construct clarity buffer that is greater than 1MB');\n  }\n\n  return { type: ClarityType.Buffer, buffer };\n};\n\nconst bufferCVFromString = (str: string): BufferCV => bufferCV(Buffer.from(str));\n\nexport { BufferCV, bufferCV, bufferCVFromString };\n","import { ClarityType, ClarityValue } from '../clarityValue';\n\ntype OptionalCV = NoneCV | SomeCV;\n\ninterface NoneCV {\n  readonly type: ClarityType.OptionalNone;\n}\n\ninterface SomeCV {\n  readonly type: ClarityType.OptionalSome;\n  readonly value: ClarityValue;\n}\n\nconst noneCV = (): OptionalCV => ({ type: ClarityType.OptionalNone });\nconst someCV = (value: ClarityValue): OptionalCV => ({ type: ClarityType.OptionalSome, value });\nconst optionalCVOf = (value?: ClarityValue): OptionalCV => {\n  if (value) {\n    return someCV(value);\n  } else {\n    return noneCV();\n  }\n};\n\nexport { OptionalCV, NoneCV, SomeCV, noneCV, someCV, optionalCVOf };\n","import { ClarityType, ClarityValue } from '../clarityValue';\n\ntype ResponseCV = ResponseErrorCV | ResponseOkCV;\n\ninterface ResponseErrorCV {\n  readonly type: ClarityType.ResponseErr;\n  readonly value: ClarityValue;\n}\n\ninterface ResponseOkCV {\n  readonly type: ClarityType.ResponseOk;\n  readonly value: ClarityValue;\n}\n\nfunction responseErrorCV(value: ClarityValue): ResponseErrorCV {\n  return { type: ClarityType.ResponseErr, value };\n}\n\nfunction responseOkCV(value: ClarityValue): ResponseOkCV {\n  return { type: ClarityType.ResponseOk, value };\n}\n\nexport { ResponseCV, ResponseErrorCV, ResponseOkCV, responseErrorCV, responseOkCV };\n","import { ClarityValue, ClarityType } from '../clarityValue';\n\ninterface ListCV {\n  type: ClarityType.List;\n  list: ClarityValue[];\n}\n\nfunction listCV<T extends ClarityValue>(values: T[]): ListCV {\n  return { type: ClarityType.List, list: values };\n}\n\nexport { ListCV, listCV };\n","import { ClarityType, ClarityValue } from '../clarityValue';\nimport { isClarityName } from '../../utils';\n\ntype TupleData = { [key: string]: ClarityValue };\n\ninterface TupleCV {\n  type: ClarityType.Tuple;\n  data: TupleData;\n}\n\nfunction tupleCV(data: TupleData): TupleCV {\n  for (const key in data) {\n    if (!isClarityName(key)) {\n      throw new Error(`\"${key}\" is not a valid Clarity name`);\n    }\n  }\n\n  return { type: ClarityType.Tuple, data };\n}\n\nexport { TupleCV, tupleCV };\n","import { ClarityType } from '../clarityValue';\n\ninterface StringAsciiCV {\n  readonly type: ClarityType.StringASCII;\n  readonly data: string;\n}\n\ninterface StringUtf8CV {\n  readonly type: ClarityType.StringUTF8;\n  readonly data: string;\n}\n\nconst stringAsciiCV = (data: string): StringAsciiCV => {\n  return { type: ClarityType.StringASCII, data };\n};\n\nconst stringUtf8CV = (data: string): StringUtf8CV => {\n  return { type: ClarityType.StringUTF8, data };\n};\n\nconst stringCV = (data: string, encoding: 'ascii' | 'utf8'): StringAsciiCV | StringUtf8CV => {\n  switch (encoding) {\n    case 'ascii':\n      return stringAsciiCV(data);\n    case 'utf8':\n      return stringAsciiCV(data);\n  }\n};\n\nexport { StringAsciiCV, StringUtf8CV, stringAsciiCV, stringUtf8CV, stringCV };\n","import { serializeAddress, serializeLPString, createLPString } from '../types';\nimport {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseCV,\n  ListCV,\n  TupleCV,\n  ClarityType,\n  ClarityValue,\n} from '.';\nimport { BufferArray } from '../utils';\nimport { SerializationError } from '../errors';\nimport { StringAsciiCV, StringUtf8CV } from './types/stringCV';\n\nfunction bufferWithTypeID(typeId: ClarityType, buffer: Buffer): Buffer {\n  const id = Buffer.from([typeId]);\n  return Buffer.concat([id, buffer]);\n}\n\nfunction serializeBoolCV(value: BooleanCV): Buffer {\n  return Buffer.from([value.type]);\n}\n\nfunction serializeOptionalCV(cv: OptionalCV): Buffer {\n  if (cv.type === ClarityType.OptionalNone) {\n    return Buffer.from([cv.type]);\n  } else {\n    return bufferWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv: BufferCV): Buffer {\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.buffer.length, 0);\n  return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));\n}\n\nfunction serializeIntCV(cv: IntCV | UIntCV): Buffer {\n  const buffer = cv.value.toArrayLike(Buffer, 'be', 16);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeStandardPrincipalCV(cv: StandardPrincipalCV): Buffer {\n  return bufferWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv: ContractPrincipalCV): Buffer {\n  return bufferWithTypeID(\n    cv.type,\n    Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)])\n  );\n}\n\nfunction serializeResponseCV(cv: ResponseCV) {\n  return bufferWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv: ListCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.list.length, 0);\n  buffers.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeTupleCV(cv: TupleCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(Object.keys(cv.data).length, 0);\n  buffers.push(length);\n\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {\n    const bufA = Buffer.from(a);\n    const bufB = Buffer.from(b);\n    return bufA.compare(bufB);\n  });\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    buffers.push(serializeLPString(nameWithLength));\n\n    const serializedValue = serializeCV(cv.data[key]);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringCV(cv: StringAsciiCV | StringUtf8CV, encoding: 'ascii' | 'utf8') {\n  const buffers = new BufferArray();\n\n  const str = Buffer.from(cv.data, encoding);\n  const len = Buffer.alloc(4);\n  len.writeUInt32BE(str.length, 0);\n\n  buffers.push(len);\n  buffers.push(str);\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringAsciiCV(cv: StringAsciiCV) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv: StringUtf8CV) {\n  return serializeStringCV(cv, 'utf8');\n}\n\nexport function serializeCV(value: ClarityValue): Buffer {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}\n","import { SmartBuffer, SmartBufferOptions } from 'smart-buffer';\n\nfunction createEnumChecker<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue }\n): (value: number) => value is TEnumValue {\n  // Create a set of valid enum number values.\n  const enumValues = Object.values<number>(enumVariable).filter(v => typeof v === 'number');\n  const enumValueSet = new Set<number>(enumValues);\n  return (value: number): value is TEnumValue => enumValueSet.has(value);\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst enumCheckFunctions = new Map<object, (value: number) => boolean>();\n\n/**\n * Type guard to check if a given value is a valid enum value.\n * @param enumVariable - Literal `enum` type.\n * @param value - A value to check against the enum's values.\n * @example\n * ```ts\n * enum Color {\n *   Purple = 3,\n *   Orange = 5\n * }\n * const val: number = 3;\n * if (isEnum(Color, val)) {\n *   // `val` is known as enum type `Color`, e.g.:\n *   const colorVal: Color = val;\n * }\n * ```\n */\nexport function isEnum<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue },\n  value: number\n): value is TEnumValue {\n  const checker = enumCheckFunctions.get(enumVariable);\n  if (checker !== undefined) {\n    return checker(value);\n  }\n  const newChecker = createEnumChecker(enumVariable);\n  enumCheckFunctions.set(enumVariable, newChecker);\n  return isEnum(enumVariable, value);\n}\n\nexport class BufferReader {\n  smartBuffer: SmartBuffer;\n\n  static fromBuffer(buffer: Buffer): BufferReader {\n    return new BufferReader({ buff: buffer });\n  }\n\n  constructor(options?: SmartBufferOptions | Buffer) {\n    if (Buffer.isBuffer(options)) {\n      this.smartBuffer = new SmartBuffer({ buff: options });\n    } else {\n      this.smartBuffer = new SmartBuffer(options);\n    }\n  }\n\n  readBuffer(length: number): Buffer {\n    return this.smartBuffer.readBuffer(length);\n  }\n\n  readUInt32BE(offset?: number): number {\n    return this.smartBuffer.readUInt32BE(offset);\n  }\n\n  readUInt8(): number {\n    return this.smartBuffer.readUInt8();\n  }\n\n  readUInt16BE(): number {\n    return this.smartBuffer.readUInt16BE();\n  }\n\n  readBigUIntLE(length: number): bigint {\n    const buffer = Buffer.from(this.smartBuffer.readBuffer(length)).reverse();\n    const hex = buffer.toString();\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUIntBE(length: number): bigint {\n    const buffer = this.smartBuffer.readBuffer(length);\n    const hex = buffer.toString('hex');\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUInt64BE(): bigint {\n    return this.smartBuffer.readBigUInt64BE();\n  }\n\n  readString(arg?: number | BufferEncoding, encoding?: BufferEncoding): string {\n    return this.smartBuffer.readString(arg, encoding);\n  }\n\n  get readOffset(): number {\n    return this.smartBuffer.readOffset;\n  }\n\n  set readOffset(val: number) {\n    this.smartBuffer.readOffset = val;\n  }\n\n  get internalBuffer(): Buffer {\n    return this.smartBuffer.internalBuffer;\n  }\n\n  readUInt8Enum<T extends string, TEnumValue extends number>(\n    enumVariable: { [key in T]: TEnumValue },\n    invalidEnumErrorFormatter: (val: number) => Error\n  ): TEnumValue {\n    const num = this.smartBuffer.readUInt8();\n    if (isEnum(enumVariable, num)) {\n      return num;\n    } else {\n      throw invalidEnumErrorFormatter(num);\n    }\n  }\n}\n","import {\n  ClarityType,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCV,\n  trueCV,\n  falseCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCVFromAddress,\n  responseOkCV,\n  responseErrorCV,\n  noneCV,\n  someCV,\n  listCV,\n  tupleCV,\n} from '.';\nimport { BufferReader } from '../bufferReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\n\nexport default function deserializeCV(buffer: BufferReader | Buffer): ClarityValue {\n  const bufferReader = Buffer.isBuffer(buffer) ? new BufferReader(buffer) : buffer;\n  const type = bufferReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bufferReader.readBuffer(16));\n\n    case ClarityType.UInt:\n      return uintCV(bufferReader.readBuffer(16));\n\n    case ClarityType.Buffer:\n      const bufferLength = bufferReader.readUInt32BE();\n      return bufferCV(bufferReader.readBuffer(bufferLength));\n\n    case ClarityType.BoolTrue:\n      return trueCV();\n\n    case ClarityType.BoolFalse:\n      return falseCV();\n\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bufferReader);\n      return standardPrincipalCVFromAddress(sAddress);\n\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bufferReader);\n      const contractName = deserializeLPString(bufferReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName);\n\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bufferReader));\n\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bufferReader));\n\n    case ClarityType.OptionalNone:\n      return noneCV();\n\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bufferReader));\n\n    case ClarityType.List:\n      const listLength = bufferReader.readUInt32BE();\n      const listContents: ClarityValue[] = [];\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bufferReader));\n      }\n      return listCV(listContents);\n\n    case ClarityType.Tuple:\n      const tupleLength = bufferReader.readUInt32BE();\n      const tupleContents: { [key: string]: ClarityValue } = {};\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bufferReader).content;\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n        tupleContents[clarityName] = deserializeCV(bufferReader);\n      }\n      return tupleCV(tupleContents);\n\n    case ClarityType.StringASCII:\n      const asciiStrLen = bufferReader.readUInt32BE();\n      const asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');\n      return stringAsciiCV(asciiStr);\n\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bufferReader.readUInt32BE();\n      const utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');\n      return stringUtf8CV(utf8Str);\n\n    default:\n      throw new DeserializationError(\n        'Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.'\n      );\n  }\n}\n","import { sha256, sha512 } from 'sha.js';\nimport { ClarityValue, serializeCV } from './clarity';\nimport RIPEMD160 from 'ripemd160-min';\nimport randombytes from 'randombytes';\nimport { deserializeCV } from './clarity';\nimport fetch from 'cross-fetch';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash/cloneDeep';\n\nexport { randombytes as randomBytes };\n\nexport class BufferArray {\n  _value: Buffer[] = [];\n  get value() {\n    return this._value;\n  }\n  appendHexString(hexString: string) {\n    this.value.push(Buffer.from(hexString, 'hex'));\n  }\n\n  push(buffer: Buffer) {\n    return this._value.push(buffer);\n  }\n  appendByte(octet: number) {\n    if (!Number.isInteger(octet) || octet < 0 || octet > 255) {\n      throw new Error(`Value ${octet} is not a valid byte`);\n    }\n    this.value.push(Buffer.from([octet]));\n  }\n\n  concatBuffer(): Buffer {\n    return Buffer.concat(this.value);\n  }\n}\n\nexport const leftPadHex = (hexString: string): string =>\n  hexString.length % 2 == 0 ? hexString : `0${hexString}`;\n\nexport const leftPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padStart(length, '0');\n\nexport const rightPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padEnd(length, '0');\n\nexport const intToHexString = (integer: number, lengthBytes = 8): string =>\n  integer.toString(16).padStart(lengthBytes * 2, '0');\n\nexport const hexStringToInt = (hexString: string): number => parseInt(hexString, 16);\n\nexport const exceedsMaxLengthBytes = (string: string, maxLengthBytes: number): boolean =>\n  string ? Buffer.from(string).length > maxLengthBytes : false;\n\nexport function cloneDeep<T>(obj: T): T {\n  return lodashCloneDeep(obj);\n}\n\nexport function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K> {\n  const clone = cloneDeep(obj);\n  // @ts-expect-error\n  delete clone[prop];\n  return clone;\n}\n\nexport class sha512_256 extends sha512 {\n  constructor() {\n    super();\n    // set the \"SHA-512/256\" initialization vector\n    // see https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\n    Object.assign(this, {\n      _ah: 0x22312194,\n      _al: 0xfc2bf72c,\n      _bh: 0x9f555fa3,\n      _bl: 0xc84c64c2,\n      _ch: 0x2393b86b,\n      _cl: 0x6f53b151,\n      _dh: 0x96387719,\n      _dl: 0x5940eabd,\n      _eh: 0x96283ee2,\n      _el: 0xa88effe3,\n      _fh: 0xbe5e1e25,\n      _fl: 0x53863992,\n      _gh: 0x2b0199fc,\n      _gl: 0x2c85b8aa,\n      _hh: 0x0eb72ddc,\n      _hl: 0x81c52ca2,\n    });\n  }\n  digest(): Buffer;\n  digest(encoding: import('crypto').HexBase64Latin1Encoding): string;\n  digest(encoding?: import('crypto').HexBase64Latin1Encoding): string | Buffer {\n    // \"SHA-512/256\" truncates the digest to 32 bytes\n    const buff = super.digest().slice(0, 32);\n    return encoding ? buff.toString(encoding) : buff;\n  }\n}\n\nexport const txidFromData = (data: Buffer): string => new sha512_256().update(data).digest('hex');\n\nexport const hash160 = (input: Buffer): Buffer => {\n  const sha256Result = new sha256().update(input).digest();\n  return Buffer.from(new RIPEMD160().update(sha256Result).digest());\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address (p2pkh)\nexport const hashP2PKH = (input: Buffer): string => {\n  return hash160(input).toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multi-sig address (p2sh)\nexport const hashP2SH = (numSigs: number, pubKeys: Buffer[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const bufferArray = new BufferArray();\n  // OP_n\n  bufferArray.appendByte(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    bufferArray.appendByte(pubKey.length);\n    bufferArray.push(pubKey);\n  });\n  // OP_m\n  bufferArray.appendByte(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  bufferArray.appendByte(174);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\nexport function isClarityName(name: string) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\n\n/** @ignore */\nexport async function fetchPrivate(input: RequestInfo, init?: RequestInit): Promise<Response> {\n  const defaultFetchOpts: RequestInit = {\n    referrer: 'no-referrer',\n    referrerPolicy: 'no-referrer',\n  };\n  const fetchOpts = Object.assign(defaultFetchOpts, init);\n  const fetchResult = await fetch(input, fetchOpts);\n  return fetchResult;\n}\n/**\n * Converts a clarity value to a hex encoded string with `0x` prefix\n * @param {ClarityValue} cv  - the clarity value to convert\n */\nexport function cvToHex(cv: ClarityValue) {\n  const serialized = serializeCV(cv);\n  return `0x${serialized.toString('hex')}`;\n}\n\n/**\n * Converts a hex encoded string to a clarity value\n * @param {string} hex - the hex encoded string with or without `0x` prefix\n */\nexport function hexToCV(hex: string) {\n  const hexWithoutPrefix = hex.startsWith('0x') ? hex.slice(2) : hex;\n  const bufferCV = Buffer.from(hexWithoutPrefix, 'hex');\n  return deserializeCV(bufferCV);\n}\n/**\n * Read only function response object\n *\n * @param {Boolean} okay - the status of the response\n * @param {string} result - serialized hex clarity value\n */\n\nexport interface ReadOnlyFunctionSuccessResponse {\n  okay: true;\n  result: string;\n}\n\nexport interface ReadOnlyFunctionErrorResponse {\n  okay: false;\n  cause: string;\n}\n\nexport type ReadOnlyFunctionResponse =\n  | ReadOnlyFunctionSuccessResponse\n  | ReadOnlyFunctionErrorResponse;\n\n/**\n * Converts the response of a read-only function call into its Clarity Value\n * @param param\n */\nexport const parseReadOnlyResponse = (response: ReadOnlyFunctionResponse): ClarityValue => {\n  if (response.okay) {\n    return hexToCV(response.result);\n  } else {\n    throw new Error(response.cause);\n  }\n};\n\nexport const validateStacksAddress = (stacksAddress: string): boolean => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n","import {\n  AddressHashMode,\n  AuthType,\n  MultiSigHashMode,\n  PubKeyEncoding,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  SingleSigHashMode,\n  StacksMessageType,\n} from './constants';\n\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\n\nimport {\n  addressFromPublicKeys,\n  createEmptyAddress,\n  createLPList,\n  deserializeLPList,\n  serializeLPList,\n} from './types';\n\nimport {\n  compressPublicKey,\n  createStacksPublicKey,\n  deserializePublicKey,\n  getPublicKey,\n  isCompressed,\n  publicKeyFromSignature,\n  serializePublicKey,\n  signWithKey,\n  StacksPrivateKey,\n  StacksPublicKey,\n} from './keys';\n\nimport BigNum from 'bn.js';\nimport { BufferReader } from './bufferReader';\nimport { DeserializationError, SerializationError, SigningError } from './errors';\n\nabstract class Deserializable {\n  abstract serialize(): Buffer;\n  abstract deserialize(bufferReader: BufferReader): void;\n  static deserialize<T extends Deserializable>(this: new () => T, bufferReader: BufferReader): T {\n    const message = new this();\n    message.deserialize(bufferReader);\n    return message;\n  }\n}\n\nexport interface MessageSignature {\n  readonly type: StacksMessageType.MessageSignature;\n  data: string;\n}\n\nexport function createMessageSignature(signature: string): MessageSignature {\n  const length = Buffer.from(signature, 'hex').byteLength;\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature,\n  };\n}\n\nexport function emptyMessageSignature(): MessageSignature {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),\n  };\n}\n\nexport function serializeMessageSignature(messageSignature: MessageSignature): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature {\n  return createMessageSignature(\n    bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex')\n  );\n}\n\nenum AuthFieldType {\n  PublicKeyCompressed = 0x00,\n  PublicKeyUncompressed = 0x01,\n  SignatureCompressed = 0x02,\n  SignatureUncompressed = 0x03,\n}\n\nexport type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport function createTransactionAuthField(\n  pubKeyEncoding: PubKeyEncoding,\n  contents: TransactionAuthFieldContents\n): TransactionAuthField {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents,\n  };\n}\n\nexport function serializeTransactionAuthField(field: TransactionAuthField): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n      break;\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\n\nexport interface SingleSigSpendingCondition {\n  hashMode: SingleSigHashMode;\n  signer: string;\n  nonce: BigNum;\n  fee: BigNum;\n  keyEncoding: PubKeyEncoding;\n  signature: MessageSignature;\n}\n\nexport interface MultiSigSpendingCondition {\n  hashMode: MultiSigHashMode;\n  signer: string;\n  nonce: BigNum;\n  fee: BigNum;\n  fields: TransactionAuthField[];\n  signaturesRequired: number;\n}\n\nexport type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;\n\nexport function createSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  pubKey: string,\n  nonce: BigNum,\n  fee: BigNum\n): SingleSigSpendingCondition {\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature: emptyMessageSignature(),\n  };\n}\n\nexport function createMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  numSigs: number,\n  pubKeys: string[],\n  nonce: BigNum,\n  fee: BigNum\n): MultiSigSpendingCondition {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields: [],\n    signaturesRequired: numSigs,\n  };\n}\n\nexport function isSingleSig(condition: SpendingCondition): condition is SingleSigSpendingCondition {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition: SpendingCondition): SpendingCondition {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = new BigNum(0);\n  cloned.fee = new BigNum(0);\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return cloned;\n}\n\nexport function serializeSingleSigSpendingCondition(condition: SingleSigSpendingCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));\n  bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\n\nexport function serializeMultiSigSpendingCondition(condition: MultiSigSpendingCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));\n  bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));\n\n  const fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n\n  const numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  bufferReader: BufferReader\n): SingleSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n  const fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n\n  const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  const signature = deserializeMessageSignature(bufferReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature,\n  };\n}\n\nexport function deserializeMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  bufferReader: BufferReader\n): MultiSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n  const fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n\n  const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField)\n    .values as TransactionAuthField[];\n\n  const signaturesRequired = bufferReader.readUInt16BE();\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired,\n  };\n}\n\nexport function serializeSpendingCondition(condition: SpendingCondition): Buffer {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\n\nexport function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition {\n  const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\n\nexport function makeSigHashPreSign(\n  curSigHash: string,\n  authType: AuthType,\n  fee: BigNum,\n  nonce: BigNum\n): string {\n  // new hash combines the previous hash and all the new data this signature will add. This\n  // includes:\n  // * the previous hash\n  // * the auth flag\n  // * the tx fee (big-endian 8-byte number)\n  // * nonce (big-endian 8-byte number)\n  const hashLength = 32 + 1 + 8 + 8;\n\n  const sigHash =\n    curSigHash +\n    Buffer.from([authType]).toString('hex') +\n    fee.toArrayLike(Buffer, 'be', 8).toString('hex') +\n    nonce.toArrayLike(Buffer, 'be', 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(\n  curSigHash: string,\n  pubKey: StacksPublicKey,\n  signature: MessageSignature\n): string {\n  // new hash combines the previous hash and all the new data this signature will add.  This\n  // includes:\n  // * the public key compression flag\n  // * the signature\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n\n  const pubKeyEncoding = isCompressed(pubKey)\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n\n  const sigHashBuffer = Buffer.from(sigHash, 'hex');\n  if (sigHashBuffer.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBuffer);\n}\n\nexport function nextSignature(\n  curSigHash: string,\n  authType: AuthType,\n  fee: BigNum,\n  nonce: BigNum,\n  privateKey: StacksPrivateKey\n): {\n  nextSig: MessageSignature;\n  nextSigHash: string;\n} {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    nextSig: signature,\n    nextSigHash,\n  };\n}\n\nexport function nextVerification(\n  initialSigHash: string,\n  authType: AuthType,\n  fee: BigNum,\n  nonce: BigNum,\n  // @ts-ignore\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n\n  const publicKey = createStacksPublicKey(\n    publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding)\n  );\n\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    pubKey: publicKey,\n    nextSigHash,\n  };\n}\n\nfunction newInitialSigHash(): SpendingCondition {\n  const spendingCondition = createSingleSigSpendingCondition(\n    AddressHashMode.SerializeP2PKH,\n    '',\n    new BigNum(0),\n    new BigNum(0)\n  );\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(condition: SpendingCondition, initialSigHash: string, authType: AuthType): string {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    // TODO: verify multisig\n    return '';\n  }\n}\n\nfunction verifySingleSig(\n  condition: SingleSigSpendingCondition,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const { nextSigHash } = nextVerification(\n    initialSigHash,\n    authType,\n    condition.fee,\n    condition.nonce,\n    condition.keyEncoding,\n    condition.signature\n  );\n\n  // TODO: verify pub key\n\n  return nextSigHash;\n}\n\nexport class Authorization extends Deserializable {\n  authType?: AuthType;\n  spendingCondition?: SpendingCondition;\n  sponsorSpendingCondition?: SpendingCondition;\n\n  constructor(\n    authType?: AuthType,\n    spendingConditions?: SpendingCondition,\n    sponsorSpendingCondition?: SpendingCondition\n  ) {\n    super();\n    this.authType = authType;\n    this.spendingCondition = spendingConditions;\n    this.sponsorSpendingCondition = sponsorSpendingCondition;\n  }\n\n  intoInitialSighashAuth(): Authorization {\n    if (this.spendingCondition) {\n      switch (this.authType) {\n        case AuthType.Standard:\n          return new Authorization(AuthType.Standard, clearCondition(this.spendingCondition));\n        case AuthType.Sponsored:\n          return new Authorization(\n            AuthType.Sponsored,\n            clearCondition(this.spendingCondition),\n            newInitialSigHash()\n          );\n        default:\n          throw new SigningError('Unexpected authorization type for signing');\n      }\n    }\n\n    throw new Error('Authorization missing SpendingCondition');\n  }\n\n  setFee(amount: BigNum) {\n    switch (this.authType) {\n      case AuthType.Standard:\n        this.spendingCondition!.fee = amount;\n        break;\n      case AuthType.Sponsored:\n        this.sponsorSpendingCondition!.fee = amount;\n        break;\n    }\n  }\n\n  getFee() {\n    switch (this.authType) {\n      case AuthType.Standard:\n        return this.spendingCondition!.fee;\n      case AuthType.Sponsored:\n        return this.sponsorSpendingCondition!.fee;\n      default:\n        return 0;\n    }\n  }\n\n  setNonce(nonce: BigNum) {\n    this.spendingCondition!.nonce = nonce;\n  }\n\n  setSponsorNonce(nonce: BigNum) {\n    this.sponsorSpendingCondition!.nonce = nonce;\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingCondition) {\n    this.sponsorSpendingCondition = sponsorSpendingCondition;\n  }\n\n  verifyOrigin(initialSigHash: string): string {\n    switch (this.authType) {\n      case AuthType.Standard:\n        return verify(this.spendingCondition!, initialSigHash, AuthType.Standard);\n      case AuthType.Sponsored:\n        return verify(this.spendingCondition!, initialSigHash, AuthType.Standard);\n      default:\n        throw new SigningError('Invalid origin auth type');\n    }\n  }\n\n  serialize(): Buffer {\n    const bufferArray: BufferArray = new BufferArray();\n    if (this.authType === undefined) {\n      throw new SerializationError('\"authType\" is undefined');\n    }\n    bufferArray.appendByte(this.authType);\n\n    switch (this.authType) {\n      case AuthType.Standard:\n        if (this.spendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n        bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n        break;\n      case AuthType.Sponsored:\n        if (this.spendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n        if (this.sponsorSpendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n        bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n        bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));\n        break;\n      default:\n        throw new SerializationError(\n          `Unexpected transaction AuthType while serializing: ${JSON.stringify(this.authType)}`\n        );\n    }\n\n    return bufferArray.concatBuffer();\n  }\n\n  deserialize(bufferReader: BufferReader) {\n    this.authType = bufferReader.readUInt8Enum(AuthType, n => {\n      throw new DeserializationError(`Could not parse ${n} as AuthType`);\n    });\n\n    switch (this.authType) {\n      case AuthType.Standard:\n        this.spendingCondition = deserializeSpendingCondition(bufferReader);\n        break;\n      case AuthType.Sponsored:\n        this.spendingCondition = deserializeSpendingCondition(bufferReader);\n        this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n        break;\n      // throw new DeserializationError('Not yet implemented: deserializing sponsored transactions');\n      default:\n        throw new DeserializationError(\n          `Unexpected transaction AuthType while deserializing: ${JSON.stringify(this.authType)}`\n        );\n    }\n  }\n}\n\nexport class StandardAuthorization extends Authorization {\n  constructor(spendingCondition: SpendingCondition) {\n    super(AuthType.Standard, spendingCondition);\n  }\n}\n\nexport class SponsoredAuthorization extends Authorization {\n  constructor(\n    originSpendingCondition: SpendingCondition,\n    sponsorSpendingCondition?: SpendingCondition\n  ) {\n    let sponsorSC = sponsorSpendingCondition;\n    if (!sponsorSC) {\n      sponsorSC = createSingleSigSpendingCondition(\n        AddressHashMode.SerializeP2PKH,\n        '0'.repeat(66),\n        new BigNum(0),\n        new BigNum(0)\n      );\n    }\n    super(AuthType.Sponsored, originSpendingCondition, sponsorSC);\n  }\n}\n","import { cloneDeep } from './utils';\nimport {\n  ClarityValue,\n  uintCV,\n  intCV,\n  contractPrincipalCV,\n  standardPrincipalCV,\n  noneCV,\n  bufferCV,\n  falseCV,\n  trueCV,\n  ClarityType,\n  getCVTypeString,\n  bufferCVFromString,\n} from './clarity';\nimport { ContractCallPayload } from './payload';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\n\n// From https://github.com/blockstack/stacks-blockchain-sidecar/blob/master/src/event-stream/contract-abi.ts\n\nexport type ClarityAbiTypeBuffer = { buffer: { length: number } };\nexport type ClarityAbiTypeStringAscii = { 'string-ascii': { length: number } };\nexport type ClarityAbiTypeStringUtf8 = { 'string-utf8': { length: number } };\nexport type ClarityAbiTypeResponse = { response: { ok: ClarityAbiType; error: ClarityAbiType } };\nexport type ClarityAbiTypeOptional = { optional: ClarityAbiType };\nexport type ClarityAbiTypeTuple = { tuple: { name: string; type: ClarityAbiType }[] };\nexport type ClarityAbiTypeList = { list: { type: ClarityAbiType; length: number } };\n\nexport type ClarityAbiTypeUInt128 = 'uint128';\nexport type ClarityAbiTypeInt128 = 'int128';\nexport type ClarityAbiTypeBool = 'bool';\nexport type ClarityAbiTypePrincipal = 'principal';\nexport type ClarityAbiTypeTraitReference = 'trait_reference';\nexport type ClarityAbiTypeNone = 'none';\n\nexport type ClarityAbiTypePrimitive =\n  | ClarityAbiTypeUInt128\n  | ClarityAbiTypeInt128\n  | ClarityAbiTypeBool\n  | ClarityAbiTypePrincipal\n  | ClarityAbiTypeTraitReference\n  | ClarityAbiTypeNone;\n\nexport type ClarityAbiType =\n  | ClarityAbiTypePrimitive\n  | ClarityAbiTypeBuffer\n  | ClarityAbiTypeResponse\n  | ClarityAbiTypeOptional\n  | ClarityAbiTypeTuple\n  | ClarityAbiTypeList\n  | ClarityAbiTypeStringAscii\n  | ClarityAbiTypeStringUtf8\n  | ClarityAbiTypeTraitReference;\n\nexport enum ClarityAbiTypeId {\n  ClarityAbiTypeUInt128 = 1,\n  ClarityAbiTypeInt128 = 2,\n  ClarityAbiTypeBool = 3,\n  ClarityAbiTypePrincipal = 4,\n  ClarityAbiTypeNone = 5,\n  ClarityAbiTypeBuffer = 6,\n  ClarityAbiTypeResponse = 7,\n  ClarityAbiTypeOptional = 8,\n  ClarityAbiTypeTuple = 9,\n  ClarityAbiTypeList = 10,\n  ClarityAbiTypeStringAscii = 11,\n  ClarityAbiTypeStringUtf8 = 12,\n  ClarityAbiTypeTraitReference = 13,\n}\n\nexport const isClarityAbiPrimitive = (val: ClarityAbiType): val is ClarityAbiTypePrimitive =>\n  typeof val === 'string';\nexport const isClarityAbiBuffer = (val: ClarityAbiType): val is ClarityAbiTypeBuffer =>\n  (val as ClarityAbiTypeBuffer).buffer !== undefined;\nexport const isClarityAbiStringAscii = (val: ClarityAbiType): val is ClarityAbiTypeStringAscii =>\n  (val as ClarityAbiTypeStringAscii)['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = (val: ClarityAbiType): val is ClarityAbiTypeStringUtf8 =>\n  (val as ClarityAbiTypeStringUtf8)['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = (val: ClarityAbiType): val is ClarityAbiTypeResponse =>\n  (val as ClarityAbiTypeResponse).response !== undefined;\nexport const isClarityAbiOptional = (val: ClarityAbiType): val is ClarityAbiTypeOptional =>\n  (val as ClarityAbiTypeOptional).optional !== undefined;\nexport const isClarityAbiTuple = (val: ClarityAbiType): val is ClarityAbiTypeTuple =>\n  (val as ClarityAbiTypeTuple).tuple !== undefined;\nexport const isClarityAbiList = (val: ClarityAbiType): val is ClarityAbiTypeList =>\n  (val as ClarityAbiTypeList).list !== undefined;\n\nexport type ClarityAbiTypeUnion =\n  | { id: ClarityAbiTypeId.ClarityAbiTypeUInt128; type: ClarityAbiTypeUInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeInt128; type: ClarityAbiTypeInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBool; type: ClarityAbiTypeBool }\n  | { id: ClarityAbiTypeId.ClarityAbiTypePrincipal; type: ClarityAbiTypePrincipal }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference; type: ClarityAbiTypeTraitReference }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeNone; type: ClarityAbiTypeNone }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBuffer; type: ClarityAbiTypeBuffer }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeResponse; type: ClarityAbiTypeResponse }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeOptional; type: ClarityAbiTypeOptional }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTuple; type: ClarityAbiTypeTuple }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeList; type: ClarityAbiTypeList }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii; type: ClarityAbiTypeStringAscii }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8; type: ClarityAbiTypeStringUtf8 };\n\nexport function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };\n    } else if (val === 'int128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };\n    } else if (val === 'bool') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };\n    } else if (val === 'principal') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };\n    } else if (val === 'trait_reference') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };\n    } else if (val === 'none') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };\n  } else if (isClarityAbiResponse(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };\n  } else if (isClarityAbiOptional(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };\n  } else if (isClarityAbiTuple(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };\n  } else if (isClarityAbiList(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };\n  } else if (isClarityAbiStringAscii(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\nfunction encodeClarityValue(type: ClarityAbiType, val: string): ClarityValue;\nfunction encodeClarityValue(type: ClarityAbiTypeUnion, val: string): ClarityValue;\nfunction encodeClarityValue(\n  input: ClarityAbiTypeUnion | ClarityAbiType,\n  val: string\n): ClarityValue {\n  let union: ClarityAbiTypeUnion;\n  if ((input as ClarityAbiTypeUnion).id !== undefined) {\n    union = input as ClarityAbiTypeUnion;\n  } else {\n    union = getTypeUnion(input as ClarityAbiType);\n  }\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();\n      else if (val === 'true' || val === '1') return trueCV();\n      else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(Buffer.from(val, 'utf8'));\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\nexport { encodeClarityValue };\n\nexport function getTypeString(val: ClarityAbiType): string {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\n\nexport interface ClarityAbiFunction {\n  name: string;\n  access: 'private' | 'public' | 'read_only';\n  args: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  outputs: {\n    type: ClarityAbiType;\n  };\n}\n\nexport function abiFunctionToString(func: ClarityAbiFunction): string {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args\n    .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)\n    .join(' ')}))`;\n}\n\nexport interface ClarityAbiVariable {\n  name: string;\n  access: 'variable' | 'constant';\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbiMap {\n  name: string;\n  key: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  value: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n}\n\nexport interface ClarityAbiTypeFungibleToken {\n  name: string;\n}\n\nexport interface ClarityAbiTypeNonFungibleToken {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbi {\n  functions: ClarityAbiFunction[];\n  variables: ClarityAbiVariable[];\n  maps: ClarityAbiMap[];\n  fungible_tokens: ClarityAbiTypeFungibleToken[];\n  non_fungible_tokens: ClarityAbiTypeNonFungibleToken[];\n}\n\nfunction matchType(cv: ClarityValue, abiType: ClarityAbiType): boolean {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n    case ClarityType.Buffer:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&\n        union.type.buffer.length >= cv.buffer.length\n      );\n    case ClarityType.StringASCII:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&\n        union.type['string-ascii'].length >= cv.data.length\n      );\n    case ClarityType.StringUTF8:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&\n        union.type['string-utf8'].length >= cv.data.length\n      );\n    case ClarityType.OptionalNone:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional\n      );\n    case ClarityType.OptionalSome:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&\n        matchType(cv.value, union.type.optional)\n      );\n    case ClarityType.ResponseErr:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.error)\n      );\n    case ClarityType.ResponseOk:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.ok)\n      );\n    case ClarityType.PrincipalContract:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference\n      );\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n    case ClarityType.List:\n      return (\n        union.id == ClarityAbiTypeId.ClarityAbiTypeList &&\n        union.type.list.length === cv.list.length &&\n        cv.list.every(val => matchType(val, union.type.list.type))\n      );\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          // if key exists in cv tuple, check if its type matches the abi\n          // return false if key doesn't exist\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\n/**\n * Validates a contract-call payload with a contract ABI\n *\n * @param {ContractCallPayload} payload - a contract-call payload\n * @param {ClarityAbi} abi - a contract ABI\n *\n * @returns {boolean} true if the payloads functionArgs type check against those in the ABI\n */\nexport function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(\n        `Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`\n      );\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(\n          `Clarity function \\`${\n            payload.functionName.content\n          }\\` expects argument ${argNum} to be of type ${getTypeString(\n            abiArg.type\n          )}, not ${getCVTypeString(payloadArg)}`\n        );\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(\n      `Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`\n    );\n  }\n}\n\n/**\n * Convert string input to Clarity value based on contract ABI data. Only handles Clarity\n * primitives and buffers. Responses, optionals, tuples and lists are not supported.\n *\n * @param {string} input - string to be parsed into Clarity value\n * @param {ClarityAbiType} type - the contract function argument object\n *\n * @returns {ClarityValue} returns a Clarity value\n */\nexport function parseToCV(input: string, type: ClarityAbiType): ClarityValue {\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = Buffer.from(input).byteLength;\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n","import {\n  AnchorMode,\n  AuthType,\n  ChainID,\n  DEFAULT_CHAIN_ID,\n  PayloadType,\n  PostConditionMode,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  Authorization,\n  createMessageSignature,\n  createTransactionAuthField,\n  isSingleSig,\n  nextSignature,\n  SingleSigSpendingCondition,\n  SpendingCondition,\n} from './authorization';\n\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\n\nimport { deserializePayload, Payload, serializePayload } from './payload';\n\nimport { createLPList, deserializeLPList, LengthPrefixedList, serializeLPList } from './types';\n\nimport { isCompressed, StacksPrivateKey, StacksPublicKey } from './keys';\n\nimport { BufferReader } from './bufferReader';\n\nimport BigNum from 'bn.js';\nimport { SerializationError, SigningError } from './errors';\n\nexport class StacksTransaction {\n  version: TransactionVersion;\n  chainId: ChainID;\n  auth: Authorization;\n  anchorMode: AnchorMode;\n  payload: Payload;\n  postConditionMode: PostConditionMode;\n  postConditions: LengthPrefixedList;\n\n  constructor(\n    version: TransactionVersion,\n    auth: Authorization,\n    payload: Payload,\n    postConditions?: LengthPrefixedList,\n    postConditionMode?: PostConditionMode,\n    anchorMode?: AnchorMode,\n    chainId?: ChainID\n  ) {\n    this.version = version;\n    this.auth = auth;\n    this.payload = payload;\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorMode;\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.PoisonMicroblock: {\n          this.anchorMode = AnchorMode.OnChainOnly;\n          break;\n        }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.TokenTransfer: {\n          this.anchorMode = AnchorMode.Any;\n          break;\n        }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = tx.auth.intoInitialSighashAuth();\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = tx.auth.intoInitialSighashAuth();\n    return tx.txid();\n  }\n\n  createTxWithSignature(signature: string | Buffer): StacksTransaction {\n    const parsedSig = typeof signature === 'string' ? signature : signature.toString('hex');\n    const tx = cloneDeep(this);\n    if (!tx.auth.spendingCondition) {\n      throw new Error('Cannot set signature on transaction without spending condition');\n    }\n    (tx.auth.spendingCondition as SingleSigSpendingCondition).signature = createMessageSignature(\n      parsedSig\n    );\n    return tx;\n  }\n\n  verifyOrigin(): string {\n    return this.auth.verifyOrigin(this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.sponsorSpendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(\n      this.auth.sponsorSpendingCondition,\n      sigHash,\n      AuthType.Sponsored,\n      privateKey\n    );\n  }\n\n  appendPubkey(publicKey: StacksPublicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          publicKey\n        )\n      );\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(\n    condition: SpendingCondition,\n    curSigHash: string,\n    authType: AuthType,\n    privateKey: StacksPrivateKey\n  ): string {\n    const { nextSig, nextSigHash } = nextSignature(\n      curSigHash,\n      authType,\n      condition.fee,\n      condition.nonce,\n      privateKey\n    );\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = privateKey.data.toString('hex').endsWith('01');\n      condition.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          nextSig\n        )\n      );\n    }\n\n    return nextSigHash;\n  }\n\n  txid(): string {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingCondition) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth.setSponsor(sponsorSpendingCondition);\n  }\n\n  /**\n   * Set the total fee to be paid for this transaction\n   *\n   * @param {BigNum} fee - the fee amount in microstacks\n   */\n  setFee(amount: BigNum) {\n    this.auth.setFee(amount);\n  }\n\n  /**\n   * Set the transaction nonce\n   *\n   * @param {BigNum} nonce - the nonce value\n   */\n  setNonce(nonce: BigNum) {\n    this.auth.setNonce(nonce);\n  }\n\n  /**\n   * Set the transaction sponsor nonce\n   *\n   * @param {BigNum} nonce - the sponsor nonce value\n   */\n  setSponsorNonce(nonce: BigNum) {\n    this.auth.setSponsorNonce(nonce);\n  }\n\n  serialize(): Buffer {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bufferArray: BufferArray = new BufferArray();\n\n    bufferArray.appendByte(this.version);\n    const chainIdBuffer = Buffer.alloc(4);\n    chainIdBuffer.writeUInt32BE(this.chainId, 0);\n    bufferArray.push(chainIdBuffer);\n    bufferArray.push(this.auth.serialize());\n    bufferArray.appendByte(this.anchorMode);\n    bufferArray.appendByte(this.postConditionMode);\n    bufferArray.push(serializeLPList(this.postConditions));\n    bufferArray.push(serializePayload(this.payload));\n\n    return bufferArray.concatBuffer();\n  }\n}\n\n/**\n * @param data Buffer or hex string\n */\nexport function deserializeTransaction(data: BufferReader | Buffer | string) {\n  let bufferReader: BufferReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n    } else {\n      bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n    }\n  } else if (Buffer.isBuffer(data)) {\n    bufferReader = new BufferReader(data);\n  } else {\n    bufferReader = data;\n  }\n  const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bufferReader.readUInt32BE();\n  const auth = Authorization.deserialize(bufferReader);\n  const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bufferReader);\n\n  return new StacksTransaction(\n    version,\n    auth,\n    payload,\n    postConditions,\n    postConditionMode,\n    anchorMode,\n    chainId\n  );\n}\n","import { StacksTransaction } from './transaction';\n\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\nimport { isSingleSig } from './authorization';\nimport { cloneDeep } from './utils';\nimport { SpendingCondition } from './authorization';\nimport { AuthType } from './constants';\nimport { SigningError } from './errors';\n\nexport class TransactionSigner {\n  transaction: StacksTransaction;\n  sigHash: string;\n  originDone: boolean;\n  checkOversign: boolean;\n  checkOverlap: boolean;\n\n  constructor(transaction: StacksTransaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n  }\n\n  static createSponsorSigner(transaction: StacksTransaction, spendingCondition: SpendingCondition) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx: StacksTransaction = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey: StacksPrivateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n      if (\n        this.checkOversign &&\n        spendingCondition.fields.length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey: StacksPublicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey: StacksPrivateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.sponsorSpendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete(): StacksTransaction {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction: StacksTransaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}\n","import { StacksTransaction } from './transaction';\n\nimport { StacksNetwork, StacksMainnet, StacksTestnet } from '@stacks/network';\n\nimport {\n  createTokenTransferPayload,\n  createSmartContractPayload,\n  createContractCallPayload,\n} from './payload';\n\nimport {\n  StandardAuthorization,\n  SponsoredAuthorization,\n  createSingleSigSpendingCondition,\n  createMultiSigSpendingCondition,\n} from './authorization';\n\nimport {\n  publicKeyToString,\n  createStacksPrivateKey,\n  getPublicKey,\n  publicKeyToAddress,\n  pubKeyfromPrivKey,\n  publicKeyFromBuffer,\n} from './keys';\n\nimport { TransactionSigner } from './signer';\n\nimport {\n  PostCondition,\n  STXPostCondition,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  createSTXPostCondition,\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n} from './postcondition';\n\nimport {\n  AddressHashMode,\n  AddressVersion,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PostConditionMode,\n  PayloadType,\n  AnchorMode,\n  TransactionVersion,\n  TxRejectedReason,\n  SingleSigHashMode,\n} from './constants';\n\nimport { AssetInfo, createLPList, createStandardPrincipal, createContractPrincipal } from './types';\n\nimport { cvToHex, parseReadOnlyResponse, omit } from './utils';\n\nimport { fetchPrivate } from '@stacks/common';\n\nimport BigNum from 'bn.js';\nimport { ClarityValue, PrincipalCV } from './clarity';\nimport { validateContractCall, ClarityAbi } from './contract-abi';\nimport { c32address } from 'c32check';\n\n/**\n * Lookup the nonce for an address from a core node\n *\n * @param {string} address - the c32check address to look up\n * @param {StacksNetwork} network - the Stacks network to look up address on\n *\n * @return a promise that resolves to an integer\n */\nexport async function getNonce(address: string, network?: StacksNetwork): Promise<BigNum> {\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getAccountApiUrl(address)\n    : defaultNetwork.getAccountApiUrl(address);\n\n  const response = await fetchPrivate(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const result = (await response.json()) as { nonce: string };\n  return new BigNum(result.nonce);\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetwork\n): Promise<BigNum> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getTransferFeeEstimateApiUrl()\n    : defaultNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await fetchPrivate(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = new BigNum(transaction.serialize().byteLength);\n  const feeRate = new BigNum(feeRateResult);\n  return feeRate.mul(txBytes);\n}\n\nexport type TxBroadcastResultOk = string;\nexport type TxBroadcastResultRejected = {\n  error: string;\n  reason: TxRejectedReason;\n  reason_data: any;\n  txid: string;\n};\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network: StacksNetwork,\n  attachment?: Buffer\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const url = network.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url, attachment);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Buffer} rawTx - the raw serialized transaction buffer to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Buffer,\n  url: string,\n  attachment?: Buffer\n): Promise<TxBroadcastResult> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n    body: attachment\n      ? JSON.stringify({\n          tx: rawTx.toString('hex'),\n          attachment: attachment.toString('hex'),\n        })\n      : rawTx,\n  };\n\n  const response = await fetchPrivate(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  try {\n    return JSON.parse(text) as TxBroadcastResult;\n  } catch (e) {\n    return text;\n  }\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const url = network.getAbiApiUrl(address, contractName);\n\n  const response = await fetchPrivate(url, options);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\n/**\n * STX token transfer transaction options\n *\n * @param  {String|PrincipalCV} recipientAddress - the c32check address of the recipient or a\n *                                                  principal clarity value\n * @param  {BigNum} amount - number of tokens to transfer in microstacks\n * @param  {BigNum} fee - transaction fee in microstacks\n * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {anchorMode} anchorMode - identify how the the transaction should be mined\n * @param  {String} memo - an arbitrary string to include with the transaction, must be less than\n *                          34 bytes\n * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all\n *                                                 transferred assets\n * @param  {PostCondition[]} postConditions - an array of post conditions to add to the\n *                                                  transaction\n * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees\n */\nexport interface TokenTransferOptions {\n  recipient: string | PrincipalCV;\n  amount: BigNum;\n  fee?: BigNum;\n  nonce?: BigNum;\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  memo?: string;\n  postConditionMode?: PostConditionMode;\n  postConditions?: PostCondition[];\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param  {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promis<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    nonce: new BigNum(0),\n    network: new StacksMainnet(),\n    anchorMode: AnchorMode.Any,\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization = null;\n  let spendingCondition = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    options.network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    defaultOptions.anchorMode,\n    options.network.chainId\n  );\n\n  if (!txOptions.fee) {\n    const txFee = await estimateTransfer(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (!txOptions.nonce) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param  {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n *\n * @param  {String} contractName - the contract name\n * @param  {String} codeBody - the code body string\n * @param  {String} senderKey - hex string sender private key used to sign transaction\n * @param  {BigNum} fee - transaction fee in microstacks\n * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {anchorMode} anchorMode - identify how the the transaction should be mined\n * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all\n *                                                 transferred assets\n * @param  {PostCondition[]} postConditions - an array of post conditions to add to the\n *                                                  transaction\n * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees\n */\nexport interface ContractDeployOptions {\n  contractName: string;\n  codeBody: string;\n  senderKey: string;\n  fee?: BigNum;\n  nonce?: BigNum;\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  postConditionMode?: PostConditionMode;\n  postConditions?: PostCondition[];\n  sponsored?: boolean;\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetwork\n): Promise<BigNum> {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getTransferFeeEstimateApiUrl()\n    : defaultNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await fetchPrivate(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = new BigNum(transaction.serialize().byteLength);\n  const feeRate = new BigNum(feeRateResult);\n  return feeRate.mul(txBytes);\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param  {ContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: ContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    nonce: new BigNum(0),\n    network: new StacksMainnet(),\n    anchorMode: AnchorMode.Any,\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(options.contractName, options.codeBody);\n\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const privKey = createStacksPrivateKey(options.senderKey);\n  const pubKey = getPublicKey(privKey);\n\n  let authorization = null;\n\n  const spendingCondition = createSingleSigSpendingCondition(\n    addressHashMode,\n    publicKeyToString(pubKey),\n    options.nonce,\n    options.fee\n  );\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    options.network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    options.network.chainId\n  );\n\n  if (!txOptions.fee) {\n    const txFee = await estimateContractDeploy(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (!txOptions.nonce) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  if (options.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n * @param  {String} contractAddress - the c32check address of the contract\n * @param  {String} contractName - the contract name\n * @param  {String} functionName - name of the function to be called\n * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param  {String} senderKey - hex string sender private key used to sign transaction\n * @param  {BigNum} fee - transaction fee in microstacks\n * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {anchorMode} anchorMode - identify how the the transaction should be mined\n * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all\n *                                                 transferred assets\n * @param  {PostCondition[]} postConditions - an array of post conditions to add to the\n *                                                  transaction\n * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees\n */\nexport interface ContractCallOptions {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  fee?: BigNum;\n  feeEstimateApiUrl?: string;\n  nonce?: BigNum;\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  postConditionMode?: PostConditionMode;\n  postConditions?: PostCondition[];\n  validateWithAbi?: boolean | ClarityAbi;\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetwork\n): Promise<BigNum> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getTransferFeeEstimateApiUrl()\n    : defaultNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await fetchPrivate(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = new BigNum(transaction.serialize().byteLength);\n  const feeRate = new BigNum(feeRateResult);\n  return feeRate.mul(txBytes);\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    nonce: new BigNum(0),\n    network: new StacksMainnet(),\n    anchorMode: AnchorMode.Any,\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition = null;\n  let authorization = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    options.network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    options.network.chainId\n  );\n\n  if (!txOptions.fee) {\n    const txFee = await estimateContractFunctionCall(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (!txOptions.nonce) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param  {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of STX tokens\n *\n * @return {STXPostCondition}\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param  {String} address - the c32check address of the contract\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of STX tokens\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of fungible tokens\n * @param  {AssetInfo} assetInfo - asset info describing the fungible token\n *\n * @return {FungiblePostCondition}\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of fungible tokens\n * @param  {AssetInfo} assetInfo - asset info describing the fungible token\n *\n * @return {FungiblePostCondition}\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Read only function options\n *\n * @param  {String} contractAddress - the c32check address of the contract\n * @param  {String} contractName - the contract name\n * @param  {String} functionName - name of the function to be called\n * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  network?: StacksNetwork;\n  senderAddress: string;\n}\n\n/**\n * Calls a read only function from a contract interface\n *\n * @param  {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const {\n    contractName,\n    contractAddress,\n    functionName,\n    functionArgs,\n    network,\n    senderAddress,\n  } = options;\n\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await fetchPrivate(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\n/**\n * Sponsored transaction options\n *\n * @param  {StacksTransaction} transaction - the origin-signed transaction to sponsor\n * @param  {String} sponsorPrivateKey - the sponsor's private key\n * @param  {BigNum} fee - the transaction fee amount to sponsor\n * @param  {BigNum} sponsorNonce - the nonce of the sponsor account\n * @param  {AddressHashMode} sponsorAddressHashmode - the sponsor address hashmode\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n */\nexport interface SponsorOptions {\n  transaction: StacksTransaction;\n  sponsorPrivateKey: string;\n  fee?: BigNum;\n  sponsorNonce?: BigNum;\n  sponsorAddressHashmode?: AddressHashMode;\n  network?: StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param  {SponsorOptions} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    sponsorNonce: new BigNum(0),\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n  const network =\n    sponsorOptions.network ??\n    (options.transaction.version === TransactionVersion.Mainnet\n      ? new StacksMainnet()\n      : new StacksTestnet());\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (!sponsorOptions.fee) {\n    let txFee = new BigNum(0);\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n        txFee = await estimateTransfer(options.transaction, network);\n        break;\n      case PayloadType.SmartContract:\n        txFee = await estimateContractDeploy(options.transaction, network);\n        break;\n      case PayloadType.ContractCall:\n        txFee = await estimateContractFunctionCall(options.transaction, network);\n        break;\n      default:\n        throw new Error(\n          `Sponsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (!sponsorOptions.sponsorNonce) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return options.transaction;\n}\n"],"names":["ChainID","StacksMessageType","PayloadType","AnchorMode","TransactionVersion","DEFAULT_CHAIN_ID","Mainnet","PostConditionMode","PostConditionType","AuthType","AddressHashMode","AddressVersion","PubKeyEncoding","FungibleConditionCode","NonFungibleConditionCode","PostConditionPrincipalID","AssetType","TxRejectedReason","DEFAULT_TRANSACTION_VERSION","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","getAddressFromPublicKey","publicKey","transactionVersion","addressToString","addressFromVersionHash","addressHashModeToVersion","SerializeP2PKH","hashP2PKH","Buffer","from","createStacksPublicKey","PublicKey","data","publicKeyFromSignature","message","messageSignature","pubKeyEncoding","Compressed","ec","EC","messageBN","keyFromPrivate","getPrivate","parsedSignature","parseRecoverableSignature","recoverPubKey","recoveryParam","Uncompressed","encode","encodeCompressed","publicKeyFromBuffer","isCompressed","startsWith","publicKeyToString","serializePublicKey","bufferArray","BufferArray","concatBuffer","pubKeyfromPrivKey","privateKey","privKey","createStacksPrivateKey","getPublic","compressed","compressPublicKey","keyFromPublic","deserializePublicKey","bufferReader","fieldId","readUInt8","keyLength","concat","readBuffer","signWithKey","input","signature","sign","canonical","r","leftPadHexToLength","coordinateValueBytes","s","createMessageSignature","intToHexString","recoveryParamHex","substr","hexStringToInt","getPublicKey","publicKeyToAddress","version","c32address","hash160","ClarityType","SerializationError","_this2","captureStackTrace","DeserializationError","_this3","NotImplementedError","_this4","SigningError","_this5","createSTXPostCondition","principal","conditionCode","amount","parsePrincipalString","PostCondition","conditionType","STX","createFungiblePostCondition","assetInfo","parseAssetInfoString","Fungible","createNonFungiblePostCondition","assetName","NonFungible","serializePostCondition","postCondition","appendByte","serializePrincipal","serializeAssetInfo","serializeCV","toArrayLike","deserializePostCondition","postConditionType","readUInt8Enum","n","deserializePrincipal","BigNum","deserializeAssetInfo","deserializeCV","createTokenTransferPayload","recipient","memo","includes","split","contractPrincipalCV","standardPrincipalCV","principalCV","createMemoString","Payload","payloadType","TokenTransfer","createContractCallPayload","contractAddress","contractName","functionName","functionArgs","createAddress","createLPString","ContractCall","createSmartContractPayload","codeBody","codeBodyString","SmartContract","serializePayload","payload","serializeStacksMessage","numArgs","alloc","writeUInt32BE","PoisonMicroblock","Coinbase","coinbaseBuffer","deserializePayload","deserializeMemoString","deserializeAddress","contractCallName","deserializeLPString","numberOfArgs","readUInt32BE","clarityValue","byteLength","createCoinbasePayload","Address","serializeAddress","Principal","LengthPrefixedString","serializeLPString","MemoString","serializeMemoString","AssetInfo","LengthPrefixedList","serializeLPList","TransactionAuthField","serializeTransactionAuthField","MessageSignature","serializeMessageSignature","c32AddressString","addressData","c32addressDecode","createEmptyAddress","MainnetSingleSig","repeat","hash","hashMode","txVersion","Testnet","TestnetSingleSig","JSON","stringify","SerializeP2SH","SerializeP2WPKH","SerializeP2WSH","MainnetMultiSig","TestnetMultiSig","addressFromPublicKeys","numSigs","publicKeys","hashP2SH","map","address","appendHexString","principalString","createContractPrincipal","createStandardPrincipal","addressString","addr","prefix","Standard","Contract","_","content","lengthPrefixBytes","maxLengthBytes","prefixLength","maxLength","exceedsMaxLengthBytes","lps","contentBuffer","prefixBytes","memoString","paddedContent","rightPadHexToLength","MEMO_MAX_LENGTH_BYTES","id","createAssetInfo","createLPList","lpList","list","index","deserializeLPList","l","deserializeTransactionAuthField","principalToString","PrincipalStandard","PrincipalContract","standardPrincipalCVFromAddress","contractPrincipalCVFromAddress","cvToValue","val","BoolTrue","BoolFalse","Int","fromTwos","toNumber","UInt","buffer","OptionalNone","OptionalSome","ResponseErr","ResponseOk","cvToJSON","List","v","Tuple","StringASCII","StringUTF8","getCVTypeString","success","join","trueCV","falseCV","intCV","twos","toTwos","bitLength","uintCV","isNeg","bufferCV","bufferCVFromString","str","noneCV","someCV","responseErrorCV","responseOkCV","listCV","tupleCV","isClarityName","stringAsciiCV","stringUtf8CV","bufferWithTypeID","typeId","serializeStringCV","cv","encoding","buffers","len","serializeBoolCV","serializeBufferCV","serializeIntCV","serializeStandardPrincipalCV","serializeContractPrincipalCV","serializeResponseCV","serializedValue","serializeListCV","sort","a","b","bufA","bufB","compare","nameWithLength","serializeTupleCV","serializeStringAsciiCV","serializeStringUtf8CV","enumCheckFunctions","Map","BufferReader","options","smartBuffer","isBuffer","SmartBuffer","buff","fromBuffer","offset","readUInt16BE","readBigUIntLE","hex","BigInt","readBigUIntBE","readBigUInt64BE","readString","enumVariable","invalidEnumErrorFormatter","num","isEnum","checker","get","newChecker","enumValues","filter","enumValueSet","Set","has","createEnumChecker","set","readOffset","internalBuffer","bufferLength","listLength","listContents","tupleLength","tupleContents","clarityName","asciiStrLen","asciiStr","utf8StrLen","utf8Str","hexString","_value","octet","Number","isInteger","leftPadHex","padStart","padEnd","integer","lengthBytes","parseInt","string","cloneDeep","lodashCloneDeep","omit","prop","clone","sha512_256","assign","_ah","_al","_bh","_bl","_ch","_cl","_dh","_dl","_eh","_el","_fh","_fl","_gh","_gl","_hh","_hl","digest","_sha","sha512","txidFromData","update","sha256Result","sha256","RIPEMD160","pubKeys","pubKey","redeemScript","test","init","fetchOpts","referrer","referrerPolicy","fetch","cvToHex","hexToCV","hexWithoutPrefix","AuthFieldType","parseReadOnlyResponse","response","okay","cause","Deserializable","deserialize","emptyMessageSignature","deserializeMessageSignature","createTransactionAuthField","contents","field","PublicKeyCompressed","PublicKeyUncompressed","SignatureCompressed","SignatureUncompressed","authFieldType","createSingleSigSpendingCondition","nonce","fee","signer","keyEncoding","createMultiSigSpendingCondition","fields","signaturesRequired","isSingleSig","condition","clearCondition","cloned","serializeSingleSigSpendingCondition","serializeMultiSigSpendingCondition","writeUInt16BE","deserializeSingleSigSpendingCondition","deserializeMultiSigSpendingCondition","serializeSpendingCondition","deserializeSpendingCondition","makeSigHashPreSign","curSigHash","authType","sigHash","makeSigHashPostSign","sigHashBuffer","nextSignature","sigHashPreSign","nextSig","nextSigHash","nextVerification","initialSigHash","ClarityAbiTypeId","Authorization","spendingConditions","sponsorSpendingCondition","spendingCondition","intoInitialSighashAuth","Sponsored","setFee","getFee","setNonce","setSponsorNonce","setSponsor","verifyOrigin","verifySingleSig","verify","serialize","StandardAuthorization","_Authorization","SponsoredAuthorization","originSpendingCondition","sponsorSC","_Authorization2","StacksTransaction","auth","postConditions","postConditionMode","anchorMode","chainId","Deny","OnChainOnly","Any","signBegin","tx","txid","verifyBegin","createTxWithSignature","parsedSig","signNextOrigin","signAndAppend","signNextSponsor","appendPubkey","cond","endsWith","serialized","chainIdBuffer","TransactionSigner","transaction","originDone","checkOversign","checkOverlap","createSponsorSigner","originSigHash","signOrigin","nextSighash","appendOrigin","signSponsor","getTxInComplete","resume","isClarityAbiPrimitive","isClarityAbiBuffer","isClarityAbiStringAscii","isClarityAbiStringUtf8","isClarityAbiResponse","isClarityAbiOptional","optional","isClarityAbiTuple","tuple","isClarityAbiList","getTypeUnion","ClarityAbiTypeUInt128","ClarityAbiTypeInt128","ClarityAbiTypeBool","ClarityAbiTypePrincipal","ClarityAbiTypeTraitReference","ClarityAbiTypeNone","ClarityAbiTypeBuffer","ClarityAbiTypeResponse","ClarityAbiTypeOptional","ClarityAbiTypeTuple","ClarityAbiTypeList","ClarityAbiTypeStringAscii","ClarityAbiTypeStringUtf8","getTypeString","ok","t","matchType","abiType","union","every","abiTupleEntry","validateContractCall","abi","filtered","functions","abiArgs","args","payloadArg","abiArg","getNonce","network","defaultNetwork","StacksMainnet","url","getAccountApiUrl","fetchPrivate","msg","text","status","statusText","json","estimateTransfer","fetchOptions","headers","Accept","getTransferFeeEstimateApiUrl","feeRateResult","txBytes","feeRate","mul","attachment","rawTx","getBroadcastApiUrl","broadcastRawTransaction","body","_context4","parse","getAbi","getAbiApiUrl","makeUnsignedSTXTokenTransfer","txOptions","defaultOptions","sponsored","numSignatures","authorization","lpPostConditions","addressVersion","senderAddress","senderKey","pk","signerKeys","estimateContractDeploy","addressHashMode","estimateContractFunctionCall","makeUnsignedContractCall","validateWithAbi","readOnlyFunctionOptions","getReadOnlyFunctionCallApiUrl","sender","arguments","responseJson","sponsorOptions","sponsorNonce","sponsorAddressHashmode","StacksTestnet","sponsorPubKey","sponsorPrivateKey","txFee","func","access","sp","lengthPrefixedContractName","cvToString","listType","toLowerCase","entropy","randomBytes","genKeyPair","typeString","stacksAddress","e"],"mappings":"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"}