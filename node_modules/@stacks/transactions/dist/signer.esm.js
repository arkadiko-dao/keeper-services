import { AuthType } from './constants.esm.js';
import { SigningError } from './errors.esm.js';
import { cloneDeep } from './utils.esm.js';
import { isSingleSig } from './authorization.esm.js';

var TransactionSigner = /*#__PURE__*/function () {
  function TransactionSigner(transaction) {
    this.transaction = transaction;
    this.sigHash = transaction.signBegin();
    this.originDone = false;
    this.checkOversign = true;
    this.checkOverlap = true;
  }

  TransactionSigner.createSponsorSigner = function createSponsorSigner(transaction, spendingCondition) {
    if (transaction.auth.authType != AuthType.Sponsored) {
      throw new SigningError('Cannot add sponsor to non-sponsored transaction');
    }

    var tx = cloneDeep(transaction);
    tx.setSponsor(spendingCondition);
    var originSigHash = tx.verifyOrigin();
    var signer = new this(tx);
    signer.originDone = true;
    signer.sigHash = originSigHash;
    signer.checkOversign = true;
    signer.checkOverlap = true;
    return signer;
  };

  var _proto = TransactionSigner.prototype;

  _proto.signOrigin = function signOrigin(privateKey) {
    if (this.checkOverlap && this.originDone) {
      throw new SigningError('Cannot sign origin after sponsor key');
    }

    if (this.transaction.auth === undefined) {
      throw new SigningError('"transaction.auth" is undefined');
    }

    if (this.transaction.auth.spendingCondition === undefined) {
      throw new SigningError('"transaction.auth.spendingCondition" is undefined');
    }

    if (!isSingleSig(this.transaction.auth.spendingCondition)) {
      var spendingCondition = this.transaction.auth.spendingCondition;

      if (this.checkOversign && spendingCondition.fields.length >= spendingCondition.signaturesRequired) {
        throw new Error('Origin would have too many signatures');
      }
    }

    var nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);
    this.sigHash = nextSighash;
  };

  _proto.appendOrigin = function appendOrigin(publicKey) {
    if (this.checkOverlap && this.originDone) {
      throw Error('Cannot append public key to origin after sponsor key');
    }

    if (this.transaction.auth === undefined) {
      throw new Error('"transaction.auth" is undefined');
    }

    if (this.transaction.auth.spendingCondition === undefined) {
      throw new Error('"transaction.auth.spendingCondition" is undefined');
    }

    this.transaction.appendPubkey(publicKey);
  };

  _proto.signSponsor = function signSponsor(privateKey) {
    if (this.transaction.auth === undefined) {
      throw new SigningError('"transaction.auth" is undefined');
    }

    if (this.transaction.auth.sponsorSpendingCondition === undefined) {
      throw new SigningError('"transaction.auth.spendingCondition" is undefined');
    }

    var nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);
    this.sigHash = nextSighash;
    this.originDone = true;
  };

  _proto.getTxInComplete = function getTxInComplete() {
    return cloneDeep(this.transaction);
  };

  _proto.resume = function resume(transaction) {
    this.transaction = cloneDeep(transaction);
    this.sigHash = transaction.signBegin();
  };

  return TransactionSigner;
}();

export { TransactionSigner };
//# sourceMappingURL=signer.esm.js.map
