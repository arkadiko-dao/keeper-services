import 'sha.js';
import 'c32check';
import { DeserializationError } from '../errors.esm.js';
import { deserializeLPString, deserializeAddress } from '../types.esm.js';
import { contractPrincipalCVFromAddress, standardPrincipalCVFromAddress } from './types/principalCV.esm.js';
import { ClarityType } from './clarityValue.esm.js';
import { falseCV, trueCV } from './types/booleanCV.esm.js';
import { uintCV, intCV } from './types/intCV.esm.js';
import { bufferCV } from './types/bufferCV.esm.js';
import { someCV, noneCV } from './types/optionalCV.esm.js';
import { responseErrorCV, responseOkCV } from './types/responseCV.esm.js';
import { listCV } from './types/listCV.esm.js';
import { tupleCV } from './types/tupleCV.esm.js';
import { stringUtf8CV, stringAsciiCV } from './types/stringCV.esm.js';
import { BufferReader } from '../bufferReader.esm.js';
import 'ripemd160-min';
import 'randombytes';
import 'cross-fetch';
import 'lodash-es/cloneDeep';

function deserializeCV(buffer) {
  var bufferReader = Buffer.isBuffer(buffer) ? new BufferReader(buffer) : buffer;
  var type = bufferReader.readUInt8Enum(ClarityType, function (n) {
    throw new DeserializationError("Cannot recognize Clarity Type: " + n);
  });

  switch (type) {
    case ClarityType.Int:
      return intCV(bufferReader.readBuffer(16));

    case ClarityType.UInt:
      return uintCV(bufferReader.readBuffer(16));

    case ClarityType.Buffer:
      var bufferLength = bufferReader.readUInt32BE();
      return bufferCV(bufferReader.readBuffer(bufferLength));

    case ClarityType.BoolTrue:
      return trueCV();

    case ClarityType.BoolFalse:
      return falseCV();

    case ClarityType.PrincipalStandard:
      var sAddress = deserializeAddress(bufferReader);
      return standardPrincipalCVFromAddress(sAddress);

    case ClarityType.PrincipalContract:
      var cAddress = deserializeAddress(bufferReader);
      var contractName = deserializeLPString(bufferReader);
      return contractPrincipalCVFromAddress(cAddress, contractName);

    case ClarityType.ResponseOk:
      return responseOkCV(deserializeCV(bufferReader));

    case ClarityType.ResponseErr:
      return responseErrorCV(deserializeCV(bufferReader));

    case ClarityType.OptionalNone:
      return noneCV();

    case ClarityType.OptionalSome:
      return someCV(deserializeCV(bufferReader));

    case ClarityType.List:
      var listLength = bufferReader.readUInt32BE();
      var listContents = [];

      for (var i = 0; i < listLength; i++) {
        listContents.push(deserializeCV(bufferReader));
      }

      return listCV(listContents);

    case ClarityType.Tuple:
      var tupleLength = bufferReader.readUInt32BE();
      var tupleContents = {};

      for (var _i = 0; _i < tupleLength; _i++) {
        var clarityName = deserializeLPString(bufferReader).content;

        if (clarityName === undefined) {
          throw new DeserializationError('"content" is undefined');
        }

        tupleContents[clarityName] = deserializeCV(bufferReader);
      }

      return tupleCV(tupleContents);

    case ClarityType.StringASCII:
      var asciiStrLen = bufferReader.readUInt32BE();
      var asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');
      return stringAsciiCV(asciiStr);

    case ClarityType.StringUTF8:
      var utf8StrLen = bufferReader.readUInt32BE();
      var utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');
      return stringUtf8CV(utf8Str);

    default:
      throw new DeserializationError('Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.');
  }
}

export default deserializeCV;
//# sourceMappingURL=deserialize.esm.js.map
