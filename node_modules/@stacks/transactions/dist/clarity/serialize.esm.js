import '../constants.esm.js';
import { createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';
import 'bn.js';
import { SerializationError } from '../errors.esm.js';
import { serializeAddress, serializeLPString, createLPString } from '../types.esm.js';
import { ClarityType } from './clarityValue.esm.js';
import 'smart-buffer';
import { BufferArray } from '../utils.esm.js';

function bufferWithTypeID(typeId, buffer) {
  var id = Buffer.from([typeId]);
  return Buffer.concat([id, buffer]);
}

function serializeBoolCV(value) {
  return Buffer.from([value.type]);
}

function serializeOptionalCV(cv) {
  if (cv.type === ClarityType.OptionalNone) {
    return Buffer.from([cv.type]);
  } else {
    return bufferWithTypeID(cv.type, serializeCV(cv.value));
  }
}

function serializeBufferCV(cv) {
  var length = Buffer.alloc(4);
  length.writeUInt32BE(cv.buffer.length, 0);
  return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));
}

function serializeIntCV(cv) {
  var buffer = cv.value.toArrayLike(Buffer, 'be', 16);
  return bufferWithTypeID(cv.type, buffer);
}

function serializeStandardPrincipalCV(cv) {
  return bufferWithTypeID(cv.type, serializeAddress(cv.address));
}

function serializeContractPrincipalCV(cv) {
  return bufferWithTypeID(cv.type, Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)]));
}

function serializeResponseCV(cv) {
  return bufferWithTypeID(cv.type, serializeCV(cv.value));
}

function serializeListCV(cv) {
  var buffers = new BufferArray();
  var length = Buffer.alloc(4);
  length.writeUInt32BE(cv.list.length, 0);
  buffers.push(length);

  for (var _iterator = _createForOfIteratorHelperLoose(cv.list), _step; !(_step = _iterator()).done;) {
    var value = _step.value;
    var serializedValue = serializeCV(value);
    buffers.push(serializedValue);
  }

  return bufferWithTypeID(cv.type, buffers.concatBuffer());
}

function serializeTupleCV(cv) {
  var buffers = new BufferArray();
  var length = Buffer.alloc(4);
  length.writeUInt32BE(Object.keys(cv.data).length, 0);
  buffers.push(length);
  var lexicographicOrder = Object.keys(cv.data).sort(function (a, b) {
    var bufA = Buffer.from(a);
    var bufB = Buffer.from(b);
    return bufA.compare(bufB);
  });

  for (var _iterator2 = _createForOfIteratorHelperLoose(lexicographicOrder), _step2; !(_step2 = _iterator2()).done;) {
    var key = _step2.value;
    var nameWithLength = createLPString(key);
    buffers.push(serializeLPString(nameWithLength));
    var serializedValue = serializeCV(cv.data[key]);
    buffers.push(serializedValue);
  }

  return bufferWithTypeID(cv.type, buffers.concatBuffer());
}

function serializeStringCV(cv, encoding) {
  var buffers = new BufferArray();
  var str = Buffer.from(cv.data, encoding);
  var len = Buffer.alloc(4);
  len.writeUInt32BE(str.length, 0);
  buffers.push(len);
  buffers.push(str);
  return bufferWithTypeID(cv.type, buffers.concatBuffer());
}

function serializeStringAsciiCV(cv) {
  return serializeStringCV(cv, 'ascii');
}

function serializeStringUtf8CV(cv) {
  return serializeStringCV(cv, 'utf8');
}

function serializeCV(value) {
  switch (value.type) {
    case ClarityType.BoolTrue:
    case ClarityType.BoolFalse:
      return serializeBoolCV(value);

    case ClarityType.OptionalNone:
    case ClarityType.OptionalSome:
      return serializeOptionalCV(value);

    case ClarityType.Buffer:
      return serializeBufferCV(value);

    case ClarityType.Int:
    case ClarityType.UInt:
      return serializeIntCV(value);

    case ClarityType.PrincipalStandard:
      return serializeStandardPrincipalCV(value);

    case ClarityType.PrincipalContract:
      return serializeContractPrincipalCV(value);

    case ClarityType.ResponseOk:
    case ClarityType.ResponseErr:
      return serializeResponseCV(value);

    case ClarityType.List:
      return serializeListCV(value);

    case ClarityType.Tuple:
      return serializeTupleCV(value);

    case ClarityType.StringASCII:
      return serializeStringAsciiCV(value);

    case ClarityType.StringUTF8:
      return serializeStringUtf8CV(value);

    default:
      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');
  }
}

export { serializeCV };
//# sourceMappingURL=serialize.esm.js.map
