import { StacksMessageType, PubKeyEncoding, AddressHashMode, COMPRESSED_PUBKEY_LENGTH_BYTES, UNCOMPRESSED_PUBKEY_LENGTH_BYTES, TransactionVersion } from './constants.esm.js';
import { ec } from 'elliptic';
import { c32address } from 'c32check';
import { addressHashModeToVersion, addressFromVersionHash, addressToString } from './types.esm.js';
import randomBytes from 'randombytes';
import { hashP2PKH, hexStringToInt, leftPadHexToLength, intToHexString, hash160, BufferArray } from './utils.esm.js';
import { createMessageSignature } from './authorization.esm.js';

function getAddressFromPrivateKey(privateKey, transactionVersion) {
  if (transactionVersion === void 0) {
    transactionVersion = TransactionVersion.Mainnet;
  }

  var pubKey = pubKeyfromPrivKey(privateKey);
  return getAddressFromPublicKey(pubKey.data, transactionVersion);
}
function getAddressFromPublicKey(publicKey, transactionVersion) {
  if (transactionVersion === void 0) {
    transactionVersion = TransactionVersion.Mainnet;
  }

  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');
  var addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);
  var addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));
  var addrString = addressToString(addr);
  return addrString;
}
function createStacksPublicKey(key) {
  return {
    type: StacksMessageType.PublicKey,
    data: Buffer.from(key, 'hex')
  };
}
function publicKeyFromSignature(message, messageSignature, pubKeyEncoding) {
  if (pubKeyEncoding === void 0) {
    pubKeyEncoding = PubKeyEncoding.Compressed;
  }

  var ec$1 = new ec('secp256k1');
  var messageBN = ec$1.keyFromPrivate(message, 'hex').getPrivate().toString(10);
  var parsedSignature = parseRecoverableSignature(messageSignature.data);
  var publicKey = ec$1.recoverPubKey(messageBN, parsedSignature, parsedSignature.recoveryParam, 'hex');

  if (pubKeyEncoding == PubKeyEncoding.Uncompressed) {
    return publicKey.encode('hex');
  }

  return publicKey.encodeCompressed('hex');
}
function publicKeyFromBuffer(data) {
  return {
    type: StacksMessageType.PublicKey,
    data: data
  };
}
function isCompressed(key) {
  return !key.data.toString('hex').startsWith('04');
}
function publicKeyToString(key) {
  return key.data.toString('hex');
}
function serializePublicKey(key) {
  var bufferArray = new BufferArray();
  bufferArray.push(key.data);
  return bufferArray.concatBuffer();
}
function pubKeyfromPrivKey(privateKey) {
  var privKey = createStacksPrivateKey(privateKey);
  var ec$1 = new ec('secp256k1');
  var keyPair = ec$1.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');
  var pubKey = keyPair.getPublic(privKey.compressed, 'hex');
  return createStacksPublicKey(pubKey);
}
function compressPublicKey(publicKey) {
  var ec$1 = new ec('secp256k1');
  var key = ec$1.keyFromPublic(publicKey);
  var pubKey = key.getPublic(true, 'hex');
  return createStacksPublicKey(pubKey);
}
function deserializePublicKey(bufferReader) {
  var fieldId = bufferReader.readUInt8();
  var keyLength = fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
  return publicKeyFromBuffer(Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)]));
}
function createStacksPrivateKey(key) {
  var data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;
  var compressed;

  if (data.length === 33) {
    if (data[data.length - 1] !== 1) {
      throw new Error('Improperly formatted private-key. 33 byte length usually ' + 'indicates compressed key, but last byte must be == 0x01');
    }

    compressed = true;
  } else if (data.length === 32) {
    compressed = false;
  } else {
    throw new Error("Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length " + data.length);
  }

  return {
    data: data,
    compressed: compressed
  };
}
function makeRandomPrivKey(entropy) {
  var ec$1 = new ec('secp256k1');
  var options = {
    entropy: entropy || randomBytes(32)
  };
  var keyPair = ec$1.genKeyPair(options);
  var privateKey = keyPair.getPrivate().toString('hex', 32);
  return createStacksPrivateKey(privateKey);
}
function signWithKey(privateKey, input) {
  var ec$1 = new ec('secp256k1');
  var key = ec$1.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');
  var signature = key.sign(input, 'hex', {
    canonical: true
  });
  var coordinateValueBytes = 32;
  var r = leftPadHexToLength(signature.r.toString('hex'), coordinateValueBytes * 2);
  var s = leftPadHexToLength(signature.s.toString('hex'), coordinateValueBytes * 2);

  if (signature.recoveryParam === undefined || signature.recoveryParam === null) {
    throw new Error('"signature.recoveryParam" is not set');
  }

  var recoveryParam = intToHexString(signature.recoveryParam, 1);
  var recoverableSignatureString = recoveryParam + r + s;
  return createMessageSignature(recoverableSignatureString);
}
function getSignatureRecoveryParam(signature) {
  var coordinateValueBytes = 32;

  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {
    throw new Error('Invalid signature');
  }

  var recoveryParamHex = signature.substr(0, 2);
  return hexStringToInt(recoveryParamHex);
}
function parseRecoverableSignature(signature) {
  var coordinateValueBytes = 32;

  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {
    throw new Error('Invalid signature');
  }

  var recoveryParamHex = signature.substr(0, 2);
  var r = signature.substr(2, coordinateValueBytes * 2);
  var s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);
  return {
    recoveryParam: hexStringToInt(recoveryParamHex),
    r: r,
    s: s
  };
}
function getPublicKey(privateKey) {
  return pubKeyfromPrivKey(privateKey.data);
}
function privateKeyToString(privateKey) {
  return privateKey.data.toString('hex');
}
function publicKeyToAddress(version, publicKey) {
  return c32address(version, hash160(publicKey.data).toString('hex'));
}

export { compressPublicKey, createStacksPrivateKey, createStacksPublicKey, deserializePublicKey, getAddressFromPrivateKey, getAddressFromPublicKey, getPublicKey, getSignatureRecoveryParam, isCompressed, makeRandomPrivKey, parseRecoverableSignature, privateKeyToString, pubKeyfromPrivKey, publicKeyFromBuffer, publicKeyFromSignature, publicKeyToAddress, publicKeyToString, serializePublicKey, signWithKey };
//# sourceMappingURL=keys.esm.js.map
