import { AuthType, PubKeyEncoding, TransactionVersion, AnchorMode, PostConditionMode, StacksMessageType, DEFAULT_CHAIN_ID, PayloadType } from './constants.esm.js';
import { isCompressed } from './keys.esm.js';
import { SigningError, SerializationError } from './errors.esm.js';
import { serializePayload, deserializePayload } from './payload.esm.js';
import { serializeLPList, deserializeLPList, createLPList } from './types.esm.js';
import { BufferReader } from './bufferReader.esm.js';
import { cloneDeep, txidFromData, BufferArray } from './utils.esm.js';
import { createMessageSignature, isSingleSig, createTransactionAuthField, nextSignature, Authorization } from './authorization.esm.js';

var StacksTransaction = /*#__PURE__*/function () {
  function StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {
    this.version = version;
    this.auth = auth;
    this.payload = payload;
    this.chainId = chainId != null ? chainId : DEFAULT_CHAIN_ID;
    this.postConditionMode = postConditionMode != null ? postConditionMode : PostConditionMode.Deny;
    this.postConditions = postConditions != null ? postConditions : createLPList([]);

    if (anchorMode) {
      this.anchorMode = anchorMode;
    } else {
      switch (payload.payloadType) {
        case PayloadType.Coinbase:
        case PayloadType.PoisonMicroblock:
          {
            this.anchorMode = AnchorMode.OnChainOnly;
            break;
          }

        case PayloadType.ContractCall:
        case PayloadType.SmartContract:
        case PayloadType.TokenTransfer:
          {
            this.anchorMode = AnchorMode.Any;
            break;
          }
      }
    }
  }

  var _proto = StacksTransaction.prototype;

  _proto.signBegin = function signBegin() {
    var tx = cloneDeep(this);
    tx.auth = tx.auth.intoInitialSighashAuth();
    return tx.txid();
  };

  _proto.verifyBegin = function verifyBegin() {
    var tx = cloneDeep(this);
    tx.auth = tx.auth.intoInitialSighashAuth();
    return tx.txid();
  };

  _proto.createTxWithSignature = function createTxWithSignature(signature) {
    var parsedSig = typeof signature === 'string' ? signature : signature.toString('hex');
    var tx = cloneDeep(this);

    if (!tx.auth.spendingCondition) {
      throw new Error('Cannot set signature on transaction without spending condition');
    }

    tx.auth.spendingCondition.signature = createMessageSignature(parsedSig);
    return tx;
  };

  _proto.verifyOrigin = function verifyOrigin() {
    return this.auth.verifyOrigin(this.verifyBegin());
  };

  _proto.signNextOrigin = function signNextOrigin(sigHash, privateKey) {
    if (this.auth.spendingCondition === undefined) {
      throw new Error('"auth.spendingCondition" is undefined');
    }

    if (this.auth.authType === undefined) {
      throw new Error('"auth.authType" is undefined');
    }

    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);
  };

  _proto.signNextSponsor = function signNextSponsor(sigHash, privateKey) {
    if (this.auth.sponsorSpendingCondition === undefined) {
      throw new Error('"auth.spendingCondition" is undefined');
    }

    if (this.auth.authType === undefined) {
      throw new Error('"auth.authType" is undefined');
    }

    return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);
  };

  _proto.appendPubkey = function appendPubkey(publicKey) {
    var cond = this.auth.spendingCondition;

    if (cond && !isSingleSig(cond)) {
      var compressed = isCompressed(publicKey);
      cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));
    } else {
      throw new Error("Can't append public key to a singlesig condition");
    }
  };

  _proto.signAndAppend = function signAndAppend(condition, curSigHash, authType, privateKey) {
    var _nextSignature = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey),
        nextSig = _nextSignature.nextSig,
        nextSigHash = _nextSignature.nextSigHash;

    if (isSingleSig(condition)) {
      condition.signature = nextSig;
    } else {
      var compressed = privateKey.data.toString('hex').endsWith('01');
      condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));
    }

    return nextSigHash;
  };

  _proto.txid = function txid() {
    var serialized = this.serialize();
    return txidFromData(serialized);
  };

  _proto.setSponsor = function setSponsor(sponsorSpendingCondition) {
    if (this.auth.authType != AuthType.Sponsored) {
      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');
    }

    this.auth.setSponsor(sponsorSpendingCondition);
  };

  _proto.setFee = function setFee(amount) {
    this.auth.setFee(amount);
  };

  _proto.setNonce = function setNonce(nonce) {
    this.auth.setNonce(nonce);
  };

  _proto.setSponsorNonce = function setSponsorNonce(nonce) {
    this.auth.setSponsorNonce(nonce);
  };

  _proto.serialize = function serialize() {
    if (this.version === undefined) {
      throw new SerializationError('"version" is undefined');
    }

    if (this.chainId === undefined) {
      throw new SerializationError('"chainId" is undefined');
    }

    if (this.auth === undefined) {
      throw new SerializationError('"auth" is undefined');
    }

    if (this.anchorMode === undefined) {
      throw new SerializationError('"anchorMode" is undefined');
    }

    if (this.payload === undefined) {
      throw new SerializationError('"payload" is undefined');
    }

    var bufferArray = new BufferArray();
    bufferArray.appendByte(this.version);
    var chainIdBuffer = Buffer.alloc(4);
    chainIdBuffer.writeUInt32BE(this.chainId, 0);
    bufferArray.push(chainIdBuffer);
    bufferArray.push(this.auth.serialize());
    bufferArray.appendByte(this.anchorMode);
    bufferArray.appendByte(this.postConditionMode);
    bufferArray.push(serializeLPList(this.postConditions));
    bufferArray.push(serializePayload(this.payload));
    return bufferArray.concatBuffer();
  };

  return StacksTransaction;
}();
function deserializeTransaction(data) {
  var bufferReader;

  if (typeof data === 'string') {
    if (data.slice(0, 2).toLowerCase() === '0x') {
      bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));
    } else {
      bufferReader = new BufferReader(Buffer.from(data, 'hex'));
    }
  } else if (Buffer.isBuffer(data)) {
    bufferReader = new BufferReader(data);
  } else {
    bufferReader = data;
  }

  var version = bufferReader.readUInt8Enum(TransactionVersion, function (n) {
    throw new Error("Could not parse " + n + " as TransactionVersion");
  });
  var chainId = bufferReader.readUInt32BE();
  var auth = Authorization.deserialize(bufferReader);
  var anchorMode = bufferReader.readUInt8Enum(AnchorMode, function (n) {
    throw new Error("Could not parse " + n + " as AnchorMode");
  });
  var postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, function (n) {
    throw new Error("Could not parse " + n + " as PostConditionMode");
  });
  var postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);
  var payload = deserializePayload(bufferReader);
  return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);
}

export { StacksTransaction, deserializeTransaction };
//# sourceMappingURL=transaction.esm.js.map
