import { PayloadType, AnchorMode, PostConditionMode, AddressHashMode, TransactionVersion, AddressVersion } from './constants.esm.js';
import { asyncToGenerator as _asyncToGenerator, createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose, extends as _extends } from './_virtual/_rollupPluginBabelHelpers.js';
import runtime_1 from './node_modules/regenerator-runtime/runtime.esm.js';
import { c32address } from 'c32check';
import { publicKeyFromBuffer, createStacksPrivateKey, publicKeyToString, getPublicKey, publicKeyToAddress, pubKeyfromPrivKey } from './keys.esm.js';
import BigNum from 'bn.js';
import { createSTXPostCondition, createFungiblePostCondition, createNonFungiblePostCondition } from './postcondition.esm.js';
import { createTokenTransferPayload, createSmartContractPayload, createContractCallPayload } from './payload.esm.js';
import { createStandardPrincipal, createContractPrincipal, createLPList } from './types.esm.js';
import { omit, parseReadOnlyResponse, cvToHex } from './utils.esm.js';
import { createSingleSigSpendingCondition, createMultiSigSpendingCondition, SponsoredAuthorization, StandardAuthorization } from './authorization.esm.js';
import { StacksTransaction } from './transaction.esm.js';
import { StacksMainnet, StacksTestnet } from '@stacks/network';
import { TransactionSigner } from './signer.esm.js';
import { fetchPrivate } from '@stacks/common';
import { validateContractCall } from './contract-abi.esm.js';

function getNonce(_x, _x2) {
  return _getNonce.apply(this, arguments);
}

function _getNonce() {
  _getNonce = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(address, network) {
    var defaultNetwork, url, response, msg, result;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            defaultNetwork = new StacksMainnet();
            url = network ? network.getAccountApiUrl(address) : defaultNetwork.getAccountApiUrl(address);
            _context.next = 4;
            return fetchPrivate(url);

          case 4:
            response = _context.sent;

            if (response.ok) {
              _context.next = 16;
              break;
            }

            msg = '';
            _context.prev = 7;
            _context.next = 10;
            return response.text();

          case 10:
            msg = _context.sent;
            _context.next = 15;
            break;

          case 13:
            _context.prev = 13;
            _context.t0 = _context["catch"](7);

          case 15:
            throw new Error("Error fetching nonce. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

          case 16:
            _context.next = 18;
            return response.json();

          case 18:
            result = _context.sent;
            return _context.abrupt("return", new BigNum(result.nonce));

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[7, 13]]);
  }));
  return _getNonce.apply(this, arguments);
}

function estimateTransfer(_x3, _x4) {
  return _estimateTransfer.apply(this, arguments);
}

function _estimateTransfer() {
  _estimateTransfer = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(transaction, network) {
    var requestHeaders, fetchOptions, defaultNetwork, url, response, msg, feeRateResult, txBytes, feeRate;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(transaction.payload.payloadType !== PayloadType.TokenTransfer)) {
              _context2.next = 2;
              break;
            }

            throw new Error("Transaction fee estimation only possible with " + PayloadType[PayloadType.TokenTransfer] + " transactions. Invoked with: " + PayloadType[transaction.payload.payloadType]);

          case 2:
            requestHeaders = {
              Accept: 'application/text'
            };
            fetchOptions = {
              method: 'GET',
              headers: requestHeaders
            };
            defaultNetwork = new StacksMainnet();
            url = network ? network.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();
            _context2.next = 8;
            return fetchPrivate(url, fetchOptions);

          case 8:
            response = _context2.sent;

            if (response.ok) {
              _context2.next = 20;
              break;
            }

            msg = '';
            _context2.prev = 11;
            _context2.next = 14;
            return response.text();

          case 14:
            msg = _context2.sent;
            _context2.next = 19;
            break;

          case 17:
            _context2.prev = 17;
            _context2.t0 = _context2["catch"](11);

          case 19:
            throw new Error("Error estimating transaction fee. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

          case 20:
            _context2.next = 22;
            return response.text();

          case 22:
            feeRateResult = _context2.sent;
            txBytes = new BigNum(transaction.serialize().byteLength);
            feeRate = new BigNum(feeRateResult);
            return _context2.abrupt("return", feeRate.mul(txBytes));

          case 26:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[11, 17]]);
  }));
  return _estimateTransfer.apply(this, arguments);
}

function broadcastTransaction(_x5, _x6, _x7) {
  return _broadcastTransaction.apply(this, arguments);
}

function _broadcastTransaction() {
  _broadcastTransaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(transaction, network, attachment) {
    var rawTx, url;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            rawTx = transaction.serialize();
            url = network.getBroadcastApiUrl();
            return _context3.abrupt("return", broadcastRawTransaction(rawTx, url, attachment));

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _broadcastTransaction.apply(this, arguments);
}

function broadcastRawTransaction(_x8, _x9, _x10) {
  return _broadcastRawTransaction.apply(this, arguments);
}

function _broadcastRawTransaction() {
  _broadcastRawTransaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(rawTx, url, attachment) {
    var options, response, text;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            options = {
              method: 'POST',
              headers: {
                'Content-Type': attachment ? 'application/json' : 'application/octet-stream'
              },
              body: attachment ? JSON.stringify({
                tx: rawTx.toString('hex'),
                attachment: attachment.toString('hex')
              }) : rawTx
            };
            _context4.next = 3;
            return fetchPrivate(url, options);

          case 3:
            response = _context4.sent;

            if (response.ok) {
              _context4.next = 14;
              break;
            }

            _context4.prev = 5;
            _context4.next = 8;
            return response.json();

          case 8:
            return _context4.abrupt("return", _context4.sent);

          case 11:
            _context4.prev = 11;
            _context4.t0 = _context4["catch"](5);
            throw Error("Failed to broadcast transaction: " + _context4.t0.message);

          case 14:
            _context4.next = 16;
            return response.text();

          case 16:
            text = _context4.sent;
            _context4.prev = 17;
            return _context4.abrupt("return", JSON.parse(text));

          case 21:
            _context4.prev = 21;
            _context4.t1 = _context4["catch"](17);
            return _context4.abrupt("return", text);

          case 24:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[5, 11], [17, 21]]);
  }));
  return _broadcastRawTransaction.apply(this, arguments);
}

function getAbi(_x11, _x12, _x13) {
  return _getAbi.apply(this, arguments);
}

function _getAbi() {
  _getAbi = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(address, contractName, network) {
    var options, url, response, msg;
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            options = {
              method: 'GET'
            };
            url = network.getAbiApiUrl(address, contractName);
            _context5.next = 4;
            return fetchPrivate(url, options);

          case 4:
            response = _context5.sent;

            if (response.ok) {
              _context5.next = 16;
              break;
            }

            msg = '';
            _context5.prev = 7;
            _context5.next = 10;
            return response.text();

          case 10:
            msg = _context5.sent;
            _context5.next = 15;
            break;

          case 13:
            _context5.prev = 13;
            _context5.t0 = _context5["catch"](7);

          case 15:
            throw new Error("Error fetching contract ABI for contract \"" + contractName + "\" at address " + address + ". Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

          case 16:
            _context5.t1 = JSON;
            _context5.next = 19;
            return response.text();

          case 19:
            _context5.t2 = _context5.sent;
            return _context5.abrupt("return", _context5.t1.parse.call(_context5.t1, _context5.t2));

          case 21:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[7, 13]]);
  }));
  return _getAbi.apply(this, arguments);
}

function makeUnsignedSTXTokenTransfer(_x14) {
  return _makeUnsignedSTXTokenTransfer.apply(this, arguments);
}

function _makeUnsignedSTXTokenTransfer() {
  _makeUnsignedSTXTokenTransfer = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(txOptions) {
    var defaultOptions, options, payload, authorization, spendingCondition, postConditions, lpPostConditions, transaction, txFee, addressVersion, senderAddress, txNonce;
    return runtime_1.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            defaultOptions = {
              fee: new BigNum(0),
              nonce: new BigNum(0),
              network: new StacksMainnet(),
              anchorMode: AnchorMode.Any,
              postConditionMode: PostConditionMode.Deny,
              memo: '',
              sponsored: false
            };
            options = Object.assign(defaultOptions, txOptions);
            payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);
            authorization = null;
            spendingCondition = null;

            if ('publicKey' in options) {
              spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
            } else {
              spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
            }

            if (options.sponsored) {
              authorization = new SponsoredAuthorization(spendingCondition);
            } else {
              authorization = new StandardAuthorization(spendingCondition);
            }

            postConditions = [];

            if (options.postConditions && options.postConditions.length > 0) {
              options.postConditions.forEach(function (postCondition) {
                postConditions.push(postCondition);
              });
            }

            lpPostConditions = createLPList(postConditions);
            transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, defaultOptions.anchorMode, options.network.chainId);

            if (txOptions.fee) {
              _context6.next = 16;
              break;
            }

            _context6.next = 14;
            return estimateTransfer(transaction, options.network);

          case 14:
            txFee = _context6.sent;
            transaction.setFee(txFee);

          case 16:
            if (txOptions.nonce) {
              _context6.next = 23;
              break;
            }

            addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;
            senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);
            _context6.next = 21;
            return getNonce(senderAddress, options.network);

          case 21:
            txNonce = _context6.sent;
            transaction.setNonce(txNonce);

          case 23:
            return _context6.abrupt("return", transaction);

          case 24:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _makeUnsignedSTXTokenTransfer.apply(this, arguments);
}

function makeSTXTokenTransfer(_x15) {
  return _makeSTXTokenTransfer.apply(this, arguments);
}

function _makeSTXTokenTransfer() {
  _makeSTXTokenTransfer = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(txOptions) {
    var publicKey, options, transaction, privKey, signer, _options, _transaction, _signer, pubKeys, _loop, _iterator, _step, _iterator2, _step2, key;

    return runtime_1.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (!('senderKey' in txOptions)) {
              _context7.next = 12;
              break;
            }

            publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));
            options = omit(txOptions, 'senderKey');
            _context7.next = 5;
            return makeUnsignedSTXTokenTransfer(_extends({
              publicKey: publicKey
            }, options));

          case 5:
            transaction = _context7.sent;
            privKey = createStacksPrivateKey(txOptions.senderKey);
            signer = new TransactionSigner(transaction);
            signer.signOrigin(privKey);
            return _context7.abrupt("return", transaction);

          case 12:
            _options = omit(txOptions, 'signerKeys');
            _context7.next = 15;
            return makeUnsignedSTXTokenTransfer(_options);

          case 15:
            _transaction = _context7.sent;
            _signer = new TransactionSigner(_transaction);
            pubKeys = txOptions.publicKeys;

            _loop = function _loop() {
              var key = _step.value;
              var pubKey = pubKeyfromPrivKey(key);
              pubKeys = pubKeys.filter(function (pk) {
                return pk !== pubKey.data.toString('hex');
              });

              _signer.signOrigin(createStacksPrivateKey(key));
            };

            for (_iterator = _createForOfIteratorHelperLoose(txOptions.signerKeys); !(_step = _iterator()).done;) {
              _loop();
            }

            for (_iterator2 = _createForOfIteratorHelperLoose(pubKeys); !(_step2 = _iterator2()).done;) {
              key = _step2.value;

              _signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));
            }

            return _context7.abrupt("return", _transaction);

          case 22:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _makeSTXTokenTransfer.apply(this, arguments);
}

function estimateContractDeploy(_x16, _x17) {
  return _estimateContractDeploy.apply(this, arguments);
}

function _estimateContractDeploy() {
  _estimateContractDeploy = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(transaction, network) {
    var requestHeaders, fetchOptions, defaultNetwork, url, response, msg, feeRateResult, txBytes, feeRate;
    return runtime_1.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (!(transaction.payload.payloadType !== PayloadType.SmartContract)) {
              _context8.next = 2;
              break;
            }

            throw new Error("Contract deploy fee estimation only possible with " + PayloadType[PayloadType.SmartContract] + " transactions. Invoked with: " + PayloadType[transaction.payload.payloadType]);

          case 2:
            requestHeaders = {
              Accept: 'application/text'
            };
            fetchOptions = {
              method: 'GET',
              headers: requestHeaders
            };
            defaultNetwork = new StacksMainnet();
            url = network ? network.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();
            _context8.next = 8;
            return fetchPrivate(url, fetchOptions);

          case 8:
            response = _context8.sent;

            if (response.ok) {
              _context8.next = 20;
              break;
            }

            msg = '';
            _context8.prev = 11;
            _context8.next = 14;
            return response.text();

          case 14:
            msg = _context8.sent;
            _context8.next = 19;
            break;

          case 17:
            _context8.prev = 17;
            _context8.t0 = _context8["catch"](11);

          case 19:
            throw new Error("Error estimating contract deploy fee. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

          case 20:
            _context8.next = 22;
            return response.text();

          case 22:
            feeRateResult = _context8.sent;
            txBytes = new BigNum(transaction.serialize().byteLength);
            feeRate = new BigNum(feeRateResult);
            return _context8.abrupt("return", feeRate.mul(txBytes));

          case 26:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, null, [[11, 17]]);
  }));
  return _estimateContractDeploy.apply(this, arguments);
}

function makeContractDeploy(_x18) {
  return _makeContractDeploy.apply(this, arguments);
}

function _makeContractDeploy() {
  _makeContractDeploy = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(txOptions) {
    var defaultOptions, options, payload, addressHashMode, privKey, pubKey, authorization, spendingCondition, postConditions, lpPostConditions, transaction, txFee, addressVersion, senderAddress, txNonce, signer;
    return runtime_1.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            defaultOptions = {
              fee: new BigNum(0),
              nonce: new BigNum(0),
              network: new StacksMainnet(),
              anchorMode: AnchorMode.Any,
              postConditionMode: PostConditionMode.Deny,
              sponsored: false
            };
            options = Object.assign(defaultOptions, txOptions);
            payload = createSmartContractPayload(options.contractName, options.codeBody);
            addressHashMode = AddressHashMode.SerializeP2PKH;
            privKey = createStacksPrivateKey(options.senderKey);
            pubKey = getPublicKey(privKey);
            authorization = null;
            spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);

            if (options.sponsored) {
              authorization = new SponsoredAuthorization(spendingCondition);
            } else {
              authorization = new StandardAuthorization(spendingCondition);
            }

            postConditions = [];

            if (options.postConditions && options.postConditions.length > 0) {
              options.postConditions.forEach(function (postCondition) {
                postConditions.push(postCondition);
              });
            }

            lpPostConditions = createLPList(postConditions);
            transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);

            if (txOptions.fee) {
              _context9.next = 18;
              break;
            }

            _context9.next = 16;
            return estimateContractDeploy(transaction, options.network);

          case 16:
            txFee = _context9.sent;
            transaction.setFee(txFee);

          case 18:
            if (txOptions.nonce) {
              _context9.next = 25;
              break;
            }

            addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;
            senderAddress = publicKeyToAddress(addressVersion, pubKey);
            _context9.next = 23;
            return getNonce(senderAddress, options.network);

          case 23:
            txNonce = _context9.sent;
            transaction.setNonce(txNonce);

          case 25:
            if (options.senderKey) {
              signer = new TransactionSigner(transaction);
              signer.signOrigin(privKey);
            }

            return _context9.abrupt("return", transaction);

          case 27:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _makeContractDeploy.apply(this, arguments);
}

function estimateContractFunctionCall(_x19, _x20) {
  return _estimateContractFunctionCall.apply(this, arguments);
}

function _estimateContractFunctionCall() {
  _estimateContractFunctionCall = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(transaction, network) {
    var requestHeaders, fetchOptions, defaultNetwork, url, response, msg, feeRateResult, txBytes, feeRate;
    return runtime_1.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            if (!(transaction.payload.payloadType !== PayloadType.ContractCall)) {
              _context10.next = 2;
              break;
            }

            throw new Error("Contract call fee estimation only possible with " + PayloadType[PayloadType.ContractCall] + " transactions. Invoked with: " + PayloadType[transaction.payload.payloadType]);

          case 2:
            requestHeaders = {
              Accept: 'application/text'
            };
            fetchOptions = {
              method: 'GET',
              headers: requestHeaders
            };
            defaultNetwork = new StacksMainnet();
            url = network ? network.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();
            _context10.next = 8;
            return fetchPrivate(url, fetchOptions);

          case 8:
            response = _context10.sent;

            if (response.ok) {
              _context10.next = 20;
              break;
            }

            msg = '';
            _context10.prev = 11;
            _context10.next = 14;
            return response.text();

          case 14:
            msg = _context10.sent;
            _context10.next = 19;
            break;

          case 17:
            _context10.prev = 17;
            _context10.t0 = _context10["catch"](11);

          case 19:
            throw new Error("Error estimating contract call fee. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

          case 20:
            _context10.next = 22;
            return response.text();

          case 22:
            feeRateResult = _context10.sent;
            txBytes = new BigNum(transaction.serialize().byteLength);
            feeRate = new BigNum(feeRateResult);
            return _context10.abrupt("return", feeRate.mul(txBytes));

          case 26:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, null, [[11, 17]]);
  }));
  return _estimateContractFunctionCall.apply(this, arguments);
}

function makeUnsignedContractCall(_x21) {
  return _makeUnsignedContractCall.apply(this, arguments);
}

function _makeUnsignedContractCall() {
  _makeUnsignedContractCall = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(txOptions) {
    var defaultOptions, options, payload, abi, spendingCondition, authorization, postConditions, lpPostConditions, transaction, txFee, addressVersion, senderAddress, txNonce;
    return runtime_1.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            defaultOptions = {
              fee: new BigNum(0),
              nonce: new BigNum(0),
              network: new StacksMainnet(),
              anchorMode: AnchorMode.Any,
              postConditionMode: PostConditionMode.Deny,
              sponsored: false
            };
            options = Object.assign(defaultOptions, txOptions);
            payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);

            if (!(options == null ? void 0 : options.validateWithAbi)) {
              _context11.next = 16;
              break;
            }

            if (!(typeof options.validateWithAbi === 'boolean')) {
              _context11.next = 14;
              break;
            }

            if (!(options == null ? void 0 : options.network)) {
              _context11.next = 11;
              break;
            }

            _context11.next = 8;
            return getAbi(options.contractAddress, options.contractName, options.network);

          case 8:
            abi = _context11.sent;
            _context11.next = 12;
            break;

          case 11:
            throw new Error('Network option must be provided in order to validate with ABI');

          case 12:
            _context11.next = 15;
            break;

          case 14:
            abi = options.validateWithAbi;

          case 15:
            validateContractCall(payload, abi);

          case 16:
            spendingCondition = null;
            authorization = null;

            if ('publicKey' in options) {
              spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
            } else {
              spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
            }

            if (options.sponsored) {
              authorization = new SponsoredAuthorization(spendingCondition);
            } else {
              authorization = new StandardAuthorization(spendingCondition);
            }

            postConditions = [];

            if (options.postConditions && options.postConditions.length > 0) {
              options.postConditions.forEach(function (postCondition) {
                postConditions.push(postCondition);
              });
            }

            lpPostConditions = createLPList(postConditions);
            transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);

            if (txOptions.fee) {
              _context11.next = 29;
              break;
            }

            _context11.next = 27;
            return estimateContractFunctionCall(transaction, options.network);

          case 27:
            txFee = _context11.sent;
            transaction.setFee(txFee);

          case 29:
            if (txOptions.nonce) {
              _context11.next = 36;
              break;
            }

            addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;
            senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);
            _context11.next = 34;
            return getNonce(senderAddress, options.network);

          case 34:
            txNonce = _context11.sent;
            transaction.setNonce(txNonce);

          case 36:
            return _context11.abrupt("return", transaction);

          case 37:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));
  return _makeUnsignedContractCall.apply(this, arguments);
}

function makeContractCall(_x22) {
  return _makeContractCall.apply(this, arguments);
}

function _makeContractCall() {
  _makeContractCall = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(txOptions) {
    var publicKey, options, transaction, privKey, signer, _options2, _transaction2, _signer2, _pubKeys, _loop2, _iterator3, _step3, _iterator4, _step4, key;

    return runtime_1.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            if (!('senderKey' in txOptions)) {
              _context12.next = 12;
              break;
            }

            publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));
            options = omit(txOptions, 'senderKey');
            _context12.next = 5;
            return makeUnsignedContractCall(_extends({
              publicKey: publicKey
            }, options));

          case 5:
            transaction = _context12.sent;
            privKey = createStacksPrivateKey(txOptions.senderKey);
            signer = new TransactionSigner(transaction);
            signer.signOrigin(privKey);
            return _context12.abrupt("return", transaction);

          case 12:
            _options2 = omit(txOptions, 'signerKeys');
            _context12.next = 15;
            return makeUnsignedContractCall(_options2);

          case 15:
            _transaction2 = _context12.sent;
            _signer2 = new TransactionSigner(_transaction2);
            _pubKeys = txOptions.publicKeys;

            _loop2 = function _loop2() {
              var key = _step3.value;
              var pubKey = pubKeyfromPrivKey(key);
              _pubKeys = _pubKeys.filter(function (pk) {
                return pk !== pubKey.data.toString('hex');
              });

              _signer2.signOrigin(createStacksPrivateKey(key));
            };

            for (_iterator3 = _createForOfIteratorHelperLoose(txOptions.signerKeys); !(_step3 = _iterator3()).done;) {
              _loop2();
            }

            for (_iterator4 = _createForOfIteratorHelperLoose(_pubKeys); !(_step4 = _iterator4()).done;) {
              key = _step4.value;

              _signer2.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));
            }

            return _context12.abrupt("return", _transaction2);

          case 22:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));
  return _makeContractCall.apply(this, arguments);
}

function makeStandardSTXPostCondition(address, conditionCode, amount) {
  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);
}
function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
  return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);
}
function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
  return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);
}
function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
  return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);
}
function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {
  return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetName);
}
function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {
  return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);
}
function callReadOnlyFunction(_x23) {
  return _callReadOnlyFunction.apply(this, arguments);
}

function _callReadOnlyFunction() {
  _callReadOnlyFunction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(readOnlyFunctionOptions) {
    var defaultOptions, options, contractName, contractAddress, functionName, functionArgs, network, senderAddress, url, args, body, response, msg;
    return runtime_1.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            defaultOptions = {
              network: new StacksMainnet()
            };
            options = Object.assign(defaultOptions, readOnlyFunctionOptions);
            contractName = options.contractName, contractAddress = options.contractAddress, functionName = options.functionName, functionArgs = options.functionArgs, network = options.network, senderAddress = options.senderAddress;
            url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);
            args = functionArgs.map(function (arg) {
              return cvToHex(arg);
            });
            body = JSON.stringify({
              sender: senderAddress,
              arguments: args
            });
            _context13.next = 8;
            return fetchPrivate(url, {
              method: 'POST',
              body: body,
              headers: {
                'Content-Type': 'application/json'
              }
            });

          case 8:
            response = _context13.sent;

            if (response.ok) {
              _context13.next = 20;
              break;
            }

            msg = '';
            _context13.prev = 11;
            _context13.next = 14;
            return response.text();

          case 14:
            msg = _context13.sent;
            _context13.next = 19;
            break;

          case 17:
            _context13.prev = 17;
            _context13.t0 = _context13["catch"](11);

          case 19:
            throw new Error("Error calling read-only function. Response " + response.status + ": " + response.statusText + ". Attempted to fetch " + url + " and failed with the message: \"" + msg + "\"");

          case 20:
            return _context13.abrupt("return", response.json().then(function (responseJson) {
              return parseReadOnlyResponse(responseJson);
            }));

          case 21:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13, null, [[11, 17]]);
  }));
  return _callReadOnlyFunction.apply(this, arguments);
}

function sponsorTransaction(_x24) {
  return _sponsorTransaction.apply(this, arguments);
}

function _sponsorTransaction() {
  _sponsorTransaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(sponsorOptions) {
    var _sponsorOptions$netwo;

    var defaultOptions, options, network, sponsorPubKey, txFee, addressVersion, senderAddress, sponsorNonce, sponsorSpendingCondition, privKey, signer;
    return runtime_1.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            defaultOptions = {
              fee: new BigNum(0),
              sponsorNonce: new BigNum(0),
              sponsorAddressHashmode: AddressHashMode.SerializeP2PKH
            };
            options = Object.assign(defaultOptions, sponsorOptions);
            network = (_sponsorOptions$netwo = sponsorOptions.network) != null ? _sponsorOptions$netwo : options.transaction.version === TransactionVersion.Mainnet ? new StacksMainnet() : new StacksTestnet();
            sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);

            if (sponsorOptions.fee) {
              _context14.next = 24;
              break;
            }

            txFee = new BigNum(0);
            _context14.t0 = options.transaction.payload.payloadType;
            _context14.next = _context14.t0 === PayloadType.TokenTransfer ? 9 : _context14.t0 === PayloadType.SmartContract ? 13 : _context14.t0 === PayloadType.ContractCall ? 17 : 21;
            break;

          case 9:
            _context14.next = 11;
            return estimateTransfer(options.transaction, network);

          case 11:
            txFee = _context14.sent;
            return _context14.abrupt("break", 22);

          case 13:
            _context14.next = 15;
            return estimateContractDeploy(options.transaction, network);

          case 15:
            txFee = _context14.sent;
            return _context14.abrupt("break", 22);

          case 17:
            _context14.next = 19;
            return estimateContractFunctionCall(options.transaction, network);

          case 19:
            txFee = _context14.sent;
            return _context14.abrupt("break", 22);

          case 21:
            throw new Error("Sponsored transactions not supported for transaction type " + PayloadType[options.transaction.payload.payloadType]);

          case 22:
            options.transaction.setFee(txFee);
            options.fee = txFee;

          case 24:
            if (sponsorOptions.sponsorNonce) {
              _context14.next = 31;
              break;
            }

            addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;
            senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);
            _context14.next = 29;
            return getNonce(senderAddress, network);

          case 29:
            sponsorNonce = _context14.sent;
            options.sponsorNonce = sponsorNonce;

          case 31:
            sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);
            options.transaction.setSponsor(sponsorSpendingCondition);
            privKey = createStacksPrivateKey(options.sponsorPrivateKey);
            signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);
            signer.signSponsor(privKey);
            return _context14.abrupt("return", options.transaction);

          case 37:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));
  return _sponsorTransaction.apply(this, arguments);
}

export { broadcastRawTransaction, broadcastTransaction, callReadOnlyFunction, estimateContractDeploy, estimateContractFunctionCall, estimateTransfer, getAbi, getNonce, makeContractCall, makeContractDeploy, makeContractFungiblePostCondition, makeContractNonFungiblePostCondition, makeContractSTXPostCondition, makeSTXTokenTransfer, makeStandardFungiblePostCondition, makeStandardNonFungiblePostCondition, makeStandardSTXPostCondition, makeUnsignedContractCall, makeUnsignedSTXTokenTransfer, sponsorTransaction };
//# sourceMappingURL=builders.esm.js.map
