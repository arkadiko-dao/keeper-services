import { inheritsLoose as _inheritsLoose, assertThisInitialized as _assertThisInitialized, wrapNativeSuper as _wrapNativeSuper } from './_virtual/_rollupPluginBabelHelpers.js';
import { AddressHashMode } from '@stacks/transactions';
import BN from 'bn.js';
import { StackingErrors } from './constants.esm.js';
import { address } from 'bitcoinjs-lib';

var InvalidAddressError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(InvalidAddressError, _Error);

  function InvalidAddressError(address, innerError) {
    var _this;

    var msg = address + " is not a valid P2PKH or P2SH address -- native P2WPKH and native P2WSH are not supported in PoX.";
    _this = _Error.call(this, msg) || this;
    _this.message = msg;
    _this.name = _this.constructor.name;
    _this.innerError = innerError;

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    }

    return _this;
  }

  return InvalidAddressError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
function btcAddressVersionToHashMode(btcAddressVersion) {
  switch (btcAddressVersion) {
    case 0:
      return AddressHashMode.SerializeP2PKH;

    case 111:
      return AddressHashMode.SerializeP2PKH;

    case 5:
      return AddressHashMode.SerializeP2SH;

    case 196:
      return AddressHashMode.SerializeP2SH;

    default:
      throw new Error('Invalid pox address version');
  }
}
function getAddressHashMode(btcAddress) {
  try {
    var _address$fromBase58Ch = address.fromBase58Check(btcAddress),
        version = _address$fromBase58Ch.version;

    return btcAddressVersionToHashMode(version);
  } catch (error) {
    throw new InvalidAddressError(btcAddress, error);
  }
}
function decodeBtcAddress(btcAddress) {
  var b58Result;

  try {
    b58Result = address.fromBase58Check(btcAddress);
  } catch (error) {
    throw new InvalidAddressError(btcAddress, error);
  }

  var hashMode = btcAddressVersionToHashMode(b58Result.version);
  return {
    hashMode: hashMode,
    data: b58Result.hash
  };
}
function getBTCAddress(version, checksum) {
  var btcAddress = address.toBase58Check(checksum, new BN(version).toNumber());
  return btcAddress;
}
function getErrorString(error) {
  switch (error) {
    case StackingErrors.ERR_STACKING_UNREACHABLE:
      return 'Stacking unreachable';

    case StackingErrors.ERR_STACKING_INSUFFICIENT_FUNDS:
      return 'Insufficient funds';

    case StackingErrors.ERR_STACKING_INVALID_LOCK_PERIOD:
      return 'Invalid lock period';

    case StackingErrors.ERR_STACKING_ALREADY_STACKED:
      return 'Account already stacked. Concurrent stacking not allowed.';

    case StackingErrors.ERR_STACKING_NO_SUCH_PRINCIPAL:
      return 'Principal does not exist';

    case StackingErrors.ERR_STACKING_EXPIRED:
      return 'Stacking expired';

    case StackingErrors.ERR_STACKING_STX_LOCKED:
      return 'STX balance is locked';

    case StackingErrors.ERR_STACKING_PERMISSION_DENIED:
      return 'Permission denied';

    case StackingErrors.ERR_STACKING_THRESHOLD_NOT_MET:
      return 'Stacking threshold not met';

    case StackingErrors.ERR_STACKING_POX_ADDRESS_IN_USE:
      return 'PoX address already in use';

    case StackingErrors.ERR_STACKING_INVALID_POX_ADDRESS:
      return 'Invalid PoX address';

    case StackingErrors.ERR_STACKING_ALREADY_REJECTED:
      return 'Stacking already rejected';

    case StackingErrors.ERR_STACKING_INVALID_AMOUNT:
      return 'Invalid amount';

    case StackingErrors.ERR_NOT_ALLOWED:
      return 'Stacking not allowed';

    case StackingErrors.ERR_STACKING_ALREADY_DELEGATED:
      return 'Already delegated';

    case StackingErrors.ERR_DELEGATION_EXPIRES_DURING_LOCK:
      return 'Delegation expires during lock period';

    case StackingErrors.ERR_DELEGATION_TOO_MUCH_LOCKED:
      return 'Delegation too much locked';

    case StackingErrors.ERR_DELEGATION_POX_ADDR_REQUIRED:
      return 'PoX address required for delegation';

    case StackingErrors.ERR_INVALID_START_BURN_HEIGHT:
      return 'Invalid start burn height';
  }
}

export { InvalidAddressError, btcAddressVersionToHashMode, decodeBtcAddress, getAddressHashMode, getBTCAddress, getErrorString };
//# sourceMappingURL=utils.esm.js.map
