import { Logger } from './logger.esm.js';

var BLOCKSTACK_HANDLER = 'blockstack';
function nextYear() {
  return new Date(new Date().setFullYear(new Date().getFullYear() + 1));
}
function nextMonth() {
  return new Date(new Date().setMonth(new Date().getMonth() + 1));
}
function nextHour() {
  return new Date(new Date().setHours(new Date().getHours() + 1));
}
function megabytesToBytes(megabytes) {
  if (!Number.isFinite(megabytes)) {
    return 0;
  }

  return Math.floor(megabytes * 1024 * 1024);
}
function getAesCbcOutputLength(inputByteLength) {
  var cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;
  return cipherTextLength;
}
function getBase64OutputLength(inputByteLength) {
  var encodedLength = Math.ceil(inputByteLength / 3) * 4;
  return encodedLength;
}
function updateQueryStringParameter(uri, key, value) {
  var re = new RegExp("([?&])" + key + "=.*?(&|$)", 'i');
  var separator = uri.indexOf('?') !== -1 ? '&' : '?';

  if (uri.match(re)) {
    return uri.replace(re, "$1" + key + "=" + value + "$2");
  } else {
    return "" + uri + separator + key + "=" + value;
  }
}
function isLaterVersion(v1, v2) {
  if (v1 === undefined || v1 === '') {
    v1 = '0.0.0';
  }

  if (v2 === undefined || v1 === '') {
    v2 = '0.0.0';
  }

  var v1tuple = v1.split('.').map(function (x) {
    return parseInt(x, 10);
  });
  var v2tuple = v2.split('.').map(function (x) {
    return parseInt(x, 10);
  });

  for (var index = 0; index < v2.length; index++) {
    if (index >= v1.length) {
      v2tuple.push(0);
    }

    if (v1tuple[index] < v2tuple[index]) {
      return false;
    }
  }

  return true;
}
function makeUUID4() {
  var d = new Date().getTime();

  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
    d += performance.now();
  }

  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
  });
}
function isSameOriginAbsoluteUrl(uri1, uri2) {
  try {
    var parseUrl;

    if (typeof URL !== 'undefined') {
      parseUrl = function parseUrl(url) {
        return new URL(url);
      };
    } else {
      try {
        var nodeUrl = require('url').URL;

        parseUrl = function parseUrl(url) {
          return new nodeUrl(url);
        };
      } catch (error) {
        console.log(error);
        throw new Error('Global URL class is not available');
      }
    }

    var parsedUri1 = parseUrl(uri1);
    var parsedUri2 = parseUrl(uri2);
    var port1 = parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);
    var port2 = parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);
    var match = {
      scheme: parsedUri1.protocol === parsedUri2.protocol,
      hostname: parsedUri1.hostname === parsedUri2.hostname,
      port: port1 === port2,
      absolute: (uri1.includes('http://') || uri1.includes('https://')) && (uri2.includes('http://') || uri2.includes('https://'))
    };
    return match.scheme && match.hostname && match.port && match.absolute;
  } catch (error) {
    console.log(error);
    console.log('Parsing error in same URL origin check');
    return false;
  }
}
function getGlobalScope() {
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof global !== 'undefined') {
    return global;
  }

  throw new Error('Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available');
}

function getAPIUsageErrorMessage(scopeObject, apiName, usageDesc) {
  if (usageDesc) {
    return "Use of '" + usageDesc + "' requires `" + apiName + "` which is unavailable on the '" + scopeObject + "' object within the currently executing environment.";
  } else {
    return "`" + apiName + "` is unavailable on the '" + scopeObject + "' object within the currently executing environment.";
  }
}

function getGlobalObject(name, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      throwIfUnavailable = _ref.throwIfUnavailable,
      usageDesc = _ref.usageDesc,
      returnEmptyObject = _ref.returnEmptyObject;

  var globalScope = undefined;

  try {
    globalScope = getGlobalScope();

    if (globalScope) {
      var obj = globalScope[name];

      if (obj) {
        return obj;
      }
    }
  } catch (error) {
    Logger.error("Error getting object '" + name + "' from global scope '" + globalScope + "': " + error);
  }

  if (throwIfUnavailable) {
    var errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
    Logger.error(errMsg);
    throw new Error(errMsg);
  }

  if (returnEmptyObject) {
    return {};
  }

  return undefined;
}
function getGlobalObjects(names, _temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2,
      throwIfUnavailable = _ref2.throwIfUnavailable,
      usageDesc = _ref2.usageDesc,
      returnEmptyObject = _ref2.returnEmptyObject;

  var globalScope;

  try {
    globalScope = getGlobalScope();
  } catch (error) {
    Logger.error("Error getting global scope: " + error);

    if (throwIfUnavailable) {
      var errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);
      Logger.error(errMsg);
      throw errMsg;
    } else if (returnEmptyObject) {
      globalScope = {};
    }
  }

  var result = {};

  for (var i = 0; i < names.length; i++) {
    var name = names[i];

    try {
      if (globalScope) {
        var obj = globalScope[name];

        if (obj) {
          result[name] = obj;
        } else if (throwIfUnavailable) {
          var _errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);

          Logger.error(_errMsg);
          throw new Error(_errMsg);
        } else if (returnEmptyObject) {
          result[name] = {};
        }
      }
    } catch (error) {
      if (throwIfUnavailable) {
        var _errMsg2 = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);

        Logger.error(_errMsg2);
        throw new Error(_errMsg2);
      }
    }
  }

  return result;
}

export { BLOCKSTACK_HANDLER, getAesCbcOutputLength, getBase64OutputLength, getGlobalObject, getGlobalObjects, getGlobalScope, isLaterVersion, isSameOriginAbsoluteUrl, makeUUID4, megabytesToBytes, nextHour, nextMonth, nextYear, updateQueryStringParameter };
//# sourceMappingURL=utils.esm.js.map
